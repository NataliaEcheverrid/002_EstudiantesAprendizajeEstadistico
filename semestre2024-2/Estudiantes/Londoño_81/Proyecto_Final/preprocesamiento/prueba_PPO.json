[
  {
    "full_name": "CategoryTheory.Equivalence.invFunIdAssoc_hom_app",
    "file_path": "Mathlib/CategoryTheory/Equivalence.lean",
    "teorema": "lemma CategoryTheory.Equivalence.invFunIdAssoc_hom_app (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (E : Type u‚ÇÉ) (F : D ‚•§ E) (X : D) (e : C ‚âå D) : (e.invFunIdAssoc F).hom.app X = F.map (e.counit.app X) := by"
  },
  {
    "full_name": "ENNReal.le_rpow_one_div_iff",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "theorem ENNReal.le_rpow_one_div_iff (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù‚â•0‚àû) (z : ‚Ñù) : x ‚â§ y ^ (1 / z) ‚Üî x ^ z ‚â§ y := by"
  },
  {
    "full_name": "Combinatorics.Line.apply_of_ne_none",
    "file_path": "Mathlib/Combinatorics/HalesJewett.lean",
    "teorema": "theorem Combinatorics.Line.apply_of_ne_none (i : Œπ) (l : Line Œ± Œπ) (x : Œ±) (Œ± : Type u_1) (Œπ : Type u_2) : some ((fun x i => (l.idxFun i).getD x) x i) = l.idxFun i := by"
  },
  {
    "full_name": "CancelDenoms.cancel_factors_lt",
    "file_path": "Mathlib/Tactic/CancelDenoms/Core.lean",
    "teorema": "lemma CancelDenoms.cancel_factors_lt (a : Œ±) (ad : Œ±) (b : Œ±) (bd : Œ±) (gcd : Œ±) (Œ± : Type u_1) : (a < b) = (1 / gcd * (bd * a') < 1 / gcd * (ad * b')) := by"
  },
  {
    "full_name": "Batteries.BinomialHeap.Imp.Heap.WF.tail?",
    "file_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "teorema": "lemma Batteries.BinomialHeap.Imp.Heap.WF.tail? (le : Œ± ‚Üí Œ± ‚Üí Bool) (s : Heap Œ±) (tl : Heap Œ±) (Œ± : Type u_1) : Heap.tail? le s = some tl ‚Üí WF le 0 tl := by"
  },
  {
    "full_name": "Ideal.span_singleton_eq_span_singleton",
    "file_path": "Mathlib/RingTheory/Ideal/Basic.lean",
    "teorema": "lemma Ideal.span_singleton_eq_span_singleton (x : Œ±) (y : Œ±) (Œ± : Type u) : span {x} = span {y} ‚Üî Associated x y := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.comap_ofFunction",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean",
    "teorema": "lemma MeasureTheory.OuterMeasure.comap_ofFunction (f : Œ≤ ‚Üí Œ±) (m : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œ≤ : Type ?u.25201) : (fun s => m (f '' s)) ‚àÖ = 0 := by"
  },
  {
    "full_name": "IsGroupHom.inv_ker_one'",
    "file_path": "Mathlib/Deprecated/Subgroup.lean",
    "teorema": "lemma IsGroupHom.inv_ker_one' (G : Type u_1) (H : Type u_2) (a : G) (b : G) (f : G ‚Üí H) : f (a‚Åª¬π * b) = 1 := by"
  },
  {
    "full_name": "Convex.thickening",
    "file_path": "Mathlib/Analysis/Convex/Normed.lean",
    "teorema": "lemma Convex.thickening (E : Type u_2) (s : Set E) (Œ¥ : ‚Ñù) : Convex ‚Ñù (Metric.thickening Œ¥ s) := by"
  },
  {
    "full_name": "SetTheory.PGame.zero_lf_inv'",
    "file_path": "Mathlib/SetTheory/Game/Basic.lean",
    "teorema": "theorem SetTheory.PGame.zero_lf_inv' (xL : xl ‚Üí PGame) (xR : xr ‚Üí PGame) (xl : Type u_1) (xr : Type u_1) : 0 ‚ßè (mk xl xr xL xR).inv' := by"
  },
  {
    "full_name": "NNReal.le_inv_iff_mul_le",
    "file_path": "Mathlib/Data/NNReal/Basic.lean",
    "teorema": "lemma NNReal.le_inv_iff_mul_le (p : ‚Ñù‚â•0) (r : ‚Ñù‚â•0) : r ‚â§ p‚Åª¬π ‚Üî r * p ‚â§ 1 := by"
  },
  {
    "full_name": "MeasureTheory.integrable_of_intervalIntegral_norm_bounded",
    "file_path": "Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean",
    "teorema": "lemma MeasureTheory.integrable_of_intervalIntegral_norm_bounded (E : Type u_2) (f : ‚Ñù ‚Üí E) (Œº : Measure ‚Ñù) : Integrable f Œº := by"
  },
  {
    "full_name": "IntermediateField.separable_of_mem_isSeparable",
    "file_path": "Mathlib/FieldTheory/SeparableDegree.lean",
    "teorema": "lemma IntermediateField.separable_of_mem_isSeparable (E : Type v) (F : Type u) (x : E) : (minpoly F x).Separable := by"
  },
  {
    "full_name": "CochainComplex.mk'_d_1_0",
    "file_path": "Mathlib/Algebra/Homology/HomologicalComplex.lean",
    "teorema": "theorem CochainComplex.mk'_d_1_0 (V : Type u) (X‚ÇÄ : V) (X‚ÇÅ : V) (d‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (succ : (S : ShortComplex V) ‚Üí (X‚ÇÑ : V) √ó' (d‚ÇÇ : S.X‚ÇÉ ‚ü∂ X‚ÇÑ) √ó' S.g ‚â´ d‚ÇÇ = 0) : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').d 0 1 = d‚ÇÄ := by"
  },
  {
    "full_name": "Equiv.Perm.prod_comp'",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "theorem Equiv.Perm.prod_comp' (f : Œ± ‚Üí Œ± ‚Üí Œ≤) (s : Finset Œ±) (Œ± : Type u_3) (Œ≤ : Type u_4) (œÉ : Equiv.Perm Œ±) : ‚àè x ‚àà s, f (œÉ x) x = ‚àè x ‚àà s, f x ((Equiv.symm œÉ) x) := by"
  },
  {
    "full_name": "Finmap.erase_toFinmap",
    "file_path": "Mathlib/Data/Finmap.lean",
    "teorema": "theorem Finmap.erase_toFinmap (a : Œ±) (s : AList Œ≤) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) : erase a ‚ü¶s‚üß = ‚ü¶AList.erase a s‚üß := by"
  },
  {
    "full_name": "Filter.HasBasis.to_hasBasis'",
    "file_path": "Mathlib/Order/Filter/Bases.lean",
    "teorema": "theorem Filter.HasBasis.to_hasBasis' (l : Filter Œ±) (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí Set Œ±) (Œ± : Type u_1) (Œπ : Sort u_4) : l.HasBasis p' s' := by"
  },
  {
    "full_name": "FreeAlgebra.toTensor_Œπ",
    "file_path": "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean",
    "teorema": "lemma FreeAlgebra.toTensor_Œπ (M : Type u_2) (R : Type u_1) (m : M) : toTensor (Œπ R m) = (TensorAlgebra.Œπ R) m := by"
  },
  {
    "full_name": "Algebra.map_leftMulMatrix_localization",
    "file_path": "Mathlib/RingTheory/Localization/NormTrace.lean",
    "teorema": "lemma Algebra.map_leftMulMatrix_localization (M : Submonoid R) (R : Type u_1) (R‚Çò : Type u_3) (S : Type u_2) (S‚Çò : Type u_4) (a : S) (b : Basis Œπ R S) (Œπ : Type u_5) : (algebraMap R R‚Çò).mapMatrix ((leftMulMatrix b) a) = (leftMulMatrix (Basis.localizationLocalization R‚Çò M S‚Çò b)) ((algebraMap S S‚Çò) a) := by"
  },
  {
    "full_name": "Polynomial.Monic.degree_mul_comm",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "teorema": "theorem Polynomial.Monic.degree_mul_comm (R : Type u) (p : R[X]) (q : R[X]) : (p * q).degree = (q * p).degree := by"
  },
  {
    "full_name": "List.head_cyclicPermutations",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "teorema": "theorem List.head_cyclicPermutations (l : List Œ±) (Œ± : Type u) : l.cyclicPermutations.head ‚ãØ = l := by"
  },
  {
    "full_name": "Cardinal.lift_natCast",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "lemma Cardinal.lift_natCast (n : ‚Ñï) : lift.{u, v} ‚Üën = ‚Üën := by"
  },
  {
    "full_name": "Algebra.trace_prod",
    "file_path": "Mathlib/RingTheory/Trace.lean",
    "teorema": "theorem Algebra.trace_prod (R : Type u_1) (S : Type u_2) (T : Type u_3) (p : S √ó T) : (trace R (S √ó T)) p = ((trace R S).coprod (trace R T)) p := by"
  },
  {
    "full_name": "Order.pred_eq_iff_covBy",
    "file_path": "Mathlib/Order/SuccPred/Basic.lean",
    "teorema": "theorem Order.pred_eq_iff_covBy (a : Œ±) (b : Œ±) (Œ± : Type u_1) : pred b = a ‚Üí a ‚ãñ b := by"
  },
  {
    "full_name": "Set.wellFoundedOn_iff",
    "file_path": "Mathlib/Order/WellFoundedSet.lean",
    "teorema": "theorem Set.wellFoundedOn_iff (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Set Œ±) (Œ± : Type u_2) : s.WellFoundedOn r ‚Üî WellFounded fun a b => r a b ‚àß a ‚àà s ‚àß b ‚àà s := by"
  },
  {
    "full_name": "ExteriorAlgebra.Œπ_range_disjoint_one",
    "file_path": "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean",
    "teorema": "lemma ExteriorAlgebra.Œπ_range_disjoint_one (R : Type u1) : Disjoint (LinearMap.range (Œπ R)) 1 := by"
  },
  {
    "full_name": "MulOpposite.unop_list_prod",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "theorem MulOpposite.unop_list_prod (l : List M·µê·µí·µñ) : unop l.prod = (map unop l).reverse.prod := by"
  },
  {
    "full_name": "MeasureTheory.integrable_add_iff_integrable_left",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "theorem MeasureTheory.integrable_add_iff_integrable_left (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) : Integrable (g + f) Œº ‚Üî Integrable g Œº := by"
  },
  {
    "full_name": "PowerSeries.ker_coeff_eq_max_ideal",
    "file_path": "Mathlib/RingTheory/PowerSeries/Inverse.lean",
    "teorema": "lemma PowerSeries.ker_coeff_eq_max_ideal (k : Type u_2) : x‚úù ‚àà RingHom.ker (constantCoeff k) ‚Üî x‚úù ‚àà maximalIdeal k‚ü¶X‚üß := by"
  },
  {
    "full_name": "Setoid.card_classes_ker_le",
    "file_path": "Mathlib/Data/Setoid/Partition.lean",
    "teorema": "theorem Setoid.card_classes_ker_le (f : Œ± ‚Üí Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : Fintype.card ‚Üë(ker f).classes ‚â§ Fintype.card Œ≤ := by"
  },
  {
    "full_name": "FiberPrebundle.mem_pretrivializationAt_source",
    "file_path": "Mathlib/Topology/FiberBundle/Basic.lean",
    "teorema": "theorem FiberPrebundle.mem_pretrivializationAt_source (B : Type u_2) (E : B ‚Üí Type u_5) (F : Type u_3) (a : FiberPrebundle F E) (b : B) (x : E b) : { proj := b, snd := x } ‚àà (a.pretrivializationAt b).source := by"
  },
  {
    "full_name": "Finset.noncommProd_singleton",
    "file_path": "Mathlib/Data/Finset/NoncommProd.lean",
    "teorema": "theorem Finset.noncommProd_singleton (a : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_3) (Œ≤ : Type u_4) : (‚Üë{a}).Pairwise fun a b => Commute (f a) (f b) := by"
  },
  {
    "full_name": "NFA.toDFA_correct",
    "file_path": "Mathlib/Computability/NFA.lean",
    "teorema": "lemma NFA.toDFA_correct (M : NFA Œ± œÉ) (Œ± : Type u) (œÉ : Type v) : M.toDFA.accepts = M.accepts := by"
  },
  {
    "full_name": "FractionalIdeal.count_mul",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Factorization.lean",
    "teorema": "theorem FractionalIdeal.count_mul (I : FractionalIdeal R‚Å∞ K) (K : Type u_2) (R : Type u_1) (v : HeightOneSpectrum R) : count K v (I * I') = count K v I + count K v I' := by"
  },
  {
    "full_name": "Booleanisation.lift_le_lift",
    "file_path": "Mathlib/Order/Booleanisation.lean",
    "teorema": "theorem Booleanisation.lift_le_lift (a : Œ±) (b : Œ±) (Œ± : Type u_1) : lift a ‚â§ lift b ‚Üí a ‚â§ b := by"
  },
  {
    "full_name": "PowerBasis.equivAdjoinSimple_symm_aeval",
    "file_path": "Mathlib/FieldTheory/Adjoin.lean",
    "teorema": "lemma PowerBasis.equivAdjoinSimple_symm_aeval (K : Type u_1) (L : Type u_2) (f : K[X]) (pb : PowerBasis K L) : pb.equivAdjoinSimple.symm ((aeval pb.gen) f) = (aeval (AdjoinSimple.gen K pb.gen)) f := by"
  },
  {
    "full_name": "Fin.zero_add",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.zero_add (k : Fin n) (n : ‚Ñï) : 0 + k = k := by"
  },
  {
    "full_name": "List.get_attach",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "lemma List.get_attach (L : List Œ±) (i : Fin L.attach.length) (Œ± : Type u) : ‚Üë(L.attach.get i) = L.get ‚ü®‚Üëi, ‚ãØ‚ü© := by"
  },
  {
    "full_name": "Polynomial.associated_of_dvd_of_natDegree_le",
    "file_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
    "teorema": "lemma Polynomial.associated_of_dvd_of_natDegree_le (K : Type u_1) (q : K[X]) : IsUnit q.leadingCoeff := by"
  },
  {
    "full_name": "Configuration.HasLines.exists_bijective_of_card_eq",
    "file_path": "Mathlib/Combinatorics/Configuration.lean",
    "teorema": "lemma Configuration.HasLines.exists_bijective_of_card_eq (L : Type u_2) (P : Type u_1) : ‚àÉ f, Function.Bijective f ‚àß ‚àÄ (l : L), pointCount P l = lineCount L (f l) := by"
  },
  {
    "full_name": "CategoryTheory.Idempotents.split_iff_of_iso",
    "file_path": "Mathlib/CategoryTheory/Idempotents/Basic.lean",
    "teorema": "theorem CategoryTheory.Idempotents.split_iff_of_iso (C : Type u_1) (X : C) (p : X ‚ü∂ X) : (‚àÉ Y i e, i ‚â´ e = ùüô Y ‚àß e ‚â´ i = p) ‚Üî ‚àÉ Y' i' e', i' ‚â´ e' = ùüô Y' ‚àß e' ‚â´ i' = p' := by"
  },
  {
    "full_name": "Cardinal.mk_bounded_subset_le",
    "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
    "teorema": "theorem Cardinal.mk_bounded_subset_le (c : Cardinal.{u}) (s : Set Œ±) (Œ± : Type u) : #{ t // t ‚äÜ s ‚àß #‚Üët ‚â§ c } ‚â§ max #‚Üës ‚Ñµ‚ÇÄ ^ c := by"
  },
  {
    "full_name": "Matrix.transpose_nonsing_inv",
    "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
    "teorema": "lemma Matrix.transpose_nonsing_inv (A : Matrix n n Œ±) (n : Type u') (Œ± : Type v) : A‚Åª¬π·µÄ = A·µÄ‚Åª¬π := by"
  },
  {
    "full_name": "Fin.cons_rev",
    "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean",
    "teorema": "theorem Fin.cons_rev (a : Œ±) (f : Fin n ‚Üí Œ±) (i : Fin (n + 1)) (n : ‚Ñï) (Œ± : Type u_1) : cons a f i.rev = snoc (f ‚àò rev) a i := by"
  },
  {
    "full_name": "Nat.fib_dvd",
    "file_path": "Mathlib/Data/Nat/Fib/Basic.lean",
    "teorema": "theorem Nat.fib_dvd (m : ‚Ñï) (n : ‚Ñï) : fib m ‚à£ fib n := by"
  },
  {
    "full_name": "CategoryTheory.MorphismProperty.LeftFraction.map_ofHom",
    "file_path": "Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean",
    "teorema": "theorem CategoryTheory.MorphismProperty.LeftFraction.map_ofHom (C : Type u_1) (D : Type u_2) (L : C ‚•§ D) (W : MorphismProperty C) (X : C) (Y : C) (f : X ‚ü∂ Y) (hL : W.IsInvertedBy L) : (ofHom W f).map L hL = L.map f := by"
  },
  {
    "full_name": "FiniteField.isSquare_iff",
    "file_path": "Mathlib/FieldTheory/Finite/Basic.lean",
    "teorema": "lemma FiniteField.isSquare_iff (F : Type u_3) (a : F) : IsSquare a ‚Üî a ^ (Fintype.card F / 2) = 1 := by"
  },
  {
    "full_name": "Seminorm.ball_finset_sup_eq_iInter",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "theorem Seminorm.ball_finset_sup_eq_iInter (E : Type u_7) (p : Œπ ‚Üí Seminorm ùïú E) (r : ‚Ñù) (s : Finset Œπ) (x : E) (Œπ : Type u_12) (ùïú : Type u_3) : (s.sup p).ball x r = ‚ãÇ i ‚àà s, (p i).ball x r := by"
  },
  {
    "full_name": "Filter.EventuallyLE.mul_le_mul'",
    "file_path": "Mathlib/Order/Filter/Ring.lean",
    "teorema": "lemma Filter.EventuallyLE.mul_le_mul' (f‚ÇÅ : Œ± ‚Üí Œ≤) (f‚ÇÇ : Œ± ‚Üí Œ≤) (g‚ÇÅ : Œ± ‚Üí Œ≤) (g‚ÇÇ : Œ± ‚Üí Œ≤) (l : Filter Œ±) (Œ± : Type u) (Œ≤ : Type v) : f‚ÇÅ * g‚ÇÅ ‚â§·∂†[l] f‚ÇÇ * g‚ÇÇ := by"
  },
  {
    "full_name": "CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_sieve‚ÇÅ",
    "file_path": "Mathlib/CategoryTheory/Sites/OneHypercover.lean",
    "teorema": "theorem CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_sieve‚ÇÅ (C : Type u) (J : GrothendieckTopology C) (S : J.Cover X) (W : C) (X : C) (f‚ÇÅ : S.Arrow) (f‚ÇÇ : S.Arrow) (p‚ÇÅ : W ‚ü∂ f‚ÇÅ.Y) (p‚ÇÇ : W ‚ü∂ f‚ÇÇ.Y) : S.preOneHypercover.sieve‚ÇÅ p‚ÇÅ p‚ÇÇ = ‚ä§ := by"
  },
  {
    "full_name": "Polynomial.nextCoeff_ne_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "lemma Polynomial.nextCoeff_ne_zero (R : Type u) (p : R[X]) : p.nextCoeff ‚â† 0 ‚Üî p.natDegree ‚â† 0 ‚àß p.coeff (p.natDegree - 1) ‚â† 0 := by"
  },
  {
    "full_name": "Mon_.mul_rightUnitor",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Mon_.lean",
    "teorema": "theorem Mon_.mul_rightUnitor (C : Type u‚ÇÅ) (M : Mon_ C) : (tensor_Œº C (M.X, ùüô_ C) (M.X, ùüô_ C) ‚â´ (M.mul ‚äó (Œª_ (ùüô_ C)).hom)) ‚â´ (œÅ_ M.X).hom = ((œÅ_ M.X).hom ‚äó (œÅ_ M.X).hom) ‚â´ M.mul := by"
  },
  {
    "full_name": "slope_vadd_const",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean",
    "teorema": "theorem slope_vadd_const (E : Type u_2) (PE : Type u_3) (c : PE) (f : k ‚Üí E) (k : Type u_1) : (slope fun x => f x +·µ• c) = slope f := by"
  },
  {
    "full_name": "Set.le_chainHeight_add_nat_iff",
    "file_path": "Mathlib/Order/Height.lean",
    "teorema": "theorem Set.le_chainHeight_add_nat_iff (l : List Œ±) (m : ‚Ñï) (n : ‚Ñï) (s : Set Œ±) (Œ± : Type u_1) : ‚Üën ‚â§ s.chainHeight + ‚Üëm ‚Üî ‚àÉ l ‚àà s.subchain, n ‚â§ l.length + m := by"
  },
  {
    "full_name": "antisymm_iff",
    "file_path": "Mathlib/Order/RelClasses.lean",
    "teorema": "lemma antisymm_iff (a : Œ±) (b : Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u) : a = b ‚Üí r a b ‚àß r b a := by"
  },
  {
    "full_name": "Finpartition.parts_top_subset",
    "file_path": "Mathlib/Order/Partition/Finpartition.lean",
    "teorema": "theorem Finpartition.parts_top_subset (a : Œ±) (Œ± : Type u_1) : ‚ä§.parts ‚äÜ {a} := by"
  },
  {
    "full_name": "CategoryTheory.Functor.quasiIso'_of_map_quasiIso'",
    "file_path": "Mathlib/Algebra/Homology/QuasiIso.lean",
    "teorema": "lemma CategoryTheory.Functor.quasiIso'_of_map_quasiIso' (A : Type u_2) (B : Type u_3) (C : HomologicalComplex A c) (D : HomologicalComplex A c) (F : A ‚•§ B) (c : ComplexShape Œπ) (f : C ‚ü∂ D) (i : Œπ) (Œπ : Type u_1) : IsIso (F.map ((homology'Functor A c i).map f)) := by"
  },
  {
    "full_name": "MeasureTheory.IsFundamentalDomain.essSup_measure_restrict",
    "file_path": "Mathlib/MeasureTheory/Group/FundamentalDomain.lean",
    "teorema": "theorem MeasureTheory.IsFundamentalDomain.essSup_measure_restrict (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Set Œ±) (Œ± : Type u_3) (Œº : Measure Œ±) : essSup f (Œº.restrict s) = essSup f Œº := by"
  },
  {
    "full_name": "Ideal.sup_mul_eq_of_coprime_right",
    "file_path": "Mathlib/RingTheory/Ideal/Operations.lean",
    "teorema": "theorem Ideal.sup_mul_eq_of_coprime_right (I : Ideal R) (J : Ideal R) (K : Ideal R) (R : Type u) : I ‚äî J * K = I ‚äî J := by"
  },
  {
    "full_name": "LinearMap.continuous_of_nonzero_on_open",
    "file_path": "Mathlib/Topology/Algebra/Module/FiniteDimension.lean",
    "teorema": "theorem LinearMap.continuous_of_nonzero_on_open (E : Type v) (l : E ‚Üí‚Çó[ùïú] ùïú) (ùïú : Type u) : Continuous ‚áël := by"
  },
  {
    "full_name": "MeasureTheory.zero_convolution",
    "file_path": "Mathlib/Analysis/Convolution.lean",
    "teorema": "lemma MeasureTheory.zero_convolution (E : Type uE) (F : Type uF) (G : Type uG) (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) (g : G ‚Üí E') (Œº : Measure G) (ùïú : Type uùïú) : 0 ‚ãÜ[L, Œº] g = 0 := by"
  },
  {
    "full_name": "Real.deriv_negMulLog",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
    "teorema": "theorem Real.deriv_negMulLog (x : ‚Ñù) : deriv negMulLog x = -log x - 1 := by"
  },
  {
    "full_name": "CategoryTheory.TwoSquare.GuitartExact.vComp_iff_of_equivalences",
    "file_path": "Mathlib/CategoryTheory/GuitartExact/VerticalComposition.lean",
    "teorema": "theorem CategoryTheory.TwoSquare.GuitartExact.vComp_iff_of_equivalences (C‚ÇÅ : Type u_1) (C‚ÇÇ : Type u_2) (D‚ÇÅ : Type u_4) (D‚ÇÇ : Type u_5) (H‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (H‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (L‚ÇÅ : C‚ÇÅ ‚•§ C‚ÇÇ) (R‚ÇÅ : D‚ÇÅ ‚•§ D‚ÇÇ) (w : TwoSquare H‚ÇÅ L‚ÇÅ R‚ÇÅ H‚ÇÇ) : (w.vComp w'.hom).GuitartExact ‚Üî w.GuitartExact := by"
  },
  {
    "full_name": "Polynomial.mkDerivation_X",
    "file_path": "Mathlib/Algebra/Polynomial/Derivation.lean",
    "teorema": "lemma Polynomial.mkDerivation_X (A : Type u_2) (R : Type u_1) (a : A) : ((mkDerivation R) a) X = a := by"
  },
  {
    "full_name": "Filter.principal_singleton",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.principal_singleton (a : Œ±) (s : Set Œ±) (Œ± : Type u) : s ‚àà ùìü {a} ‚Üî s ‚àà pure a := by"
  },
  {
    "full_name": "ArithmeticFunction.IsMultiplicative.mul",
    "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean",
    "teorema": "lemma ArithmeticFunction.IsMultiplicative.mul (R : Type u_1) (f : ArithmeticFunction R) (g : ArithmeticFunction R) : (f * g).IsMultiplicative := by"
  },
  {
    "full_name": "LinearMap.range_inl",
    "file_path": "Mathlib/LinearAlgebra/Prod.lean",
    "teorema": "lemma LinearMap.range_inl (M : Type v) (M‚ÇÇ : Type w) (R : Type u) : range (inl R M M‚ÇÇ) = ker (snd R M M‚ÇÇ) := by"
  },
  {
    "full_name": "LowerSet.coe_iSup‚ÇÇ",
    "file_path": "Mathlib/Order/UpperLower/Basic.lean",
    "teorema": "lemma LowerSet.coe_iSup‚ÇÇ (f : (i : Œπ) ‚Üí Œ∫ i ‚Üí LowerSet Œ±) (Œ± : Type u_1) (Œπ : Sort u_4) (Œ∫ : Œπ ‚Üí Sort u_5) : ‚Üë(‚®Ü i, ‚®Ü j, f i j) = ‚ãÉ i, ‚ãÉ j, ‚Üë(f i j) := by"
  },
  {
    "full_name": "List.kreplace_nodupKeys",
    "file_path": "Mathlib/Data/List/Sigma.lean",
    "teorema": "lemma List.kreplace_nodupKeys (a : Œ±) (b : Œ≤ a) (l : List (Sigma Œ≤)) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) : (kreplace a b l).NodupKeys ‚Üî l.NodupKeys := by"
  },
  {
    "full_name": "AkraBazziRecurrence.eventually_atTop_sumTransform_ge",
    "file_path": "Mathlib/Computability/AkraBazzi/AkraBazzi.lean",
    "teorema": "theorem AkraBazziRecurrence.eventually_atTop_sumTransform_ge (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) (Œ± : Type u_1) : ‚àÉ c > 0, ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ (i : Œ±), c * g ‚Üën ‚â§ sumTransform (p a b) g (r i n) n := by"
  },
  {
    "full_name": "iSup‚ÇÇ_disjoint_iff",
    "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean",
    "teorema": "lemma iSup‚ÇÇ_disjoint_iff (a : Œ±) (f : (i : Œπ) ‚Üí Œ∫ i ‚Üí Œ±) (Œ± : Type u) (Œπ : Sort w) (Œ∫ : Œπ ‚Üí Sort w') : Disjoint (‚®Ü i, ‚®Ü j, f i j) a ‚Üî ‚àÄ (i : Œπ) (j : Œ∫ i), Disjoint (f i j) a := by"
  },
  {
    "full_name": "Polynomial.degree_map_eq_iff",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Lemmas.lean",
    "teorema": "lemma Polynomial.degree_map_eq_iff (R : Type u) (S : Type v) (f : R ‚Üí+* S) (p : R[X]) : (map f p).degree = p.degree ‚Üî f p.leadingCoeff ‚â† 0 ‚à® p = 0 := by"
  },
  {
    "full_name": "prodXSubSMul.smul",
    "file_path": "Mathlib/Algebra/Polynomial/GroupRingAction.lean",
    "teorema": "theorem prodXSubSMul.smul (G : Type u_2) (R : Type u_3) (g : G) (x : R) : g ‚Ä¢ (X - C (ofQuotientStabilizer G x g')) = X - C (ofQuotientStabilizer G x (g ‚Ä¢ g')) := by"
  },
  {
    "full_name": "OreLocalization.mul_div_one",
    "file_path": "Mathlib/RingTheory/OreLocalization/Basic.lean",
    "teorema": "lemma OreLocalization.mul_div_one (R : Type u_1) (S : Submonoid R) (p : R) (r : R) (s : ‚Ü•S) : p /‚Çí s * (r /‚Çí 1) = p * r /‚Çí s := by"
  },
  {
    "full_name": "Submonoid.coe_mul_self_eq",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Pointwise.lean",
    "teorema": "theorem Submonoid.coe_mul_self_eq (M : Type u_3) (s : Submonoid M) : ‚Üës * ‚Üës = ‚Üës := by"
  },
  {
    "full_name": "Ordinal.principal_mul_two",
    "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
    "teorema": "lemma Ordinal.principal_mul_two (a : Ordinal.{u_1}) (b : Ordinal.{u_1}) : (fun x x_1 => x * x_1) a b < 2 := by"
  },
  {
    "full_name": "Rel.preimage_top",
    "file_path": "Mathlib/Data/Rel.lean",
    "teorema": "theorem Rel.preimage_top (s : Set Œ≤) (Œ≤ : Type u_2) : ‚ä§.preimage s = Set.univ := by"
  },
  {
    "full_name": "aemeasurable_union_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean",
    "teorema": "lemma aemeasurable_union_iff (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œº : Measure Œ±) : AEMeasurable f (Œº.restrict (s ‚à™ t)) ‚Üî AEMeasurable f (Œº.restrict s) ‚àß AEMeasurable f (Œº.restrict t) := by"
  },
  {
    "full_name": "TopologicalSpace.NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent",
    "file_path": "Mathlib/Topology/NoetherianSpace.lean",
    "teorema": "theorem TopologicalSpace.NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent (Z : Set Œ±) (Œ± : Type u_1) : ‚àÉ o, IsOpen o ‚àß o ‚â† ‚àÖ ‚àß o ‚â§ Z := by"
  },
  {
    "full_name": "List.Ico.filter_le_of_top_le",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "teorema": "lemma List.Ico.filter_le_of_top_le (k : ‚Ñï) (l : ‚Ñï) : ¬¨decide (l ‚â§ k) = true := by"
  },
  {
    "full_name": "Submodule.map_unop_mul",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "lemma Submodule.map_unop_mul (M : Submodule R A·µê·µí·µñ) (N : Submodule R A·µê·µí·µñ) (R : Type u) : map (‚Üë(opLinearEquiv R)) (map (‚Üë(opLinearEquiv R).symm) (M * N)) = map (‚Üë(opLinearEquiv R)) (map (‚Üë(opLinearEquiv R).symm) N * map (‚Üë(opLinearEquiv R).symm) M) := by"
  },
  {
    "full_name": "MeasureTheory.measure_union_add_inter‚ÇÄ'",
    "file_path": "Mathlib/MeasureTheory/Measure/NullMeasurable.lean",
    "teorema": "lemma MeasureTheory.measure_union_add_inter‚ÇÄ' (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_2) (Œº : Measure Œ±) : Œº (s ‚à™ t) + Œº (s ‚à© t) = Œº s + Œº t := by"
  },
  {
    "full_name": "Complex.abs_cpow_inv_nat",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "theorem Complex.abs_cpow_inv_nat (n : ‚Ñï) (x : ‚ÑÇ) : abs (x ^ (‚Üën)‚Åª¬π) = abs x ^ (‚Üën)‚Åª¬π := by"
  },
  {
    "full_name": "Nat.add_pos_iff_pos_or_pos",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "theorem Nat.add_pos_iff_pos_or_pos (m : ‚Ñï) (n : ‚Ñï) : 0 < m + n ‚Üî 0 < m ‚à® 0 < n := by"
  },
  {
    "full_name": "Finset.nonempty_Ico",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "teorema": "lemma Finset.nonempty_Ico (a : Œ±) (b : Œ±) (Œ± : Type u_2) : (Ico a b).Nonempty ‚Üî a < b := by"
  },
  {
    "full_name": "not_summable_of_ratio_norm_eventually_ge",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "lemma not_summable_of_ratio_norm_eventually_ge (f : ‚Ñï ‚Üí Œ±) (Œ± : Type u_4) : ¬¨Summable f := by"
  },
  {
    "full_name": "MultilinearMap.map_update_sum",
    "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
    "teorema": "theorem MultilinearMap.map_update_sum (M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ) (M‚ÇÇ : Type v‚ÇÇ) (R : Type uR) (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) (g : Œ± ‚Üí M‚ÇÅ i) (i : Œπ) (m : (i : Œπ) ‚Üí M‚ÇÅ i) (t : Finset Œ±) (Œ± : Type u_2) (Œπ : Type uŒπ) : f (update m i (‚àë a ‚àà t, g a)) = ‚àë a ‚àà t, f (update m i (g a)) := by"
  },
  {
    "full_name": "Ordinal.log_eq_zero",
    "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
    "teorema": "theorem Ordinal.log_eq_zero (b : Ordinal.{u_1}) (o : Ordinal.{u_1}) : log b o = 0 := by"
  },
  {
    "full_name": "MeasureTheory.Measure.snd_prod",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "lemma MeasureTheory.Measure.snd_prod (Œ± : Type u_1) (Œ≤ : Type u_3) (Œº : Measure Œ±) (ŒΩ : Measure Œ≤) : (Œº.prod ŒΩ).snd = ŒΩ := by"
  },
  {
    "full_name": "UpperHalfPlane.dist_triangle",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean",
    "teorema": "lemma UpperHalfPlane.dist_triangle (a : ‚Ñç) (b : ‚Ñç) (c : ‚Ñç) : dist a c ‚â§ dist a b + dist b c := by"
  },
  {
    "full_name": "Matrix.Pivot.listTransvecCol_mul_last_row_drop",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Transvection.lean",
    "teorema": "lemma Matrix.Pivot.listTransvecCol_mul_last_row_drop (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú) (i : Fin r ‚äï Unit) (k : ‚Ñï) (r : ‚Ñï) (ùïú : Type u_3) : ((List.drop k (listTransvecCol M)).prod * M) (inr ()) i = M (inr ()) i := by"
  },
  {
    "full_name": "TrivSqZeroExt.map_comp_map",
    "file_path": "Mathlib/Algebra/TrivSqZeroExt.lean",
    "teorema": "theorem TrivSqZeroExt.map_comp_map (M : Type v) (N : Type u_3) (P : Type u_4) (R : Type u) (f : M ‚Üí‚Çó[R'] N) (g : N ‚Üí‚Çó[R'] P) : map (g ‚àò‚Çó f) = (map g).comp (map f) := by"
  },
  {
    "full_name": "Dense.biUnion_uniformity_ball",
    "file_path": "Mathlib/Topology/UniformSpace/Basic.lean",
    "teorema": "lemma Dense.biUnion_uniformity_ball (U : Set (Œ± √ó Œ±)) (s : Set Œ±) (Œ± : Type ua) : ‚ãÉ x ‚àà s, ball x U = univ := by"
  },
  {
    "full_name": "units_smul_eq_self_iff",
    "file_path": "Mathlib/LinearAlgebra/Ray.lean",
    "teorema": "theorem units_smul_eq_self_iff (M : Type u_2) (R : Type u_1) (u : RÀ£) (v : Module.Ray R M) : u ‚Ä¢ v = v ‚Üî 0 < ‚Üëu := by"
  },
  {
    "full_name": "List.nodup_permutations'Aux_iff",
    "file_path": "Mathlib/Data/List/Perm.lean",
    "teorema": "theorem List.nodup_permutations'Aux_iff (s : List Œ±) (x : Œ±) (Œ± : Type u_1) : (permutations'Aux x s).Nodup ‚Üî x ‚àâ s := by"
  },
  {
    "full_name": "Finite.card_le_of_injective",
    "file_path": "Mathlib/Data/Finite/Card.lean",
    "teorema": "lemma Finite.card_le_of_injective (Œ± : Type u_1) (Œ≤ : Type u_2) : Nat.card Œ± ‚â§ Nat.card Œ≤ := by"
  },
  {
    "full_name": "EllipticCurve.ofJ1728_j",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean",
    "teorema": "lemma EllipticCurve.ofJ1728_j (R : Type u) : (ofJ1728 R).j = 1728 := by"
  },
  {
    "full_name": "LieModule.mem_weightSpace",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "lemma LieModule.mem_weightSpace (L : Type u_3) (M : Type u_4) (R : Type u_2) (m : M) (œá : L ‚Üí R) : m ‚àà weightSpace M œá ‚Üî ‚àÄ (x : L), ‚àÉ k, (((toEnd R L M) x - œá x ‚Ä¢ 1) ^ k) m = 0 := by"
  },
  {
    "full_name": "IsClosed.exists_closed_singleton",
    "file_path": "Mathlib/Topology/Separation.lean",
    "teorema": "theorem IsClosed.exists_closed_singleton (S : Set X) (X : Type u_1) : ‚àÉ x ‚àà S, IsClosed {x} := by"
  },
  {
    "full_name": "Polynomial.cyclotomic_expand_eq_cyclotomic_mul",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean",
    "teorema": "lemma Polynomial.cyclotomic_expand_eq_cyclotomic_mul (R : Type u_1) (n : ‚Ñï) (p : ‚Ñï) : (expand R p) (cyclotomic n R) = cyclotomic (n * p) R * cyclotomic n R := by"
  },
  {
    "full_name": "StrictAnti.prod_map",
    "file_path": "Mathlib/Order/Monotone/Basic.lean",
    "teorema": "lemma StrictAnti.prod_map (a : Œ± √ó Œ≤) (b : Œ± √ó Œ≤) (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (Œ± : Type u) (Œ≤ : Type v) (Œ≥ : Type w) (Œ¥ : Type u_2) : a < b ‚Üí Prod.map f g b < Prod.map f g a := by"
  },
  {
    "full_name": "PiLp.norm_equiv_symm_const",
    "file_path": "Mathlib/Analysis/NormedSpace/PiLp.lean",
    "teorema": "lemma PiLp.norm_equiv_symm_const (b : Œ≤) (p : ‚Ñù‚â•0‚àû) (Œ≤ : Type u_5) (Œπ : Type u_2) : ‚Üë(‚Üë(Fintype.card Œπ) ^ (1 / p).toReal * ‚Äñb‚Äñ‚Çä) = ‚Üë‚Üë(Fintype.card Œπ) ^ (1 / p).toReal * ‚Äñb‚Äñ := by"
  },
  {
    "full_name": "Mathlib.Meta.NormNum.isInt_eq_false",
    "file_path": "Mathlib/Tactic/NormNum/Eq.lean",
    "teorema": "lemma Mathlib.Meta.NormNum.isInt_eq_false (n‚úù : ‚Ñ§) (n‚úù¬π : ‚Ñ§) : ¬¨‚Üën‚úù¬π = ‚Üën‚úù := by"
  },
  {
    "full_name": "PosSMulReflectLT.of_pos",
    "file_path": "Mathlib/Algebra/Order/Module/Defs.lean",
    "teorema": "theorem PosSMulReflectLT.of_pos (b‚ÇÅ : Œ≤) (b‚ÇÇ : Œ≤) (Œ≤ : Type u_2) : b‚ÇÅ < b‚ÇÇ := by"
  },
  {
    "full_name": "toIcoDiv_add_left",
    "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean",
    "teorema": "theorem toIcoDiv_add_left (a : Œ±) (b : Œ±) (hp : 0 < p) (p : Œ±) (Œ± : Type u_1) : toIcoDiv hp a (p + b) = toIcoDiv hp a b + 1 := by"
  },
  {
    "full_name": "AkraBazziRecurrence.GrowsPolynomially.of_isTheta",
    "file_path": "Mathlib/Computability/AkraBazzi/GrowsPolynomially.lean",
    "teorema": "lemma AkraBazziRecurrence.GrowsPolynomially.of_isTheta (f : ‚Ñù ‚Üí ‚Ñù) : GrowsPolynomially f := by"
  },
  {
    "full_name": "IsOrderRightAdjoint.orderIso_comp",
    "file_path": "Mathlib/Order/SemiconjSup.lean",
    "teorema": "theorem IsOrderRightAdjoint.orderIso_comp (e : Œ≤ ‚âÉo Œ≥) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (y : Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : IsLUB {x | (‚áëe ‚àò f) x ‚â§ y} ((g ‚àò ‚áëe.symm) y) := by"
  },
  {
    "full_name": "List.mem_dedup",
    "file_path": "Mathlib/Data/List/Dedup.lean",
    "teorema": "lemma List.mem_dedup (a : Œ±) (l : List Œ±) (Œ± : Type u) : a ‚àà l.dedup ‚Üî a ‚àà l := by"
  },
  {
    "full_name": "HasDerivAt.mul_const",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean",
    "teorema": "theorem HasDerivAt.mul_const (c : ùïú ‚Üí ùî∏) (d : ùî∏) (u : ùïú ‚Üí ùïú') (x : ùïú) (ùî∏ : Type u_3) (ùïú : Type u) : HasDerivAt (fun y => c y * d) (c' * d) x := by"
  },
  {
    "full_name": "MeasureTheory.lmarginal_update_of_mem",
    "file_path": "Mathlib/MeasureTheory/Integral/Marginal.lean",
    "teorema": "theorem MeasureTheory.lmarginal_update_of_mem (f : ((i : Œ¥) ‚Üí œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (i : Œ¥) (x : (i : Œ¥) ‚Üí œÄ i) (y : œÄ i) (Œ¥ : Type u_1) (Œº : (i : Œ¥) ‚Üí Measure (œÄ i)) (œÄ : Œ¥ ‚Üí Type u_3) : (‚à´‚ãØ‚à´‚Åª_s, f ‚àÇŒº) (update x i y) = (‚à´‚ãØ‚à´‚Åª_s, f ‚àÇŒº) x := by"
  },
  {
    "full_name": "Set.Icc_eq_singleton_iff",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Icc_eq_singleton_iff (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : Icc a b = {c} ‚Üî a = c ‚àß b = c := by"
  },
  {
    "full_name": "Sym.ofVector_cons",
    "file_path": "Mathlib/Data/Sym/Basic.lean",
    "teorema": "theorem Sym.ofVector_cons (a : Œ±) (n : ‚Ñï) (v : Vector Œ± n) (Œ± : Type u_1) : ofVector (a ::·µ• v) = a ::‚Çõ ofVector v := by"
  },
  {
    "full_name": "List.le_findIdx_of_not",
    "file_path": "Mathlib/Data/List/Indexes.lean",
    "teorema": "lemma List.le_findIdx_of_not (i : ‚Ñï) (p : Œ± ‚Üí Bool) (xs : List Œ±) (Œ± : Type u) : i ‚â§ findIdx p xs := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_zero",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "lemma MeasureTheory.lintegral_zero (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±), 0 ‚àÇŒº = 0 := by"
  },
  {
    "full_name": "Complex.coe_basisOneI",
    "file_path": "Mathlib/Data/Complex/Module.lean",
    "teorema": "lemma Complex.coe_basisOneI (i : Fin 2) (j : Fin 2) : (basisOneI.repr (![1, I] i)) j = (Finsupp.single i 1) j := by"
  },
  {
    "full_name": "Finset.noncommProd_commute",
    "file_path": "Mathlib/Data/Finset/NoncommProd.lean",
    "teorema": "theorem Finset.noncommProd_commute (comm : (‚Üës).Pairwise fun a b => Commute (f a) (f b)) (f : Œ± ‚Üí Œ≤) (s : Finset Œ±) (y : Œ≤) (Œ± : Type u_3) (Œ≤ : Type u_4) : Commute y (s.noncommProd f comm) := by"
  },
  {
    "full_name": "Finset.Ioc_subset_Iic_self",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "teorema": "theorem Finset.Ioc_subset_Iic_self (a : Œ±) (b : Œ±) (Œ± : Type u_2) : Ioc a b ‚äÜ Iic b := by"
  },
  {
    "full_name": "ExteriorAlgebra.Œπ_ne_one",
    "file_path": "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean",
    "teorema": "lemma ExteriorAlgebra.Œπ_ne_one (M : Type u2) (R : Type u1) (x : M) : (Œπ R) x ‚â† 1 := by"
  },
  {
    "full_name": "CategoryTheory.MorphismProperty.IsInvertedBy.unop",
    "file_path": "Mathlib/CategoryTheory/MorphismProperty/IsInvertedBy.lean",
    "teorema": "lemma CategoryTheory.MorphismProperty.IsInvertedBy.unop (C : Type u) (L : C·µí·µñ ‚•§ D·µí·µñ) (X : C) (Y : C) (f : X ‚ü∂ Y) : IsIso (L.unop.map f) := by"
  },
  {
    "full_name": "Metric.mem_ball_comm",
    "file_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
    "teorema": "theorem Metric.mem_ball_comm (x : Œ±) (y : Œ±) (Œ± : Type u) (Œµ : ‚Ñù) : x ‚àà ball y Œµ ‚Üî y ‚àà ball x Œµ := by"
  },
  {
    "full_name": "lp.coeFn_sum",
    "file_path": "Mathlib/Analysis/NormedSpace/lpSpace.lean",
    "teorema": "lemma lp.coeFn_sum (E : Œ± ‚Üí Type u_2) (f : Œπ ‚Üí ‚Ü•(lp E p)) (p : ‚Ñù‚â•0‚àû) (s : Finset Œπ) (Œ± : Type u_1) (Œπ : Type u_3) : ‚Üë(‚àë i ‚àà s, f i) = ‚àë i ‚àà s, ‚Üë(f i) := by"
  },
  {
    "full_name": "isLUB_iff_sSup_eq",
    "file_path": "Mathlib/Order/CompleteLattice.lean",
    "teorema": "theorem isLUB_iff_sSup_eq (a : Œ±) (s : Set Œ±) (Œ± : Type u_1) : sSup s = a ‚Üí IsLUB s a := by"
  },
  {
    "full_name": "denselyOrdered_orderDual",
    "file_path": "Mathlib/Order/Basic.lean",
    "teorema": "theorem denselyOrdered_orderDual (Œ± : Type u_2) : DenselyOrdered Œ±·µí·µà ‚Üí DenselyOrdered Œ± := by"
  },
  {
    "full_name": "range_two_mul",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "theorem range_two_mul (a : Œ±‚úù) (Œ± : Type u_5) : (Set.range fun x => 2 * x) = {a | Even a} := by"
  },
  {
    "full_name": "AlgebraicGeometry.Scheme.map_basicOpen",
    "file_path": "Mathlib/AlgebraicGeometry/Restrict.lean",
    "teorema": "lemma AlgebraicGeometry.Scheme.map_basicOpen (U : Opens ‚Üë‚ÜëX.toPresheafedSpace) (X : Scheme) (r : ‚ÜëŒì(X ‚à£_·µ§ U, ‚ä§)) : ŒπOpens U ''·µÅ (X ‚à£_·µ§ U).basicOpen r = X.basicOpen r := by"
  },
  {
    "full_name": "PMF.pure_bind",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Monad.lean",
    "teorema": "lemma PMF.pure_bind (a : Œ±) (f : Œ± ‚Üí PMF Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (pure a).bind f = f a := by"
  },
  {
    "full_name": "MeasureTheory.Measure.rnDeriv_withDensity_left",
    "file_path": "Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean",
    "teorema": "lemma MeasureTheory.Measure.rnDeriv_withDensity_left (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) (ŒΩ : Measure Œ±) : (Œº.withDensity f).rnDeriv ŒΩ =·∂†[ae ŒΩ] fun x => f x * Œº.rnDeriv ŒΩ x := by"
  },
  {
    "full_name": "lp.norm_apply_le_norm",
    "file_path": "Mathlib/Analysis/NormedSpace/lpSpace.lean",
    "teorema": "lemma lp.norm_apply_le_norm (E : Œ± ‚Üí Type u_2) (f : ‚Ü•(lp E p)) (i : Œ±) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) : ‚Äñ‚Üëf i‚Äñ ‚â§ ‚Äñf‚Äñ := by"
  },
  {
    "full_name": "Concept.ext",
    "file_path": "Mathlib/Order/Concept.lean",
    "teorema": "lemma Concept.ext (c : Concept Œ± Œ≤ r) (d : Concept Œ± Œ≤ r) (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (Œ± : Type u_2) (Œ≤ : Type u_3) : c = d := by"
  },
  {
    "full_name": "SemidirectProduct.map_inr",
    "file_path": "Mathlib/GroupTheory/SemidirectProduct.lean",
    "teorema": "lemma SemidirectProduct.map_inr (G : Type u_2) (G‚ÇÅ : Type u_5) (N : Type u_1) (N‚ÇÅ : Type u_4) (f‚ÇÅ : N ‚Üí* N‚ÇÅ) (f‚ÇÇ : G ‚Üí* G‚ÇÅ) (g : G) (h : ‚àÄ (g : G), f‚ÇÅ.comp (MulEquiv.toMonoidHom (œÜ g)) = (MulEquiv.toMonoidHom (œÜ‚ÇÅ (f‚ÇÇ g))).comp f‚ÇÅ) (œÜ : G ‚Üí* MulAut N) (œÜ‚ÇÅ : G‚ÇÅ ‚Üí* MulAut N‚ÇÅ) : (map f‚ÇÅ f‚ÇÇ h) (inr g) = inr (f‚ÇÇ g) := by"
  },
  {
    "full_name": "convex_iff_ordConnected",
    "file_path": "Mathlib/Analysis/Convex/Basic.lean",
    "teorema": "theorem convex_iff_ordConnected (s : Set ùïú) (ùïú : Type u_1) : Convex ùïú s ‚Üî s.OrdConnected := by"
  },
  {
    "full_name": "Basis.flag_le_ker_coord_iff",
    "file_path": "Mathlib/LinearAlgebra/Basis/Flag.lean",
    "teorema": "theorem Basis.flag_le_ker_coord_iff (M : Type u_2) (R : Type u_1) (b : Basis (Fin n) R M) (k : Fin (n + 1)) (l : Fin n) (n : ‚Ñï) : b.flag k ‚â§ LinearMap.ker (b.coord l) ‚Üî k ‚â§ l.castSucc := by"
  },
  {
    "full_name": "ConjAct.orbitRel_conjAct",
    "file_path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean",
    "teorema": "lemma ConjAct.orbitRel_conjAct (G : Type u_3) (g : G) (h : G) : (orbitRel (ConjAct G) G).Rel g h = IsConj g h := by"
  },
  {
    "full_name": "IsPreconnected.eq_or_eq_neg_of_sq_eq",
    "file_path": "Mathlib/Topology/Algebra/Field.lean",
    "teorema": "theorem IsPreconnected.eq_or_eq_neg_of_sq_eq (S : Set Œ±) (f : Œ± ‚Üí ùïú) (g : Œ± ‚Üí ùïú) (Œ± : Type u_2) (ùïú : Type u_3) : EqOn f g S ‚à® EqOn f (-g) S := by"
  },
  {
    "full_name": "Polynomial.not_irreducible_C",
    "file_path": "Mathlib/Algebra/Polynomial/FieldDivision.lean",
    "teorema": "theorem Polynomial.not_irreducible_C (R : Type u) (x : R) : ¬¨Irreducible (C x) := by"
  },
  {
    "full_name": "EisensteinSeries.r1_eq",
    "file_path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/UniformConvergence.lean",
    "teorema": "lemma EisensteinSeries.r1_eq (z : ‚Ñç) : r1 z = 1 / ((z.re / z.im) ^ 2 + 1) := by"
  },
  {
    "full_name": "Metric.glueDist_swap",
    "file_path": "Mathlib/Topology/MetricSpace/Gluing.lean",
    "teorema": "theorem Metric.glueDist_swap (X : Type u) (Y : Type v) (Z : Type w) (val‚úù : Y) (val‚úù¬π : X) (Œ¶ : Z ‚Üí X) (Œ® : Z ‚Üí Y) (Œµ : ‚Ñù) : glueDist Œ® Œ¶ Œµ (Sum.inl val‚úù¬π).swap (Sum.inr val‚úù).swap = glueDist Œ¶ Œ® Œµ (Sum.inl val‚úù¬π) (Sum.inr val‚úù) := by"
  },
  {
    "full_name": "Real.isConjExponent_iff_eq_conjExponent",
    "file_path": "Mathlib/Data/Real/ConjExponents.lean",
    "teorema": "lemma Real.isConjExponent_iff_eq_conjExponent (p : ‚Ñù) (q : ‚Ñù) : p‚Åª¬π + q‚Åª¬π = 1 := by"
  },
  {
    "full_name": "NNReal.tendsto_sum_nat_add",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "lemma NNReal.tendsto_sum_nat_add (f : ‚Ñï ‚Üí ‚Ñù‚â•0) : Tendsto (fun i => ‚àë' (k : ‚Ñï), f (k + i)) atTop (ùìù 0) := by"
  },
  {
    "full_name": "List.formPerm_apply_get_length",
    "file_path": "Mathlib/GroupTheory/Perm/List.lean",
    "teorema": "lemma List.formPerm_apply_get_length (x : Œ±) (xs : List Œ±) (Œ± : Type u_1) : xs.length < (x :: xs).length := by"
  },
  {
    "full_name": "Polynomial.natDegree_C_add",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "theorem Polynomial.natDegree_C_add (R : Type u) (a : R) (p : R[X]) : (C a + p).natDegree = p.natDegree := by"
  },
  {
    "full_name": "AffineSubspace.wOppSide_iff_exists_left",
    "file_path": "Mathlib/Analysis/Convex/Side.lean",
    "teorema": "theorem AffineSubspace.wOppSide_iff_exists_left (P : Type u_4) (R : Type u_1) (p‚ÇÅ : P) (s : AffineSubspace R P) (x : P) (y : P) : s.WOppSide x y ‚Üî x ‚àà s ‚à® ‚àÉ p‚ÇÇ ‚àà s, SameRay R (x -·µ• p‚ÇÅ) (p‚ÇÇ -·µ• y) := by"
  },
  {
    "full_name": "Int.neg_pred",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "teorema": "theorem Int.neg_pred (a : ‚Ñ§) : -a.pred = (-a).succ := by"
  },
  {
    "full_name": "FractionalIdeal.coe_spanSingleton",
    "file_path": "Mathlib/RingTheory/FractionalIdeal/Operations.lean",
    "teorema": "lemma FractionalIdeal.coe_spanSingleton (P : Type u_2) (R : Type u_1) (S : Submonoid R) (x : P) : ‚Üë(spanSingleton S x) = span R {x} := by"
  },
  {
    "full_name": "MeasureTheory.setLIntegral_tilted",
    "file_path": "Mathlib/MeasureTheory/Measure/Tilted.lean",
    "teorema": "theorem MeasureTheory.setLIntegral_tilted (f : Œ± ‚Üí ‚Ñù) (g : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±) in s, g x ‚àÇŒº.tilted f = ‚à´‚Åª (x : Œ±) in s, ENNReal.ofReal (rexp (f x) / ‚à´ (x : Œ±), rexp (f x) ‚àÇŒº) * g x ‚àÇŒº := by"
  },
  {
    "full_name": "isPathConnected_iff_eq",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "teorema": "theorem isPathConnected_iff_eq (F : Set X) (X : Type u_1) (x : X) : IsPathConnected F ‚Üî ‚àÉ x ‚àà F, pathComponentIn x F = F := by"
  },
  {
    "full_name": "Metric.Sigma.fst_eq_of_dist_lt_one",
    "file_path": "Mathlib/Topology/MetricSpace/Gluing.lean",
    "teorema": "theorem Metric.Sigma.fst_eq_of_dist_lt_one (E : Œπ ‚Üí Type u_2) (x : (i : Œπ) √ó E i) (y : (i : Œπ) √ó E i) (Œπ : Type u_1) : x.fst = y.fst := by"
  },
  {
    "full_name": "Polynomial.reverse_natDegree",
    "file_path": "Mathlib/Algebra/Polynomial/Reverse.lean",
    "teorema": "theorem Polynomial.reverse_natDegree (R : Type u_1) (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree := by"
  },
  {
    "full_name": "IsometryEquiv.image_closedBall",
    "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean",
    "teorema": "lemma IsometryEquiv.image_closedBall (h : Œ± ‚âÉ·µ¢ Œ≤) (r : ‚Ñù) (x : Œ±) (Œ± : Type u) (Œ≤ : Type v) : ‚áëh '' Metric.closedBall x r = Metric.closedBall (h x) r := by"
  },
  {
    "full_name": "CategoryTheory.Limits.CoconeMorphism.ext",
    "file_path": "Mathlib/CategoryTheory/Limits/Cones.lean",
    "teorema": "theorem CategoryTheory.Limits.CoconeMorphism.ext (C : Type u‚ÇÉ) (F : J ‚•§ C) (J : Type u‚ÇÅ) (c : Cocone F) (f : c ‚ü∂ c') (g : c ‚ü∂ c') : f = g := by"
  },
  {
    "full_name": "Function.Periodic.const_sub",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "theorem Function.Periodic.const_sub (a : Œ±) (c : Œ±) (f : Œ± ‚Üí Œ≤) (x : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : (fun x => f (a - x)) (x + c) = (fun x => f (a - x)) x := by"
  },
  {
    "full_name": "ENNReal.toReal_eq_toReal_iff",
    "file_path": "Mathlib/Data/ENNReal/Basic.lean",
    "teorema": "lemma ENNReal.toReal_eq_toReal_iff (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù‚â•0‚àû) : x.toReal = y.toReal ‚Üî x = y ‚à® x = 0 ‚àß y = ‚ä§ ‚à® x = ‚ä§ ‚àß y = 0 := by"
  },
  {
    "full_name": "RCLike.smul_re",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "theorem RCLike.smul_re (K : Type u_1) (r : ‚Ñù) (z : K) : re (r ‚Ä¢ z) = r * re z := by"
  },
  {
    "full_name": "Set.encard_eq_two",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "theorem Set.encard_eq_two (s : Set Œ±) (Œ± : Type u_1) : s.encard = 2 ‚Üî ‚àÉ x y, x ‚â† y ‚àß s = {x, y} := by"
  },
  {
    "full_name": "MeasureTheory.FiniteMeasure.injective_toWeakDualBCNN",
    "file_path": "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean",
    "teorema": "theorem MeasureTheory.FiniteMeasure.injective_toWeakDualBCNN : Injective toWeakDualBCNN := by"
  },
  {
    "full_name": "Nat.digits_lt_base",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "teorema": "theorem Nat.digits_lt_base (b : ‚Ñï) (d : ‚Ñï) : d < b := by"
  },
  {
    "full_name": "Matrix.exp_neg",
    "file_path": "Mathlib/Analysis/NormedSpace/MatrixExponential.lean",
    "teorema": "theorem Matrix.exp_neg (A : Matrix m m ùî∏) (m : Type u_2) (ùî∏ : Type u_6) (ùïÇ : Type u_1) : exp ùïÇ (-A) = (exp ùïÇ A)‚Åª¬π := by"
  },
  {
    "full_name": "Nat.le_div_two_iff_mul_two_le",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "teorema": "theorem Nat.le_div_two_iff_mul_two_le (m : ‚Ñï) (n : ‚Ñï) : m ‚â§ n / 2 ‚Üî ‚Üëm * 2 ‚â§ ‚Üën := by"
  },
  {
    "full_name": "Int.floor_neg",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem Int.floor_neg (a : Œ±) (z : ‚Ñ§) (Œ± : Type u_2) : z ‚â§ ‚åä-a‚åã ‚Üî z ‚â§ -‚åàa‚åâ := by"
  },
  {
    "full_name": "MeasureTheory.Measure.prod_sum",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "theorem MeasureTheory.Measure.prod_sum (m : Œπ ‚Üí Measure Œ±) (Œ± : Type u_1) (Œπ : Type u_7) : (sum m).prod (sum m') = sum fun p => (m p.1).prod (m' p.2) := by"
  },
  {
    "full_name": "Nat.dist_cast_rat",
    "file_path": "Mathlib/Topology/Instances/Rat.lean",
    "teorema": "lemma Nat.dist_cast_rat (x : ‚Ñï) (y : ‚Ñï) : dist ‚Üëx ‚Üëy = dist x y := by"
  },
  {
    "full_name": "Profinite.finiteCoproduct.Œπ_injective",
    "file_path": "Mathlib/Topology/Category/Profinite/Limits.lean",
    "teorema": "theorem Profinite.finiteCoproduct.Œπ_injective (X : Œ± ‚Üí Profinite) (a : Œ±) (Œ± : Type w) : Function.Injective ‚áë(Œπ X a) := by"
  },
  {
    "full_name": "Turing.ListBlank.ext",
    "file_path": "Mathlib/Computability/TuringMachine.lean",
    "teorema": "lemma Turing.ListBlank.ext (L‚ÇÅ : ListBlank Œì) (L‚ÇÇ : ListBlank Œì) (Œì : Type u_1) : (‚àÄ (i_1 : ‚Ñï), L‚ÇÅ.nth i_1 = L‚ÇÇ.nth i_1) ‚Üí L‚ÇÅ = L‚ÇÇ := by"
  },
  {
    "full_name": "Surreal.Multiplication.P1_of_ih",
    "file_path": "Mathlib/SetTheory/Surreal/Multiplication.lean",
    "teorema": "lemma Surreal.Multiplication.P1_of_ih (x : PGame) (y : PGame) : (x * y).Numeric := by"
  },
  {
    "full_name": "IntermediateField.isSplittingField_iSup",
    "file_path": "Mathlib/FieldTheory/Adjoin.lean",
    "teorema": "lemma IntermediateField.isSplittingField_iSup (K : Type u_3) (L : Type u_4) (p : Œπ ‚Üí K[X]) (s : Finset Œπ) (t : Œπ ‚Üí IntermediateField K L) (Œπ : Type u_5) : IsSplittingField K (‚Ü•(‚®Ü i ‚àà s, t i)) (‚àè i ‚àà s, p i) := by"
  },
  {
    "full_name": "Real.sInf_le_sSup",
    "file_path": "Mathlib/Data/Real/Archimedean.lean",
    "teorema": "lemma Real.sInf_le_sSup (s : Set ‚Ñù) : sInf s ‚â§ sSup s := by"
  },
  {
    "full_name": "LieModule.isCompl_weightSpace_zero_posFittingComp",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "theorem LieModule.isCompl_weightSpace_zero_posFittingComp (L : Type u_3) (M : Type u_4) (R : Type u_2) : IsCompl (weightSpace M 0) (posFittingComp R L M) := by"
  },
  {
    "full_name": "Fintype.mem_piFinset",
    "file_path": "Mathlib/Data/Fintype/Pi.lean",
    "teorema": "lemma Fintype.mem_piFinset (f : (a : Œ±) ‚Üí Œ¥ a) (t : (a : Œ±) ‚Üí Finset (Œ¥ a)) (Œ± : Type u_1) (Œ¥ : Œ± ‚Üí Type u_3) : f ‚àà piFinset t ‚Üî ‚àÄ (a : Œ±), f a ‚àà t a := by"
  },
  {
    "full_name": "Set.image_id_eq",
    "file_path": "Mathlib/Data/Set/Image.lean",
    "teorema": "theorem Set.image_id_eq : image id = id := by"
  },
  {
    "full_name": "Complex.Gamma_integrand_deriv_integrable_A",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean",
    "teorema": "lemma Complex.Gamma_integrand_deriv_integrable_A (X : ‚Ñù) (s : ‚ÑÇ) : IntervalIntegrable (fun x => -(‚Üë(rexp (-x)) * ‚Üëx ^ s)) volume 0 X := by"
  },
  {
    "full_name": "Traversable.foldl_toList",
    "file_path": "Mathlib/Control/Fold.lean",
    "teorema": "theorem Traversable.foldl_toList (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (t : Type u ‚Üí Type u) (x : Œ±) (xs : t Œ≤) (Œ± : Type u) (Œ≤ : Type u) : foldl f x xs = List.foldl f x (toList xs) := by"
  },
  {
    "full_name": "Polynomial.trinomial_leading_coeff'",
    "file_path": "Mathlib/Algebra/Polynomial/UnitTrinomial.lean",
    "teorema": "lemma Polynomial.trinomial_leading_coeff' (R : Type u_1) (k : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) (u : R) (v : R) (w : R) : (trinomial k m n u v w).coeff n = w := by"
  },
  {
    "full_name": "AddSubgroup.norm_normedMk_le",
    "file_path": "Mathlib/Analysis/Normed/Group/Quotient.lean",
    "teorema": "theorem AddSubgroup.norm_normedMk_le (M : Type u_1) (S : AddSubgroup M) (m : M) : ‚ÄñS.normedMk m‚Äñ ‚â§ 1 * ‚Äñm‚Äñ := by"
  },
  {
    "full_name": "EuclideanGeometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
    "teorema": "theorem EuclideanGeometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi (P : Type u_2) (p1 : P) (p2 : P) (p3 : P) (p4 : P) (p5 : P) : ‚à† p1 p5 p2 = ‚à† p3 p5 p4 := by"
  },
  {
    "full_name": "Multiset.eq_union_right",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.eq_union_right (s : Multiset Œ±) (t : Multiset Œ±) (Œ± : Type u_1) : s ‚à™ t = t := by"
  },
  {
    "full_name": "EReal.inv_pos_of_pos_ne_top",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "theorem EReal.inv_pos_of_pos_ne_top (a : EReal) : 0 < a‚Åª¬π := by"
  },
  {
    "full_name": "LinearMap.charpoly_natDegree",
    "file_path": "Mathlib/LinearAlgebra/Charpoly/Basic.lean",
    "teorema": "lemma LinearMap.charpoly_natDegree (M : Type v) (R : Type u) (f : M ‚Üí‚Çó[R] M) : f.charpoly.natDegree = finrank R M := by"
  },
  {
    "full_name": "Batteries.BinomialHeap.Imp.Heap.WF.merge'",
    "file_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "teorema": "lemma Batteries.BinomialHeap.Imp.Heap.WF.merge' (le : Œ±‚úù ‚Üí Œ±‚úù ‚Üí Bool) (n : Nat) (s‚ÇÅ : Heap Œ±‚úù) (s‚ÇÇ : Heap Œ±‚úù) : WF le n (merge le s‚ÇÅ s‚ÇÇ) ‚àß ((s‚ÇÅ.rankGT n ‚Üî s‚ÇÇ.rankGT n) ‚Üí (merge le s‚ÇÅ s‚ÇÇ).rankGT n) := by"
  },
  {
    "full_name": "Filter.HasBasis.equicontinuousAt_iff",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "theorem Filter.HasBasis.equicontinuousAt_iff (F : Œπ ‚Üí X ‚Üí Œ±) (X : Type u_3) (p‚ÇÅ : Œ∫‚ÇÅ ‚Üí Prop) (p‚ÇÇ : Œ∫‚ÇÇ ‚Üí Prop) (s‚ÇÅ : Œ∫‚ÇÅ ‚Üí Set X) (s‚ÇÇ : Œ∫‚ÇÇ ‚Üí Set (Œ± √ó Œ±)) (x‚ÇÄ : X) (Œ± : Type u_7) (Œπ : Type u_1) (Œ∫‚ÇÅ : Type u_13) (Œ∫‚ÇÇ : Type u_14) : EquicontinuousAt F x‚ÇÄ ‚Üî ‚àÄ (k‚ÇÇ : Œ∫‚ÇÇ), p‚ÇÇ k‚ÇÇ ‚Üí ‚àÉ k‚ÇÅ, p‚ÇÅ k‚ÇÅ ‚àß ‚àÄ x ‚àà s‚ÇÅ k‚ÇÅ, ‚àÄ (i : Œπ), (F i x‚ÇÄ, F i x) ‚àà s‚ÇÇ k‚ÇÇ := by"
  },
  {
    "full_name": "bddBelow_closure",
    "file_path": "Mathlib/Topology/Order/OrderClosed.lean",
    "teorema": "lemma bddBelow_closure (s : Set Œ±) (Œ± : Type u) : BddBelow (closure s) ‚Üî BddBelow s := by"
  },
  {
    "full_name": "Subring.closure_induction'",
    "file_path": "Mathlib/Algebra/Ring/Subring/Basic.lean",
    "teorema": "theorem Subring.closure_induction' (R : Type u) (a : R) (ha : a ‚àà closure s) (p : (x : R) ‚Üí x ‚àà closure s ‚Üí Prop) (s : Set R) : p a ha := by"
  },
  {
    "full_name": "MvPowerSeries.coeff_C_mul",
    "file_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean",
    "teorema": "theorem MvPowerSeries.coeff_C_mul (R : Type u_2) (a : R) (n : œÉ ‚Üí‚ÇÄ ‚Ñï) (œÉ : Type u_1) (œÜ : MvPowerSeries œÉ R) : (coeff R n) ((C œÉ R) a * œÜ) = a * (coeff R n) œÜ := by"
  },
  {
    "full_name": "PMF.toOuterMeasure_apply_eq_zero_iff",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Basic.lean",
    "teorema": "theorem PMF.toOuterMeasure_apply_eq_zero_iff (p : PMF Œ±) (s : Set Œ±) (Œ± : Type u_1) : p.toOuterMeasure s = 0 ‚Üî Disjoint p.support s := by"
  },
  {
    "full_name": "ModularForm.slash_action_eq'_iff",
    "file_path": "Mathlib/NumberTheory/ModularForms/SlashActions.lean",
    "teorema": "lemma ModularForm.slash_action_eq'_iff (f : ‚Ñç ‚Üí ‚ÑÇ) (k : ‚Ñ§) (z : ‚Ñç) (Œì : Subgroup SL(2, ‚Ñ§)) (Œ≥ : ‚Ü•Œì) : (f ‚à£[k] Œ≥) z = f z ‚Üî f (Œ≥ ‚Ä¢ z) = (‚Üë(‚Üë‚Üë‚ÜëŒ≥ 1 0) * ‚Üëz + ‚Üë(‚Üë‚Üë‚ÜëŒ≥ 1 1)) ^ k * f z := by"
  },
  {
    "full_name": "List.map_permutationsAux2'",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "teorema": "lemma List.map_permutationsAux2' (f : List Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ±') (r : List Œ≤) (t : Œ±) (ts : List Œ±) (ys : List Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : map g' (permutationsAux2 t ts r ys f).2 = (permutationsAux2 (g t) (map g ts) (map g' r) (map g ys) f').2 := by"
  },
  {
    "full_name": "MeasureTheory.ae_restrict_union_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "theorem MeasureTheory.ae_restrict_union_iff (p : Œ± ‚Üí Prop) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_2) (Œº : Measure Œ±) : (‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict (s ‚à™ t), p x) ‚Üî (‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict s, p x) ‚àß ‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict t, p x := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.rnDeriv_def'",
    "file_path": "Mathlib/Probability/Kernel/RadonNikodym.lean",
    "teorema": "theorem ProbabilityTheory.kernel.rnDeriv_def' (Œ± : Type u_1) (Œ≥ : Type u_2) (Œ∑ : ‚Ü•(kernel Œ± Œ≥)) (Œ∫ : ‚Ü•(kernel Œ± Œ≥)) : rnDeriv Œ∫ Œ∑ = fun a x => ENNReal.ofReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x) / ENNReal.ofReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x) := by"
  },
  {
    "full_name": "ProbabilityTheory.eq_condKernel_of_measure_eq_compProd",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Unique.lean",
    "teorema": "lemma ProbabilityTheory.eq_condKernel_of_measure_eq_compProd (Œ© : Type u_3) (Œ± : Type u_1) (Œ∫ : ‚Ü•(kernel Œ± Œ©)) (œÅ : Measure (Œ± √ó Œ©)) : ‚àÄ·µê (x : Œ±) ‚àÇœÅ.fst, Œ∫ x = œÅ.condKernel x := by"
  },
  {
    "full_name": "Ordinal.blsub_eq_zero_iff",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "lemma Ordinal.blsub_eq_zero_iff (f : (a : Ordinal.{u_4}) ‚Üí a < o ‚Üí Ordinal.{max u_5 u_4}) (o : Ordinal.{u_4}) : o.blsub f = 0 ‚Üî o = 0 := by"
  },
  {
    "full_name": "t0Space_iff_uniformity'",
    "file_path": "Mathlib/Topology/UniformSpace/Separation.lean",
    "teorema": "theorem t0Space_iff_uniformity' (Œ± : Type u) : T0Space Œ± ‚Üî Pairwise fun x y => ‚àÉ r ‚àà ùì§ Œ±, (x, y) ‚àâ r := by"
  },
  {
    "full_name": "ConvexOn.smul''",
    "file_path": "Mathlib/Analysis/Convex/Mul.lean",
    "teorema": "theorem ConvexOn.smul'' (E : Type u_2) (F : Type u_3) (f : ùïú ‚Üí E) (g : ùïú ‚Üí F) (s : Set ùïú) (ùïú : Type u_1) : ConcaveOn ùïú s (f ‚Ä¢ g) := by"
  },
  {
    "full_name": "BoxIntegral.Box.biUnion_coe_eq_coe",
    "file_path": "Mathlib/Analysis/BoxIntegral/Box/Basic.lean",
    "teorema": "lemma BoxIntegral.Box.biUnion_coe_eq_coe (I : WithBot (Box Œπ)) (J : Box Œπ) (Œπ : Type u_1) : ‚ãÉ J, ‚ãÉ (_ : ‚ÜëJ = I), ‚ÜëJ = ‚ÜëI := by"
  },
  {
    "full_name": "BoxIntegral.Prepartition.mem_iUnion",
    "file_path": "Mathlib/Analysis/BoxIntegral/Partition/Basic.lean",
    "teorema": "theorem BoxIntegral.Prepartition.mem_iUnion (I : Box Œπ) (J : Box Œπ) (x : Œπ ‚Üí ‚Ñù) (Œπ : Type u_1) (œÄ : Prepartition I) : x ‚àà œÄ.iUnion ‚Üî ‚àÉ J ‚àà œÄ, x ‚àà J := by"
  },
  {
    "full_name": "Submodule.comm_trans_rTensorOne",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Submodule.lean",
    "teorema": "lemma Submodule.comm_trans_rTensorOne (M : Submodule R S) (R : Type u) (S : Type v) : TensorProduct.comm R ‚Ü•‚ä• ‚Ü•M ‚â™‚â´‚Çó M.rTensorOne = M.lTensorOne := by"
  },
  {
    "full_name": "CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_œÄ",
    "file_path": "Mathlib/CategoryTheory/Limits/FunctorCategory.lean",
    "teorema": "lemma CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_œÄ (C : Type u) (F : J ‚•§ K ‚•§ C) (J : Type u‚ÇÅ) (K : Type u‚ÇÇ) (j : J) (k : K) : (limitObjIsoLimitCompEvaluation F k).hom ‚â´ limit.œÄ (F ‚ãô (evaluation K C).obj k) j = (limit.œÄ F j).app k := by"
  },
  {
    "full_name": "Nat.gcd_mul_left_add_left",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "teorema": "lemma Nat.gcd_mul_left_add_left (k : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) : (n * k + m).gcd n = m.gcd n := by"
  },
  {
    "full_name": "UniformInducing.of_comp_iff",
    "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean",
    "teorema": "theorem UniformInducing.of_comp_iff (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (Œ± : Type u) (Œ≤ : Type v) (Œ≥ : Type w) : UniformInducing (g ‚àò f) ‚Üî UniformInducing f := by"
  },
  {
    "full_name": "Ordnode.Bounded.to_sep",
    "file_path": "Mathlib/Data/Ordmap/Ordset.lean",
    "teorema": "theorem Ordnode.Bounded.to_sep (t‚ÇÅ : Ordnode Œ±) (t‚ÇÇ : Ordnode Œ±) (Œ± : Type u_1) : All (fun y => All (fun z => y < z) t‚ÇÇ) t‚ÇÅ := by"
  },
  {
    "full_name": "IsBoundedBilinearMap.contDiff",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma IsBoundedBilinearMap.contDiff (E : Type uE) (F : Type uF) (G : Type uG) (b : E √ó F ‚Üí G) (n : ‚Ñï‚àû) (ùïú : Type u_1) : ContDiff ùïú n b := by"
  },
  {
    "full_name": "ContinuousLinearEquiv.comp_right_differentiableWithinAt_iff",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean",
    "teorema": "lemma ContinuousLinearEquiv.comp_right_differentiableWithinAt_iff (E : Type u_2) (F : Type u_3) (G : Type u_4) (L : Filter E) (f : F ‚Üí G) (iso : E ‚âÉL[ùïú] F) (s : Set F) (x : E) (ùïú : Type u_1) : DifferentiableWithinAt ùïú (f ‚àò ‚áëiso) (‚áëiso ‚Åª¬π' s) x ‚Üî DifferentiableWithinAt ùïú f s (iso x) := by"
  },
  {
    "full_name": "CategoryTheory.Adjunction.leftAdjointUniq_trans_app",
    "file_path": "Mathlib/CategoryTheory/Adjunction/Unique.lean",
    "teorema": "theorem CategoryTheory.Adjunction.leftAdjointUniq_trans_app (C : Type u_1) (D : Type u_2) (F : C ‚•§ D) (G : D ‚•§ C) (adj1 : F ‚ä£ G) (adj2 : F' ‚ä£ G) (adj3 : F'' ‚ä£ G) (x : C) : (adj1.leftAdjointUniq adj2).hom.app x ‚â´ (adj2.leftAdjointUniq adj3).hom.app x = (adj1.leftAdjointUniq adj3).hom.app x := by"
  },
  {
    "full_name": "ContinuousMap.continuous_comp_left",
    "file_path": "Mathlib/Topology/CompactOpen.lean",
    "teorema": "lemma ContinuousMap.continuous_comp_left (K : Set X) (U : Set Z) (X : Type u_2) (Y : Type u_3) (Z : Type u_4) (f : C(X, Y)) : IsOpen {x | MapsTo (‚áë(x.comp f)) K U} := by"
  },
  {
    "full_name": "CategoryTheory.NatTrans.CommShift.app_shift",
    "file_path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
    "teorema": "theorem CategoryTheory.NatTrans.CommShift.app_shift (A : Type u_5) (C : Type u_1) (D : Type u_2) (F‚ÇÅ : C ‚•§ D) (F‚ÇÇ : C ‚•§ D) (X : C) (a : A) (œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ) : œÑ.app ((shiftFunctor C a).obj X) = (F‚ÇÅ.commShiftIso a).hom.app X ‚â´ (shiftFunctor D a).map (œÑ.app X) ‚â´ (F‚ÇÇ.commShiftIso a).inv.app X := by"
  },
  {
    "full_name": "Prod.ext_iff",
    "file_path": "Mathlib/Data/Prod/Basic.lean",
    "teorema": "lemma Prod.ext_iff (p : Œ± √ó Œ≤) (q : Œ± √ó Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : p = q ‚Üî p.fst = q.fst ‚àß p.snd = q.snd := by"
  },
  {
    "full_name": "List.count_singleton",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Count.lean",
    "teorema": "theorem List.count_singleton (a : Œ±) (Œ± : Type u_1) : count a [a] = 1 := by"
  },
  {
    "full_name": "Substring.Valid.bsize",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "lemma Substring.Valid.bsize : x‚úù.bsize = utf8Len x‚úù.toString.data := by"
  },
  {
    "full_name": "MeasureTheory.integral_zero",
    "file_path": "Mathlib/MeasureTheory/Integral/Bochner.lean",
    "teorema": "theorem MeasureTheory.integral_zero (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´ (x : Œ±), 0 ‚àÇŒº = 0 := by"
  },
  {
    "full_name": "MeasureTheory.integrable_withDensity_iff_integrable_smul'",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.integrable_withDensity_iff_integrable_smul' (E : Type u_5) (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (g : Œ± ‚Üí E) (Œ± : Type u_1) (Œº : Measure Œ±) : Integrable g (Œº.withDensity f) ‚Üî Integrable (fun x => (f x).toReal ‚Ä¢ g x) Œº := by"
  },
  {
    "full_name": "Finset.inv_smul_finset_distrib",
    "file_path": "Mathlib/Data/Finset/Pointwise.lean",
    "teorema": "lemma Finset.inv_smul_finset_distrib (a : Œ±) (s : Finset Œ±) (Œ± : Type u_2) : (a ‚Ä¢ s)‚Åª¬π = op a‚Åª¬π ‚Ä¢ s‚Åª¬π := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.isEquivalence_imp",
    "file_path": "Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean",
    "teorema": "lemma CategoryTheory.LocalizerMorphism.isEquivalence_imp (D‚ÇÅ : Type u‚ÇÑ) (D‚ÇÇ : Type u‚ÇÖ) (G : D‚ÇÅ ‚•§ D‚ÇÇ) : G'.IsEquivalence := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_pos_iff_support",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "theorem MeasureTheory.lintegral_pos_iff_support (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : 0 < ‚à´‚Åª (a : Œ±), f a ‚àÇŒº ‚Üî 0 < Œº (support f) := by"
  },
  {
    "full_name": "Matrix.cons_add",
    "file_path": "Mathlib/Data/Fin/VecNotation.lean",
    "teorema": "lemma Matrix.cons_add (n : ‚Ñï) (v : Fin n ‚Üí Œ±) (w : Fin n.succ ‚Üí Œ±) (x : Œ±) (Œ± : Type u) : vecCons x v + w = vecCons (x + vecHead w) (v + vecTail w) := by"
  },
  {
    "full_name": "SimpleGraph.Walk.dropUntil_copy",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "lemma SimpleGraph.Walk.dropUntil_copy (G : SimpleGraph V) (V : Type u) (p : G.Walk v w) (u : V) (v : V) (w : V) : u ‚àà p.support := by"
  },
  {
    "full_name": "Nat.Partrec.Code.eval_prec_succ",
    "file_path": "Mathlib/Computability/PartrecCode.lean",
    "teorema": "lemma Nat.Partrec.Code.eval_prec_succ (a : ‚Ñï) (cf : Code) (cg : Code) (k : ‚Ñï) : (cf.prec cg).eval (Nat.pair a k.succ) = do let ih ‚Üê (cf.prec cg).eval (Nat.pair a k) cg.eval (Nat.pair a (Nat.pair k ih)) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_œÄ_œÄ",
    "file_path": "Mathlib/CategoryTheory/Limits/Fubini.lean",
    "teorema": "lemma CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_œÄ_œÄ (C : Type u) (G : J √ó K ‚•§ C) (J : Type v) (K : Type v) (j : J) (k : K) : (limitCurrySwapCompLimIsoLimitCurryCompLim G).hom ‚â´ limit.œÄ (curry.obj G ‚ãô lim) j ‚â´ limit.œÄ ((curry.obj G).obj j) k = limit.œÄ (curry.obj (Prod.swap K J ‚ãô G) ‚ãô lim) k ‚â´ limit.œÄ ((curry.obj (Prod.swap K J ‚ãô G)).obj k) j := by"
  },
  {
    "full_name": "Bool.coe_false",
    "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean",
    "teorema": "theorem Bool.coe_false : (false = true) = False := by"
  },
  {
    "full_name": "Rat.normalize.reduced'",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.normalize.reduced' (den : Nat) (g : Nat) (num : Int) : (num / ‚Üëg).natAbs.Coprime (den / g) := by"
  },
  {
    "full_name": "List.asString_inj",
    "file_path": "Mathlib/Data/String/Basic.lean",
    "teorema": "theorem List.asString_inj (l : List Char) : l = l' := by"
  },
  {
    "full_name": "SimpleGraph.IsSRGWith.compl_is_regular",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean",
    "teorema": "lemma SimpleGraph.IsSRGWith.compl_is_regular (k : ‚Ñï) (n : ‚Ñï) : G·∂ú.IsRegularOfDegree (n - k - 1) := by"
  },
  {
    "full_name": "Complex.differentiableOn_tsum_of_summable_norm",
    "file_path": "Mathlib/Analysis/Complex/LocallyUniformLimit.lean",
    "teorema": "lemma Complex.differentiableOn_tsum_of_summable_norm (E : Type u_1) (F : Œπ ‚Üí ‚ÑÇ ‚Üí E) (U : Set ‚ÑÇ) (Œπ : Type u_2) : DifferentiableOn ‚ÑÇ (fun w => ‚àë' (i : Œπ), F i w) U := by"
  },
  {
    "full_name": "Matrix.Represents.add",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean",
    "teorema": "lemma Matrix.Represents.add (A : Matrix Œπ Œπ R) (M : Type u_2) (R : Type u_3) (b : Œπ ‚Üí M) (f : Module.End R M) (Œπ : Type u_1) : Represents b (A + A') (f + f') := by"
  },
  {
    "full_name": "le_of_forall_one_lt_div_le",
    "file_path": "Mathlib/Algebra/Order/Group/DenselyOrdered.lean",
    "teorema": "lemma le_of_forall_one_lt_div_le (a : Œ±) (b : Œ±) (Œ± : Type u_1) (Œµ : Œ±) : a * Œµ ‚â§ b := by"
  },
  {
    "full_name": "Directed.exists_mem_subset_of_finset_subset_biUnion",
    "file_path": "Mathlib/Data/Set/Finite.lean",
    "teorema": "theorem Directed.exists_mem_subset_of_finset_subset_biUnion (f : Œπ ‚Üí Set Œ±) (s : Finset Œ±) (Œ± : Type u_1) (Œπ : Type u_2) : ‚àÉ i, ‚Üës ‚äÜ f i := by"
  },
  {
    "full_name": "CategoryTheory.Limits.colimitLimitToLimitColimit_injective",
    "file_path": "Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean",
    "teorema": "lemma CategoryTheory.Limits.colimitLimitToLimitColimit_injective (F : J √ó K ‚•§ Type v) (J : Type u‚ÇÅ) (K : Type u‚ÇÇ) : Function.Injective (colimitLimitToLimitColimit F) := by"
  },
  {
    "full_name": "PowerSeries.order_monomial",
    "file_path": "Mathlib/RingTheory/PowerSeries/Order.lean",
    "teorema": "lemma PowerSeries.order_monomial (R : Type u_1) (a : R) (n : ‚Ñï) : ((monomial R n) a).order = if a = 0 then ‚ä§ else ‚Üën := by"
  },
  {
    "full_name": "AlgEquiv.arrowCongr_comp",
    "file_path": "Mathlib/Algebra/Algebra/Equiv.lean",
    "teorema": "theorem AlgEquiv.arrowCongr_comp (A‚ÇÅ : Type uA‚ÇÅ) (A‚ÇÇ : Type uA‚ÇÇ) (A‚ÇÉ : Type uA‚ÇÉ) (R : Type uR) (e‚ÇÅ : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÅ') (e‚ÇÇ : A‚ÇÇ ‚âÉ‚Çê[R] A‚ÇÇ') (e‚ÇÉ : A‚ÇÉ ‚âÉ‚Çê[R] A‚ÇÉ') (f : A‚ÇÅ ‚Üí‚Çê[R] A‚ÇÇ) (g : A‚ÇÇ ‚Üí‚Çê[R] A‚ÇÉ) : (e‚ÇÅ.arrowCongr e‚ÇÉ) (g.comp f) = ((e‚ÇÇ.arrowCongr e‚ÇÉ) g).comp ((e‚ÇÅ.arrowCongr e‚ÇÇ) f) := by"
  },
  {
    "full_name": "ProbabilityTheory.measure_ge_le_exp_mul_mgf",
    "file_path": "Mathlib/Probability/Moments.lean",
    "teorema": "lemma ProbabilityTheory.measure_ge_le_exp_mul_mgf (X : Œ© ‚Üí ‚Ñù) (t : ‚Ñù) (Œ© : Type u_1) (Œµ : ‚Ñù) (Œº : Measure Œ©) : (Œº {œâ | Œµ ‚â§ X œâ}).toReal ‚â§ rexp (-t * Œµ) * mgf X Œº t := by"
  },
  {
    "full_name": "FirstOrder.Language.realize_noTopOrder_iff",
    "file_path": "Mathlib/ModelTheory/Order.lean",
    "teorema": "lemma FirstOrder.Language.realize_noTopOrder_iff (M : Type w') : M ‚ä® Language.order.noTopOrderSentence ‚Üî NoTopOrder M := by"
  },
  {
    "full_name": "CategoryTheory.GrothendieckTopology.W_adj_unit_app",
    "file_path": "Mathlib/CategoryTheory/Sites/Localization.lean",
    "teorema": "theorem CategoryTheory.GrothendieckTopology.W_adj_unit_app (A : Type u_2) (C : Type u_1) (G : (C·µí·µñ ‚•§ A) ‚•§ Sheaf J A) (J : GrothendieckTopology C) (P : C·µí·µñ ‚•§ A) (adj : G ‚ä£ sheafToPresheaf J A) : J.W (adj.unit.app P) := by"
  },
  {
    "full_name": "Vector.tendsto_cons",
    "file_path": "Mathlib/Topology/List.lean",
    "teorema": "theorem Vector.tendsto_cons (a : Œ±) (l : Vector Œ± n) (n : ‚Ñï) (Œ± : Type u_1) : Tendsto (fun p => p.1 ::·µ• p.2) (ùìù a √óÀ¢ ùìù l) (ùìù (a ::·µ• l)) := by"
  },
  {
    "full_name": "Ideal.map_includeRight_eq",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean",
    "teorema": "theorem Ideal.map_includeRight_eq (A : Type u_2) (B : Type u_3) (I : Ideal B) (R : Type u_1) : Submodule.restrictScalars R (map includeRight I) = LinearMap.range (LinearMap.lTensor A (Submodule.restrictScalars R I).subtype) := by"
  },
  {
    "full_name": "MvPFunctor.M.bisim'",
    "file_path": "Mathlib/Data/PFunctor/Multivariate/M.lean",
    "teorema": "theorem MvPFunctor.M.bisim' (P : MvPFunctor.{u} (n + 1)) (n : ‚Ñï) (x : P.M Œ±) (y : P.M Œ±) (Œ± : TypeVec.{u} n) : x = y := by"
  },
  {
    "full_name": "Nat.even_or_odd'",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "theorem Nat.even_or_odd' (n : ‚Ñï) : ‚àÉ k, n = 2 * k ‚à® n = 2 * k + 1 := by"
  },
  {
    "full_name": "AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_add_smoothingFn",
    "file_path": "Mathlib/Computability/AkraBazzi/AkraBazzi.lean",
    "teorema": "theorem AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_add_smoothingFn (p : ‚Ñù) : (fun x => ‚Äñderiv (fun z => z ^ p * (1 + Œµ z)) x‚Äñ) =Œò[atTop] fun z => z ^ (p - 1) := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_comm",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "teorema": "lemma InnerProductGeometry.angle_comm (V : Type u_1) (x : V) (y : V) : angle x y = angle y x := by"
  },
  {
    "full_name": "Subsemigroup.mem_sSup_of_directed_on",
    "file_path": "Mathlib/Algebra/Group/Subsemigroup/Membership.lean",
    "teorema": "lemma Subsemigroup.mem_sSup_of_directed_on (M : Type u_2) (S : Set (Subsemigroup M)) (x : M) : x ‚àà sSup S ‚Üî ‚àÉ s ‚àà S, x ‚àà s := by"
  },
  {
    "full_name": "Multiset.card_join",
    "file_path": "Mathlib/Data/Multiset/Bind.lean",
    "teorema": "theorem Multiset.card_join : card (join 0) = (map (‚áëcard) 0).sum := by"
  },
  {
    "full_name": "convexHull_union",
    "file_path": "Mathlib/Analysis/Convex/Join.lean",
    "teorema": "theorem convexHull_union (E : Type u_3) (s : Set E) (t : Set E) (ùïú : Type u_2) : (convexHull ùïú) (s ‚à™ t) = convexJoin ùïú ((convexHull ùïú) s) ((convexHull ùïú) t) := by"
  },
  {
    "full_name": "t2_iff_ultrafilter",
    "file_path": "Mathlib/Topology/Separation.lean",
    "teorema": "theorem t2_iff_ultrafilter (X : Type u_1) : (‚àÄ {x y : X}, (ùìù x ‚äì ùìù y).NeBot ‚Üí x = y) ‚Üî ‚àÄ {x y : X} (f : Ultrafilter X), ‚Üëf ‚â§ ùìù x ‚Üí ‚Üëf ‚â§ ùìù y ‚Üí x = y := by"
  },
  {
    "full_name": "Part.inter_get_eq",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "theorem Part.inter_get_eq (a : Part Œ±) (b : Part Œ±) (hab : (a ‚à© b).Dom) (Œ± : Type u_1) : (a ‚à© b).get hab = a.get ‚ãØ ‚à© b.get ‚ãØ := by"
  },
  {
    "full_name": "CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean",
    "teorema": "lemma CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv (C : Type u) (X : C) (Y : C) (b : BinaryBicone X Y) (hb : b.IsBilimit) : (hb.isLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit X Y)).inv = desc b.inl b.inr := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.sup",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.Integrable.sup (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_5) (Œº : Measure Œ±) : Integrable (f ‚äî g) Œº := by"
  },
  {
    "full_name": "iSup_const",
    "file_path": "Mathlib/Order/CompleteLattice.lean",
    "teorema": "lemma iSup_const (a : Œ±) (Œ± : Type u_1) : ‚®Ü x, a = a := by"
  },
  {
    "full_name": "Pell.y_dvd_iff",
    "file_path": "Mathlib/NumberTheory/PellMatiyasevic.lean",
    "teorema": "theorem Pell.y_dvd_iff : False := by"
  },
  {
    "full_name": "Nat.floorRoot_def",
    "file_path": "Mathlib/Data/Nat/Factorization/Root.lean",
    "teorema": "lemma Nat.floorRoot_def (a : ‚Ñï) (n : ‚Ñï) : n.floorRoot a = if n = 0 ‚à® a = 0 then 0 else (a.factorization ‚åä/‚åã n).prod fun x x_1 => x ^ x_1 := by"
  },
  {
    "full_name": "HasDerivWithinAt.comp_hasFDerivWithinAt_of_eq",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean",
    "teorema": "lemma HasDerivWithinAt.comp_hasFDerivWithinAt_of_eq (E : Type w) (f : E ‚Üí ùïú') (h‚ÇÇ : ùïú' ‚Üí ùïú') (s : Set E) (x : E) (ùïú : Type u) : HasFDerivWithinAt (h‚ÇÇ ‚àò f) (h‚ÇÇ' ‚Ä¢ f') s x := by"
  },
  {
    "full_name": "hasMellin_sub",
    "file_path": "Mathlib/Analysis/MellinTransform.lean",
    "teorema": "lemma hasMellin_sub (E : Type u_1) (f : ‚Ñù ‚Üí E) (g : ‚Ñù ‚Üí E) (s : ‚ÑÇ) : MellinConvergent (fun t => f t - g t) s := by"
  },
  {
    "full_name": "Order.Ideal.PrimePair.I_isPrime",
    "file_path": "Mathlib/Order/PrimeIdeal.lean",
    "teorema": "theorem Order.Ideal.PrimePair.I_isPrime (IF : PrimePair P) (P : Type u_1) : IsPFilter (‚ÜëIF.I)·∂ú := by"
  },
  {
    "full_name": "Int.addRight_one_isCycle",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean",
    "teorema": "theorem Int.addRight_one_isCycle (n : ‚Ñ§) : (Equiv.addRight 1 ^ n) 0 = n := by"
  },
  {
    "full_name": "AffineIsometryEquiv.vadd_vsub",
    "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean",
    "teorema": "theorem AffineIsometryEquiv.vadd_vsub (V : Type u_2) (V‚ÇÇ : Type u_5) (g : V ‚Üí V‚ÇÇ) : Isometry g := by"
  },
  {
    "full_name": "Polynomial.degree_modByMonic_lt",
    "file_path": "Mathlib/Algebra/Polynomial/Div.lean",
    "teorema": "theorem Polynomial.degree_modByMonic_lt (R : Type u) (p : R[X]) (q : R[X]) : (p %‚Çò q).degree < q.degree := by"
  },
  {
    "full_name": "Nat.Primes.coe_pnat_injective",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "teorema": "lemma Nat.Primes.coe_pnat_injective (p : Primes) (q : Primes) : ‚Üëp = ‚Üëq := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.fst_map_id_prod",
    "file_path": "Mathlib/Probability/Kernel/Composition.lean",
    "teorema": "lemma ProbabilityTheory.kernel.fst_map_id_prod (f : Œ≤ ‚Üí Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_6) (Œ∫ : ‚Ü•(kernel Œ± Œ≤)) : fst (map Œ∫ (fun a => (a, f a)) ‚ãØ) = Œ∫ := by"
  },
  {
    "full_name": "volume_regionBetween_eq_lintegral",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean",
    "teorema": "theorem volume_regionBetween_eq_lintegral (f : Œ± ‚Üí ‚Ñù) (g : Œ± ‚Üí ‚Ñù) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (Œº.prod volume) (regionBetween f g s) = ‚à´‚Åª (y : Œ±) in s, ofReal ((g - f) y) ‚àÇŒº := by"
  },
  {
    "full_name": "WittVector.ghostComponent_zero_verschiebungFun",
    "file_path": "Mathlib/RingTheory/WittVector/Verschiebung.lean",
    "teorema": "theorem WittVector.ghostComponent_zero_verschiebungFun (R : Type u_1) (x : ùïé R) : (ghostComponent 0) x.verschiebungFun = 0 := by"
  },
  {
    "full_name": "Real.sin_three_mul",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Real.sin_three_mul (x : ‚Ñù) : sin (3 * x) = 3 * sin x - 4 * sin x ^ 3 := by"
  },
  {
    "full_name": "MeasureTheory.snormEssSup_zero",
    "file_path": "Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean",
    "teorema": "lemma MeasureTheory.snormEssSup_zero (Œ± : Type u_1) (Œº : Measure Œ±) : snormEssSup 0 Œº = 0 := by"
  },
  {
    "full_name": "contDiff_zero_fun",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma contDiff_zero_fun (E : Type uE) (m : ‚Ñï) (x : E) (ùïú : Type u_1) : Differentiable ùïú (iteratedFDeriv ùïú m fun x => 0) := by"
  },
  {
    "full_name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring_injective",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "teorema": "theorem NonUnitalSemiring.toNonUnitalNonAssocSemiring_injective (R : Type u) : Function.Injective (@toNonUnitalNonAssocSemiring R) := by"
  },
  {
    "full_name": "TopologicalSpace.IsTopologicalBasis.sigma",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "theorem TopologicalSpace.IsTopologicalBasis.sigma (E : Œπ ‚Üí Type u_2) (s : (i : Œπ) ‚Üí Set (Set (E i))) (Œπ : Type u_1) : IsTopologicalBasis (‚ãÉ i, (fun u => Sigma.mk i '' u) '' s i) := by"
  },
  {
    "full_name": "MeasureTheory.Lp.ext_iff",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "theorem MeasureTheory.Lp.ext_iff (E : Type u_2) (f : ‚Ü•(Lp E p Œº)) (g : ‚Ü•(Lp E p Œº)) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚Üë‚Üëf =·∂†[ae Œº] ‚Üë‚Üëg := by"
  },
  {
    "full_name": "Complex.interior_setOf_le_im",
    "file_path": "Mathlib/Analysis/Complex/ReImTopology.lean",
    "teorema": "theorem Complex.interior_setOf_le_im (a : ‚Ñù) : interior {z | a ‚â§ z.im} = {z | a < z.im} := by"
  },
  {
    "full_name": "Batteries.RBNode.Balanced.ins",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "teorema": "theorem Batteries.RBNode.Balanced.ins (cmp : Œ± ‚Üí Œ± ‚Üí Ordering) (v : Œ±) (Œ± : Type u_1) : RedRed (nil.isRed = red) (ins cmp v nil) 0 := by"
  },
  {
    "full_name": "Filter.exists_eventually_atBot",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "theorem Filter.exists_eventually_atBot (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (Œ± : Type u_3) (Œ≤ : Type u_4) : (‚àÉ b, ‚àÄ·∂† (a : Œ±) in atBot, r a b) ‚Üî ‚àÄ·∂† (a‚ÇÄ : Œ±) in atBot, ‚àÉ b, ‚àÄ a ‚â§ a‚ÇÄ, r a b := by"
  },
  {
    "full_name": "Matroid.Base.inter_basis_iff_compl_inter_basis_dual",
    "file_path": "Mathlib/Data/Matroid/Dual.lean",
    "teorema": "theorem Matroid.Base.inter_basis_iff_compl_inter_basis_dual (B : Set Œ±) (M : Matroid Œ±) (X : Set Œ±) (Œ± : Type u_1) : M.Basis (B ‚à© X) X ‚Üî M‚ú∂.Basis (M.E \\ B ‚à© (M.E \\ X)) (M.E \\ X) := by"
  },
  {
    "full_name": "Rat.not_countably_generated_nhds_infty_opc",
    "file_path": "Mathlib/Topology/Instances/RatLemmas.lean",
    "teorema": "theorem Rat.not_countably_generated_nhds_infty_opc : ¬¨(ùìù ‚àû).IsCountablyGenerated := by"
  },
  {
    "full_name": "List.takeWhile_cons_of_neg",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "theorem List.takeWhile_cons_of_neg (l : List Œ±) (p : Œ± ‚Üí Bool) (x : Œ±) (Œ± : Type u) : takeWhile p (x :: l) = [] := by"
  },
  {
    "full_name": "ZNum.ofInt'_neg",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "theorem ZNum.ofInt'_neg (n : ‚Ñï) : ofInt' ‚Üë(n + 1) = -ofInt' -[n+1] := by"
  },
  {
    "full_name": "Con.sup_def",
    "file_path": "Mathlib/GroupTheory/Congruence/Basic.lean",
    "teorema": "theorem Con.sup_def (M : Type u_1) (c : Con M) (d : Con M) : c ‚äî d = conGen (‚áëc ‚äî ‚áëd) := by"
  },
  {
    "full_name": "Part.some_ne_none",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.some_ne_none (x : Œ±) (Œ± : Type u_1) : some x ‚â† none := by"
  },
  {
    "full_name": "Rack.toEnvelGroup.mapAux.well_def",
    "file_path": "Mathlib/Algebra/Quandle.lean",
    "teorema": "lemma Rack.toEnvelGroup.mapAux.well_def (G : Type u_2) (R : Type u_1) (f : R ‚Üí‚óÉ Quandle.Conj G) : mapAux f (a‚úù.mul b‚úù) = mapAux f (a'‚úù.mul b'‚úù) := by"
  },
  {
    "full_name": "Set.left_mem_Ioc",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.left_mem_Ioc (a : Œ±) (b : Œ±) (Œ± : Type u_1) : a ‚àà Ioc a b ‚Üî False := by"
  },
  {
    "full_name": "Finset.affineCombination_vsub",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean",
    "teorema": "lemma Finset.affineCombination_vsub (P : Type u_3) (k : Type u_1) (p : Œπ ‚Üí P) (s : Finset Œπ) (w‚ÇÅ : Œπ ‚Üí k) (w‚ÇÇ : Œπ ‚Üí k) (Œπ : Type u_4) : (affineCombination k s p) w‚ÇÅ -·µ• (affineCombination k s p) w‚ÇÇ = (s.weightedVSub p) (w‚ÇÅ - w‚ÇÇ) := by"
  },
  {
    "full_name": "Matrix.isUnit_det_transpose",
    "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
    "teorema": "lemma Matrix.isUnit_det_transpose : IsUnit A·µÄ.det := by"
  },
  {
    "full_name": "Submodule.ker_inclusion",
    "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean",
    "teorema": "lemma Submodule.ker_inclusion (M : Type u_6) (R : Type u_1) (h : p ‚â§ p') (p : Submodule R M) : ker (inclusion h) = ‚ä• := by"
  },
  {
    "full_name": "MvPFunctor.M.bisim_lemma",
    "file_path": "Mathlib/Data/PFunctor/Multivariate/M.lean",
    "teorema": "lemma MvPFunctor.M.bisim_lemma : ‚àÉ g‚ÇÅ', := by"
  },
  {
    "full_name": "SimpleGraph.dart_edge_eq_mk'_iff'",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Dart.lean",
    "teorema": "lemma SimpleGraph.dart_edge_eq_mk'_iff' (G : SimpleGraph V) (V : Type u_1) : ‚àÄ {d : G.Dart} {u v : V}, d.edge = s(u, v) ‚Üî d.toProd.1 = u ‚àß d.toProd.2 = v ‚à® d.toProd.1 = v ‚àß d.toProd.2 = u := by"
  },
  {
    "full_name": "Monotone.seq_lt_seq_of_lt_of_le",
    "file_path": "Mathlib/Order/Iterate.lean",
    "teorema": "theorem Monotone.seq_lt_seq_of_lt_of_le (n : ‚Ñï) (x : ‚Ñï ‚Üí Œ±) (y : ‚Ñï ‚Üí Œ±) (Œ± : Type u_1) : x n < y n := by"
  },
  {
    "full_name": "Cardinal.lift_le_nat_iff",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "lemma Cardinal.lift_le_nat_iff (a : Cardinal.{u}) (n : ‚Ñï) : lift.{v, u} a ‚â§ ‚Üën ‚Üî a ‚â§ ‚Üën := by"
  },
  {
    "full_name": "Profinite.NobelingProof.GoodProducts.finsupp_sum_mem_span_eval",
    "file_path": "Mathlib/Topology/Category/Profinite/Nobeling.lean",
    "teorema": "lemma Profinite.NobelingProof.GoodProducts.finsupp_sum_mem_span_eval (C : Set (I ‚Üí Bool)) (I : Type u) (a : I) (c : Products I ‚Üí‚ÇÄ ‚Ñ§) (s : Finset I) : (c.sum fun a_1 b => e (œÄ C fun x => x ‚àà s) a * b ‚Ä¢ Products.eval (œÄ C fun x => x ‚àà s) a_1) ‚àà := by"
  },
  {
    "full_name": "FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1",
    "file_path": "Mathlib/Analysis/Analytic/Inverse.lean",
    "teorema": "theorem FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1 (a : ‚Ñù) (n : ‚Ñï) (p : ‚Ñï ‚Üí ‚Ñù) (r : ‚Ñù) : ‚àë k ‚àà Ico 2 (n + 1), a ^ k * ‚àë c ‚àà {c | 1 < c.length}.toFinset, r ^ c.length * ‚àè j : Fin c.length, p (c.blocksFun j) = ‚àë k ‚àà Ico 2 (n + 1), := by"
  },
  {
    "full_name": "Matrix.det_succ_row_zero",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
    "teorema": "theorem Matrix.det_succ_row_zero (A : Matrix (Fin n.succ) (Fin n.succ) R) (R : Type v) (n : ‚Ñï) : A.det = ‚àë j : Fin n.succ, (-1) ^ ‚Üëj * A 0 j * (A.submatrix Fin.succ j.succAbove).det := by"
  },
  {
    "full_name": "Real.cos_sq_le_one",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "lemma Real.cos_sq_le_one (x : ‚Ñù) : cos x ^ 2 ‚â§ 1 := by"
  },
  {
    "full_name": "Finset.gcd_union",
    "file_path": "Mathlib/Algebra/GCDMonoid/Finset.lean",
    "teorema": "lemma Finset.gcd_union (f : Œ≤ ‚Üí Œ±) (s‚ÇÇ : Finset Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : (‚àÖ ‚à™ s‚ÇÇ).gcd f = GCDMonoid.gcd (‚àÖ.gcd f) (s‚ÇÇ.gcd f) := by"
  },
  {
    "full_name": "Real.sqrt_sq",
    "file_path": "Mathlib/Data/Real/Sqrt.lean",
    "teorema": "lemma Real.sqrt_sq (x : ‚Ñù) : ‚àö(x ^ 2) = x := by"
  },
  {
    "full_name": "Finset.insert_sdiff_cancel",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "theorem Finset.insert_sdiff_cancel (a : Œ±) (s : Finset Œ±) (Œ± : Type u_1) : insert a s \\ s = {a} := by"
  },
  {
    "full_name": "ContMDiff.codRestrict_sphere",
    "file_path": "Mathlib/Geometry/Manifold/Instances/Sphere.lean",
    "teorema": "theorem ContMDiff.codRestrict_sphere (E : Type u_1) (F : Type u_2) (H : Type u_3) (I : ModelWithCorners ‚Ñù F H) (M : Type u_4) (f : M ‚Üí E) (hf : ContMDiff I ùìò(‚Ñù, E) m f) (m : ‚Ñï‚àû) (n : ‚Ñï) : ContMDiff I ùìò(‚Ñù, EuclideanSpace ‚Ñù (Fin n)) m (Set.codRestrict f (sphere 0 1) hf') := by"
  },
  {
    "full_name": "Module.End.IsSemisimple.minpoly_squarefree",
    "file_path": "Mathlib/LinearAlgebra/Semisimple.lean",
    "teorema": "theorem Module.End.IsSemisimple.minpoly_squarefree (K : Type u_3) (M : Type u_2) (f : End K M) : IsRadical (minpoly K f) := by"
  },
  {
    "full_name": "four_functions_theorem",
    "file_path": "Mathlib/Combinatorics/SetFamily/FourFunctions.lean",
    "teorema": "theorem four_functions_theorem (f‚ÇÅ : Œ± ‚Üí Œ≤) (f‚ÇÇ : Œ± ‚Üí Œ≤) (f‚ÇÉ : Œ± ‚Üí Œ≤) (f‚ÇÑ : Œ± ‚Üí Œ≤) (s : Finset Œ±) (t : Finset Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : (‚àë a ‚àà s, f‚ÇÅ a) * ‚àë a ‚àà t, f‚ÇÇ a ‚â§ (‚àë a ‚àà s ‚äº t, f‚ÇÉ a) * ‚àë a ‚àà s ‚äª t, f‚ÇÑ a := by"
  },
  {
    "full_name": "CategoryTheory.GrothendieckTopology.WEqualsLocallyBijective.mk'",
    "file_path": "Mathlib/CategoryTheory/Sites/LocallyBijective.lean",
    "teorema": "theorem CategoryTheory.GrothendieckTopology.WEqualsLocallyBijective.mk' (A : Type u') (C : Type u) (J : GrothendieckTopology C) (P : C·µí·µñ ‚•§ A) (Q : C·µí·µñ ‚•§ A) (f : P ‚ü∂ Q) : J.W f ‚Üî Presheaf.IsLocallyInjective J f ‚àß Presheaf.IsLocallySurjective J f := by"
  },
  {
    "full_name": "LinearMap.BilinForm.isCompl_orthogonal_of_restrict_nondegenerate",
    "file_path": "Mathlib/LinearAlgebra/BilinearForm/Orthogonal.lean",
    "teorema": "theorem LinearMap.BilinForm.isCompl_orthogonal_of_restrict_nondegenerate (B : BilinForm K V) (K : Type u_6) (V : Type u_5) (W : Submodule K V) : IsCompl W (B.orthogonal W) := by"
  },
  {
    "full_name": "WeierstrassCurve.Affine.equation_negAdd",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean",
    "teorema": "theorem WeierstrassCurve.Affine.equation_negAdd (F : Type u) (W : Affine F) (x‚ÇÅ : F) (x‚ÇÇ : F) (y‚ÇÅ : F) (y‚ÇÇ : F) : W.Equation (W.addX x‚ÇÅ x‚ÇÇ (W.slope x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ)) (W.negAddY x‚ÇÅ x‚ÇÇ y‚ÇÅ (W.slope x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ)) := by"
  },
  {
    "full_name": "mul_eq_of_eq_inv_mul‚ÇÄ",
    "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
    "teorema": "lemma mul_eq_of_eq_inv_mul‚ÇÄ (G‚ÇÄ : Type u_3) (a : G‚ÇÄ) (b : G‚ÇÄ) (c : G‚ÇÄ) : a * b = c := by"
  },
  {
    "full_name": "RingHom.rangeS_top_iff_surjective",
    "file_path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
    "teorema": "lemma RingHom.rangeS_top_iff_surjective (R : Type u) (S : Type v) (f : R ‚Üí+* S) : ‚Üëf.rangeS = ‚Üë‚ä§ ‚Üî Set.range ‚áëf = Set.univ := by"
  },
  {
    "full_name": "Real.rpow_add_nat'",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "lemma Real.rpow_add_nat' (n : ‚Ñï) (x : ‚Ñù) (y : ‚Ñù) : x ^ (y + ‚Üën) = x ^ y * x ^ n := by"
  },
  {
    "full_name": "IsPGroup.comap_of_ker_isPGroup",
    "file_path": "Mathlib/GroupTheory/PGroup.lean",
    "teorema": "lemma IsPGroup.comap_of_ker_isPGroup (G : Type u_1) (H : Subgroup G) (K : Type u_2) (p : ‚Ñï) (œï : K ‚Üí* G) : IsPGroup p ‚Ü•(Subgroup.comap œï H) := by"
  },
  {
    "full_name": "Equiv.piCongr'_symm_apply_symm_apply",
    "file_path": "Mathlib/Logic/Equiv/Basic.lean",
    "teorema": "lemma Equiv.piCongr'_symm_apply_symm_apply (W : Œ± ‚Üí Sort w) (Z : Œ≤ ‚Üí Sort z) (b : Œ≤) (f : (b : Œ≤) ‚Üí Z b) (h‚ÇÅ : Œ± ‚âÉ Œ≤) (h‚ÇÇ : (b : Œ≤) ‚Üí W (h‚ÇÅ.symm b) ‚âÉ Z b) (Œ± : Sort u_1) (Œ≤ : Sort u_2) : (h‚ÇÅ.piCongr' h‚ÇÇ).symm f (h‚ÇÅ.symm b) = (h‚ÇÇ b).symm (f b) := by"
  },
  {
    "full_name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop",
    "file_path": "Mathlib/Analysis/Analytic/Composition.lean",
    "teorema": "theorem FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop : Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop := by"
  },
  {
    "full_name": "CategoryTheory.congrArg_mpr_hom_right",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "lemma CategoryTheory.congrArg_mpr_hom_right (C : Type u‚ÇÅ) (X : C) (Y : C) (p : X ‚ü∂ Y) : ‚ãØ.mpr p = p ‚â´ eqToHom ‚ãØ := by"
  },
  {
    "full_name": "Irrational.neg",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "lemma Irrational.neg (x : ‚Ñù) : Irrational (- -x) := by"
  },
  {
    "full_name": "CategoryTheory.shift_shiftFunctorCompIsoId_inv_app",
    "file_path": "Mathlib/CategoryTheory/Shift/Basic.lean",
    "teorema": "lemma CategoryTheory.shift_shiftFunctorCompIsoId_inv_app (A : Type u_1) (m : A) (n : A) : m + n = 0 := by"
  },
  {
    "full_name": "SimpleGraph.Walk.reverseAux_append",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "theorem SimpleGraph.Walk.reverseAux_append (G : SimpleGraph V) (V : Type u) (p : G.Walk u v) (q : G.Walk u w) (r : G.Walk w x) (u : V) (v : V) (w : V) (x : V) : (p.reverseAux q).append r = p.reverseAux (q.append r) := by"
  },
  {
    "full_name": "MeromorphicAt.pow",
    "file_path": "Mathlib/Analysis/Analytic/Meromorphic.lean",
    "teorema": "lemma MeromorphicAt.pow (f : ùïú ‚Üí ùïú) (n : ‚Ñï) (x : ùïú) (ùïú : Type u_1) : MeromorphicAt (f ^ n) x := by"
  },
  {
    "full_name": "Submodule.sup_orthogonal_of_completeSpace",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Projection.lean",
    "teorema": "theorem Submodule.sup_orthogonal_of_completeSpace (E : Type u_2) (K : Submodule ùïú E) (ùïú : Type u_1) : K ‚äî K·óÆ = ‚ä§ := by"
  },
  {
    "full_name": "Rat.cast_div_of_ne_zero",
    "file_path": "Mathlib/Data/Rat/Cast/Defs.lean",
    "teorema": "lemma Rat.cast_div_of_ne_zero (p : ‚Ñö) (q : ‚Ñö) : ‚Üë(p / q) = ‚Üëp / ‚Üëq := by"
  },
  {
    "full_name": "Complex.abs_cpow_of_ne_zero",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "lemma Complex.abs_cpow_of_ne_zero (w : ‚ÑÇ) (z : ‚ÑÇ) : abs (z ^ w) = abs z ^ w.re / rexp (z.arg * w.im) := by"
  },
  {
    "full_name": "AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff",
    "file_path": "Mathlib/Algebra/Order/Rearrangement.lean",
    "teorema": "lemma AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) (s : Finset Œπ) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œπ : Type u_1) (œÉ : Perm Œπ) : ‚àë i ‚àà s, f i ‚Ä¢ g i < ‚àë i ‚àà s, f i ‚Ä¢ g (œÉ i) ‚Üî ¬¨AntivaryOn f (g ‚àò ‚áëœÉ) ‚Üës := by"
  },
  {
    "full_name": "CategoryTheory.CatCommSq.hInv_hInv",
    "file_path": "Mathlib/CategoryTheory/CatCommSq.lean",
    "teorema": "theorem CategoryTheory.CatCommSq.hInv_hInv (B : C‚ÇÉ ‚âå C‚ÇÑ) (C‚ÇÅ : Type u_1) (C‚ÇÇ : Type u_2) (C‚ÇÉ : Type u_3) (C‚ÇÑ : Type u_4) (L : C‚ÇÅ ‚•§ C‚ÇÉ) (R : C‚ÇÇ ‚•§ C‚ÇÑ) (T : C‚ÇÅ ‚âå C‚ÇÇ) (h : CatCommSq T.functor L R B.functor) : hInv T.symm R L B.symm (hInv T L R B h) = h := by"
  },
  {
    "full_name": "Matrix.charmatrix_apply_natDegree",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean",
    "teorema": "theorem Matrix.charmatrix_apply_natDegree (M : Matrix n n R) (R : Type u) (i : n) (j : n) (n : Type v) : (M.charmatrix i j).natDegree = if i = j then 1 else 0 := by"
  },
  {
    "full_name": "ModelWithCorners.extChartAt_transDiffeomorph_target",
    "file_path": "Mathlib/Geometry/Manifold/Diffeomorph.lean",
    "teorema": "theorem ModelWithCorners.extChartAt_transDiffeomorph_target (E : Type u_2) (H : Type u_5) (I : ModelWithCorners ùïú E H) (M : Type u_9) (e : E ‚âÉ‚Çò‚üÆùìò(ùïú, E), ùìò(ùïú, E')‚üØ E') (x : M) (ùïú : Type u_1) : (extChartAt (I.transDiffeomorph e) x).target = ‚áëe.symm ‚Åª¬π' (extChartAt I x).target := by"
  },
  {
    "full_name": "MeasureTheory.Measure.measurePreserving_div_left",
    "file_path": "Mathlib/MeasureTheory/Group/Measure.lean",
    "teorema": "lemma MeasureTheory.Measure.measurePreserving_div_left (G : Type u_2) (g : G) (Œº : Measure G) : MeasurePreserving (fun t => g / t) Œº Œº := by"
  },
  {
    "full_name": "CochainComplex.HomComplex.Cochain.congr_v",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean",
    "teorema": "lemma CochainComplex.HomComplex.Cochain.congr_v (C : Type u) (F : CochainComplex C ‚Ñ§) (G : CochainComplex C ‚Ñ§) (hpq : p + n = q) (n : ‚Ñ§) (p : ‚Ñ§) (q : ‚Ñ§) (z‚ÇÅ : Cochain F G n) (z‚ÇÇ : Cochain F G n) : z‚ÇÅ.v p q hpq = z‚ÇÇ.v p q hpq := by"
  },
  {
    "full_name": "IsClosed.vadd_right_of_isCompact",
    "file_path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean",
    "teorema": "theorem IsClosed.vadd_right_of_isCompact (P : Type u_3) (V : Type u_2) (s : Set V) (t : Set P) : IsClosed (s +·µ• t) := by"
  },
  {
    "full_name": "geom_sum_eq",
    "file_path": "Mathlib/Algebra/GeomSum.lean",
    "teorema": "lemma geom_sum_eq (n : ‚Ñï) (x : Œ±) (Œ± : Type u) : ‚àë i ‚àà range n, x ^ i = (x ^ n - 1) / (x - 1) := by"
  },
  {
    "full_name": "iteratedDerivWithin_sub",
    "file_path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
    "teorema": "theorem iteratedDerivWithin_sub (F : Type u_2) (f : ùïú ‚Üí F) (g : ùïú ‚Üí F) (n : ‚Ñï) (s : Set ùïú) (x : ùïú) (ùïú : Type u_1) : iteratedDerivWithin n (f - g) s x = iteratedDerivWithin n f s x - iteratedDerivWithin n g s x := by"
  },
  {
    "full_name": "PartialHomeomorph.map_extend_symm_nhdsWithin_range",
    "file_path": "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean",
    "teorema": "lemma PartialHomeomorph.map_extend_symm_nhdsWithin_range (E : Type u_2) (H : Type u_4) (I : ModelWithCorners ùïú E H) (M : Type u_3) (f : PartialHomeomorph M H) (y : M) (ùïú : Type u_1) : map (‚Üë(f.extend I).symm) (ùìù[range ‚ÜëI] ‚Üë(f.extend I) y) = ùìù y := by"
  },
  {
    "full_name": "CategoryTheory.factorThruImage_comp_imageUnopOp_inv",
    "file_path": "Mathlib/CategoryTheory/Abelian/Opposite.lean",
    "teorema": "theorem CategoryTheory.factorThruImage_comp_imageUnopOp_inv (A : C·µí·µñ) (B : C·µí·µñ) (g : A ‚ü∂ B) : factorThruImage g ‚â´ (imageUnopOp g).inv = (image.Œπ g.unop).op := by"
  },
  {
    "full_name": "affineIndependent_equiv",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean",
    "teorema": "theorem affineIndependent_equiv (P : Type u_3) (e : Œπ ‚âÉ Œπ') (k : Type u_1) (p : Œπ' ‚Üí P) (Œπ : Type u_4) : AffineIndependent k (p ‚àò ‚áëe) ‚Üî AffineIndependent k p := by"
  },
  {
    "full_name": "List.Ico.eq_nil_of_le",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "teorema": "lemma List.Ico.eq_nil_of_le (m : ‚Ñï) (n : ‚Ñï) : Ico n m = [] := by"
  },
  {
    "full_name": "Polynomial.natSepDegree_X",
    "file_path": "Mathlib/FieldTheory/SeparableDegree.lean",
    "teorema": "lemma Polynomial.natSepDegree_X : X.natSepDegree = 1 := by"
  },
  {
    "full_name": "Polynomial.isUnit_of_self_mul_dvd_separable",
    "file_path": "Mathlib/FieldTheory/Separable.lean",
    "teorema": "lemma Polynomial.isUnit_of_self_mul_dvd_separable (R : Type u) (q : R[X]) : IsUnit q := by"
  },
  {
    "full_name": "Disjoint.le_of_codisjoint",
    "file_path": "Mathlib/Order/Disjoint.lean",
    "teorema": "lemma Disjoint.le_of_codisjoint (a : Œ±) (c : Œ±) (Œ± : Type u_1) : a ‚â§ c := by"
  },
  {
    "full_name": "MvPolynomial.totalDegree_finset_prod",
    "file_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
    "teorema": "lemma MvPolynomial.totalDegree_finset_prod (R : Type u) (f : Œπ ‚Üí MvPolynomial œÉ R) (s : Finset Œπ) (Œπ : Type u_3) (œÉ : Type u_1) : (s.prod f).totalDegree ‚â§ ‚àë i ‚àà s, (f i).totalDegree := by"
  },
  {
    "full_name": "Set.directedOn_iUnion",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "theorem Set.directedOn_iUnion (f : Œπ ‚Üí Set Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) (Œπ : Sort u_4) : DirectedOn r (‚ãÉ x, f x) := by"
  },
  {
    "full_name": "CategoryTheory.ShortComplex.HomologyMapData.congr_left_œÜH",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/Homology.lean",
    "teorema": "lemma CategoryTheory.ShortComplex.HomologyMapData.congr_left_œÜH (C : Type u) (S‚ÇÅ : ShortComplex C) (S‚ÇÇ : ShortComplex C) (h‚ÇÅ : S‚ÇÅ.HomologyData) (h‚ÇÇ : S‚ÇÇ.HomologyData) (Œ≥‚ÇÅ : HomologyMapData œÜ h‚ÇÅ h‚ÇÇ) (Œ≥‚ÇÇ : HomologyMapData œÜ h‚ÇÅ h‚ÇÇ) (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) : Œ≥‚ÇÅ.left.œÜH = Œ≥‚ÇÇ.left.œÜH := by"
  },
  {
    "full_name": "TrivSqZeroExt.hasSum_expSeries_of_smul_comm",
    "file_path": "Mathlib/Analysis/NormedSpace/TrivSqZeroExt.lean",
    "teorema": "lemma TrivSqZeroExt.hasSum_expSeries_of_smul_comm (M : Type u_4) (R : Type u_3) (e : R) (x : tsze R M) (ùïú : Type u_1) : HasSum (fun n => (expSeries ùïú (tsze R M) n) fun x_1 => x) (inl e + inr (e ‚Ä¢ x.snd)) := by"
  },
  {
    "full_name": "one_lt_finprod'",
    "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean",
    "teorema": "theorem one_lt_finprod' (M : Type u_7) (f : Œπ ‚Üí M) (Œπ : Type u_3) : 1 < ‚àè·∂† (i : Œπ), f i := by"
  },
  {
    "full_name": "Seminorm.closedBall_smul_closedBall",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "lemma Seminorm.closedBall_smul_closedBall (E : Type u_7) (p : Seminorm ùïú E) (r‚ÇÅ : ‚Ñù) (r‚ÇÇ : ‚Ñù) (ùïú : Type u_3) : Metric.closedBall 0 r‚ÇÅ ‚Ä¢ p.closedBall 0 r‚ÇÇ ‚äÜ p.closedBall 0 (r‚ÇÅ * r‚ÇÇ) := by"
  },
  {
    "full_name": "Mon_.Mon_tensor_one_mul",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Mon_.lean",
    "teorema": "theorem Mon_.Mon_tensor_one_mul (C : Type u‚ÇÅ) (M : Mon_ C) (N : Mon_ C) : ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one)) ‚ñ∑ (M.X ‚äó N.X) ‚â´ tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul) = (Œª_ (M.X ‚äó N.X)).hom := by"
  },
  {
    "full_name": "Int.toNat_add_toNat_neg_eq_nnnorm",
    "file_path": "Mathlib/Analysis/NormedSpace/Int.lean",
    "teorema": "lemma Int.toNat_add_toNat_neg_eq_nnnorm (n : ‚Ñ§) : ‚Üën.toNat + ‚Üë(-n).toNat = ‚Äñn‚Äñ‚Çä := by"
  },
  {
    "full_name": "Sym2.out_snd_mem",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "teorema": "lemma Sym2.out_snd_mem (e : Sym2 Œ±) (Œ± : Type u_1) : e = s((Quot.out e).2, (Quot.out e).1) := by"
  },
  {
    "full_name": "AlgebraicGeometry.Spec.map_eqToHom",
    "file_path": "Mathlib/AlgebraicGeometry/Scheme.lean",
    "teorema": "lemma AlgebraicGeometry.Spec.map_eqToHom (R : CommRingCat) (S : CommRingCat) (e : R = S) : map (eqToHom e) = eqToHom ‚ãØ := by"
  },
  {
    "full_name": "Complex.isTheta_cpow_rpow",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean",
    "teorema": "lemma Complex.isTheta_cpow_rpow (f : Œ± ‚Üí ‚ÑÇ) (g : Œ± ‚Üí ‚ÑÇ) (l : Filter Œ±) (Œ± : Type u_1) : (let_fun this := fun x => abs (f x) ^ (g x).re / 1; this) =·∂†[l] := by"
  },
  {
    "full_name": "MeasurableEmbedding.absolutelyContinuous_map",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
    "teorema": "lemma MeasurableEmbedding.absolutelyContinuous_map (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) (ŒΩ : Measure Œ±) : Measure.map f Œº ‚â™ Measure.map f ŒΩ := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.sup_apply",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/Operations.lean",
    "teorema": "theorem MeasureTheory.OuterMeasure.sup_apply (m‚ÇÅ : OuterMeasure Œ±) (m‚ÇÇ : OuterMeasure Œ±) (s : Set Œ±) (Œ± : Type u_1) : (m‚ÇÅ ‚äî m‚ÇÇ) s = m‚ÇÅ s ‚äî m‚ÇÇ s := by"
  },
  {
    "full_name": "LieModuleEquiv.symm_symm",
    "file_path": "Mathlib/Algebra/Lie/Basic.lean",
    "teorema": "lemma LieModuleEquiv.symm_symm (L : Type v) (M : Type w) (N : Type w‚ÇÅ) (R : Type u) (e : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) : e.symm.symm = e := by"
  },
  {
    "full_name": "LinearMap.polyCharpolyAux_map_eq_charpoly",
    "file_path": "Mathlib/Algebra/Module/LinearMap/Polynomial.lean",
    "teorema": "theorem LinearMap.polyCharpolyAux_map_eq_charpoly (L : Type u_2) (M : Type u_3) (R : Type u_1) (b : Basis Œπ R L) (b‚Çò : Basis ŒπM R M) (x : L) (Œπ : Type u_5) (ŒπM : Type u_7) (œÜ : L ‚Üí‚Çó[R] Module.End R M) : Polynomial.map (MvPolynomial.eval ‚áë(b.repr x)) (œÜ.polyCharpolyAux b b‚Çò) = charpoly (œÜ x) := by"
  },
  {
    "full_name": "Fin.castOrderIso_toEquiv",
    "file_path": "Mathlib/Order/Fin.lean",
    "teorema": "lemma Fin.castOrderIso_toEquiv (h : n = m) (m : ‚Ñï) (n : ‚Ñï) : (castOrderIso h).toEquiv = Equiv.cast ‚ãØ := by"
  },
  {
    "full_name": "MeasurableSpace.generateFrom_iUnion_countablePartition",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
    "teorema": "lemma MeasurableSpace.generateFrom_iUnion_countablePartition (m : MeasurableSpace Œ±) (Œ± : Type u_3) : generateFrom (‚ãÉ n, countablePartition Œ± n) = m := by"
  },
  {
    "full_name": "IsLUB.exists_seq_monotone_tendsto",
    "file_path": "Mathlib/Topology/Order/IsLUB.lean",
    "teorema": "theorem IsLUB.exists_seq_monotone_tendsto (t : Set Œ±) (x : Œ±) (Œ± : Type u_1) : ‚àÉ u, Monotone u ‚àß (‚àÄ (n : ‚Ñï), u n ‚â§ x) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ (n : ‚Ñï), u n ‚àà t := by"
  },
  {
    "full_name": "integral_exp_neg_mul_rpow",
    "file_path": "Mathlib/MeasureTheory/Integral/Gamma.lean",
    "teorema": "lemma integral_exp_neg_mul_rpow (b : ‚Ñù) (p : ‚Ñù) : ‚à´ (x : ‚Ñù) in Ioi 0, rexp (-b * x ^ p) = b ^ (-1 / p) * Gamma (1 / p + 1) := by"
  },
  {
    "full_name": "AlgebraCat.forget‚ÇÇ_map_associator_hom",
    "file_path": "Mathlib/Algebra/Category/AlgebraCat/Monoidal.lean",
    "teorema": "lemma AlgebraCat.forget‚ÇÇ_map_associator_hom (R : Type u) (X : AlgebraCat R) (Y : AlgebraCat R) (Z : AlgebraCat R) : (forget‚ÇÇ (AlgebraCat R) (ModuleCat R)).map (Œ±_ X Y Z).hom = (Œ±_ ((forget‚ÇÇ (AlgebraCat R) (ModuleCat R)).obj X) ((forget‚ÇÇ (AlgebraCat R) (ModuleCat R)).obj Y) ((forget‚ÇÇ (AlgebraCat R) (ModuleCat R)).obj Z)).hom := by"
  },
  {
    "full_name": "CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_right",
    "file_path": "Mathlib/CategoryTheory/LiftingProperties/Basic.lean",
    "teorema": "lemma CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_right (A : C) (B : C) (C : Type u_1) (X : C) (Y : C) (i : A ‚ü∂ B) (p : X ‚ü∂ Y) : HasLiftingProperty i p ‚Üî HasLiftingProperty i p' := by"
  },
  {
    "full_name": "SimpleGraph.singletonSubgraph_le_iff",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean",
    "teorema": "theorem SimpleGraph.singletonSubgraph_le_iff (G : SimpleGraph V) (H : G.Subgraph) (V : Type u) (v : V) : G.singletonSubgraph v ‚â§ H ‚Üî v ‚àà H.verts := by"
  },
  {
    "full_name": "Multiset.le_iff_count",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.le_iff_count (s : Multiset Œ±) (t : Multiset Œ±) (Œ± : Type u_1) : s ‚â§ t := by"
  },
  {
    "full_name": "PowerSeries.coeff_def",
    "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
    "teorema": "lemma PowerSeries.coeff_def (R : Type u_1) (n : ‚Ñï) (s : Unit ‚Üí‚ÇÄ ‚Ñï) : coeff R n = MvPowerSeries.coeff R s := by"
  },
  {
    "full_name": "strictMonoOn_dual_iff",
    "file_path": "Mathlib/Order/Monotone/Basic.lean",
    "teorema": "lemma strictMonoOn_dual_iff (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (Œ± : Type u) (Œ≤ : Type v) : StrictMonoOn (‚áëtoDual ‚àò f ‚àò ‚áëofDual) s ‚Üî StrictMonoOn f s := by"
  },
  {
    "full_name": "Mathlib.Tactic.Abel.term_smul",
    "file_path": "Mathlib/Tactic/Abel.lean",
    "teorema": "theorem Mathlib.Tactic.Abel.term_smul (a : Œ±) (c : ‚Ñï) (n : ‚Ñï) (x : Œ±) (Œ± : Type u_1) : smul c (term n x a) = term n' x a' := by"
  },
  {
    "full_name": "FiberBundle.totalSpaceMk_closedEmbedding",
    "file_path": "Mathlib/Topology/FiberBundle/Basic.lean",
    "teorema": "theorem FiberBundle.totalSpaceMk_closedEmbedding (B : Type u_2) (x : B) : IsClosed (range (TotalSpace.mk x)) := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.negAddY_eq",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "theorem WeierstrassCurve.Jacobian.negAddY_eq (F : Type v) (P : Fin 3 ‚Üí F) (Q : Fin 3 ‚Üí F) (W : Jacobian F) : W.negAddY P Q = ((P y * Q z ^ 3 - Q y * P z ^ 3) * (W.addX P Q * (P z * Q z) ^ 2 - P x * Q z ^ 2 * addZ P Q ^ 2) + P y * Q z ^ 3 * addZ P Q ^ 3) / (P z * Q z) ^ 3 := by"
  },
  {
    "full_name": "SimpleGraph.cliqueFree_iff",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "teorema": "theorem SimpleGraph.cliqueFree_iff (G : SimpleGraph Œ±) (n : ‚Ñï) (Œ± : Type u_1) : G.CliqueFree n ‚Üî IsEmpty (‚ä§ ‚Ü™g G) := by"
  },
  {
    "full_name": "CategoryTheory.Presieve.isSheafFor_iff_generate",
    "file_path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
    "teorema": "lemma CategoryTheory.Presieve.isSheafFor_iff_generate (C : Type u‚ÇÅ) (P : C·µí·µñ ‚•§ Type w) (R : Presieve X) (X : C) : IsSheafFor P R ‚Üî IsSheafFor P (generate R).arrows := by"
  },
  {
    "full_name": "Finset.preimage_compl",
    "file_path": "Mathlib/Data/Finset/Preimage.lean",
    "teorema": "theorem Finset.preimage_compl (f : Œ± ‚Üí Œ≤) (s : Finset Œ≤) (Œ± : Type u) (Œ≤ : Type v) : ‚Üë(s·∂ú.preimage f ‚ãØ) = ‚Üë(s.preimage f ‚ãØ)·∂ú := by"
  },
  {
    "full_name": "AlgebraicGeometry.isOpenImmersion_isLocalAtTarget",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/OpenImmersion.lean",
    "teorema": "theorem AlgebraicGeometry.isOpenImmersion_isLocalAtTarget : PropertyIsLocalAtTarget @IsOpenImmersion := by"
  },
  {
    "full_name": "MeasureTheory.compl_mem_measurableCylinders",
    "file_path": "Mathlib/MeasureTheory/Constructions/Cylinders.lean",
    "teorema": "lemma MeasureTheory.compl_mem_measurableCylinders (Œ± : Œπ ‚Üí Type u_2) (Œπ : Type u_1) : s·∂ú ‚àà measurableCylinders Œ± := by"
  },
  {
    "full_name": "IsLocalMaxOn.hasFDerivWithinAt_nonpos",
    "file_path": "Mathlib/Analysis/Calculus/LocalExtr/Basic.lean",
    "teorema": "lemma IsLocalMaxOn.hasFDerivWithinAt_nonpos (E : Type u) (f : E ‚Üí ‚Ñù) (y : E) : f' y ‚â§ 0 := by"
  },
  {
    "full_name": "CategoryTheory.ProjectiveResolution.œÄ_f_succ",
    "file_path": "Mathlib/CategoryTheory/Preadditive/ProjectiveResolution.lean",
    "teorema": "lemma CategoryTheory.ProjectiveResolution.œÄ_f_succ (n : ‚Ñï) : n + 1 ‚â† 0 := by"
  },
  {
    "full_name": "VectorFourier.fourierIntegral_comp_add_right",
    "file_path": "Mathlib/Analysis/Fourier/FourierTransform.lean",
    "teorema": "lemma VectorFourier.fourierIntegral_comp_add_right (E : Type u_4) (L : V ‚Üí‚Çó[ùïú] W ‚Üí‚Çó[ùïú] ùïú) (V : Type u_2) (W : Type u_3) (e : AddChar ùïú ‚Ü•ùïä) (f : V ‚Üí E) (v‚ÇÄ : V) (Œº : Measure V) (ùïú : Type u_1) : fourierIntegral e Œº L (f ‚àò fun v => v + v‚ÇÄ) = fun w => e ((L v‚ÇÄ) w) ‚Ä¢ fourierIntegral e Œº L f w := by"
  },
  {
    "full_name": "ArithmeticFunction.pmul_assoc",
    "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean",
    "teorema": "theorem ArithmeticFunction.pmul_assoc (R : Type u_1) (f‚ÇÅ : ArithmeticFunction R) (f‚ÇÇ : ArithmeticFunction R) (f‚ÇÉ : ArithmeticFunction R) : (f‚ÇÅ.pmul f‚ÇÇ).pmul f‚ÇÉ = f‚ÇÅ.pmul (f‚ÇÇ.pmul f‚ÇÉ) := by"
  },
  {
    "full_name": "HomologicalComplex.opcyclesToCycles_iCycles",
    "file_path": "Mathlib/Algebra/Homology/HomologySequence.lean",
    "teorema": "theorem HomologicalComplex.opcyclesToCycles_iCycles (C : Type u_1) (K : HomologicalComplex C c) (c : ComplexShape Œπ) (i : Œπ) (j : Œπ) (Œπ : Type u_2) : K.opcyclesToCycles i j ‚â´ K.iCycles j = K.fromOpcycles i j := by"
  },
  {
    "full_name": "UniformInducing.cauchy_map_iff",
    "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean",
    "teorema": "theorem UniformInducing.cauchy_map_iff (F : Filter Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u) (Œ≤ : Type v) : Cauchy (map f F) ‚Üî Cauchy F := by"
  },
  {
    "full_name": "ZNum.bit1_of_bit1",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "theorem ZNum.bit1_of_bit1 (a : PosNum) : sub' 1 (_root_.bit0 a) = (neg a).bit1 := by"
  },
  {
    "full_name": "monic_descPochhammer",
    "file_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
    "teorema": "lemma monic_descPochhammer (R : Type u) (n : ‚Ñï) : (descPochhammer R n).Monic := by"
  },
  {
    "full_name": "HasStrictFDerivAt.approximates_deriv_on_nhds",
    "file_path": "Mathlib/Analysis/Calculus/InverseFunctionTheorem/FDeriv.lean",
    "teorema": "theorem HasStrictFDerivAt.approximates_deriv_on_nhds (E : Type u_2) (F : Type u_3) (a : E) (c : ‚Ñù‚â•0) (f : E ‚Üí F) : ‚àÉ s ‚àà ùìù a, ApproximatesLinearOn f f' s c := by"
  },
  {
    "full_name": "isLocalStructomorphOn_contDiffGroupoid_iff",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Atlas.lean",
    "teorema": "theorem isLocalStructomorphOn_contDiffGroupoid_iff (E : Type u_2) (H : Type u_3) (I : ModelWithCorners ùïú E H) (M : Type u_4) (f : PartialHomeomorph M M') (ùïú : Type u_1) : LiftPropOn (contDiffGroupoid ‚ä§ I).IsLocalStructomorphWithinAt (‚Üëf) f.source ‚Üî SmoothOn I I (‚Üëf) f.source ‚àß SmoothOn I I (‚Üëf.symm) f.target := by"
  },
  {
    "full_name": "Nat.ceil_eq_zero",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Nat.ceil_eq_zero (a : Œ±) (Œ± : Type u_2) : ‚åàa‚åâ‚Çä = 0 ‚Üî a ‚â§ 0 := by"
  },
  {
    "full_name": "pow_two",
    "file_path": "Mathlib/Algebra/Group/Defs.lean",
    "teorema": "lemma pow_two (M : Type u_2) (a : M) : a ^ 2 = a * a := by"
  },
  {
    "full_name": "smul_ceilDiv",
    "file_path": "Mathlib/Algebra/Order/Floor/Div.lean",
    "teorema": "lemma smul_ceilDiv (a : Œ±) (b : Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : ‚àÄ (c : Œ≤), a ‚Ä¢ b ‚åà/‚åâ a ‚â§ c ‚Üî b ‚â§ c := by"
  },
  {
    "full_name": "Ideal.IsHomogeneous.sSup",
    "file_path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean",
    "teorema": "lemma Ideal.IsHomogeneous.sSup (A : Type u_4) (Œπ : Type u_1) (œÉ : Type u_2) (‚Ñê : Set (Ideal A)) (ùíú : Œπ ‚Üí œÉ) : IsHomogeneous ùíú (SupSet.sSup ‚Ñê) := by"
  },
  {
    "full_name": "LieAlgebra.IsKilling.eq_neg_or_eq_of_eq_smul",
    "file_path": "Mathlib/Algebra/Lie/Weights/RootSystem.lean",
    "teorema": "lemma LieAlgebra.IsKilling.eq_neg_or_eq_of_eq_smul (H : LieSubalgebra K L) (K : Type u_1) (L : Type u_2) (Œ± : Weight K (‚Ü•H) L) (Œ≤ : Weight K (‚Ü•H) L) : Œ≤ = -Œ± ‚à® Œ≤ = Œ± := by"
  },
  {
    "full_name": "MeasureTheory.measure_union_lt_top_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean",
    "teorema": "lemma MeasureTheory.measure_union_lt_top_iff (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº (s ‚à™ t) < ‚ä§ ‚Üî Œº s < ‚ä§ ‚àß Œº t < ‚ä§ := by"
  },
  {
    "full_name": "IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ",
    "file_path": "Mathlib/Topology/Order/IntermediateValue.lean",
    "teorema": "lemma IsPreconnected.intermediate_value‚ÇÇ_eventually‚ÇÇ (X : Type u) (f : X ‚Üí Œ±) (g : X ‚Üí Œ±) (s : Set X) (Œ± : Type v) : ‚àÉ x ‚àà s, f x = g x := by"
  },
  {
    "full_name": "Nat.gcd_add_self_left",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "teorema": "lemma Nat.gcd_add_self_left (m : ‚Ñï) (n : ‚Ñï) : (m + n).gcd n = m.gcd n := by"
  },
  {
    "full_name": "List.mem_zip_inits_tails",
    "file_path": "Mathlib/Data/List/Zip.lean",
    "teorema": "lemma List.mem_zip_inits_tails (init : List Œ±) (l : List Œ±) (tail : List Œ±) (Œ± : Type u) : (init, tail) ‚àà l.inits.zip l.tails ‚Üî init ++ tail = l := by"
  },
  {
    "full_name": "Turing.PartrecToTM2.supports_singleton",
    "file_path": "Mathlib/Computability/TMToPartrec.lean",
    "teorema": "theorem Turing.PartrecToTM2.supports_singleton (S : Finset Œõ') (q : Œõ') : Supports {q} S ‚Üî TM2.SupportsStmt S (tr q) := by"
  },
  {
    "full_name": "LiouvilleWith.int_sub_iff",
    "file_path": "Mathlib/NumberTheory/Liouville/LiouvilleWith.lean",
    "teorema": "theorem LiouvilleWith.int_sub_iff (m : ‚Ñ§) (p : ‚Ñù) (x : ‚Ñù) : LiouvilleWith p (‚Üëm - x) ‚Üî LiouvilleWith p x := by"
  },
  {
    "full_name": "Ideal.irreducible_of_irreducible_absNorm",
    "file_path": "Mathlib/RingTheory/Ideal/Norm.lean",
    "teorema": "lemma Ideal.irreducible_of_irreducible_absNorm (I : Ideal S) (S : Type u_1) : IsUnit (absNorm I) := by"
  },
  {
    "full_name": "vectorSpan_insert_eq_vectorSpan",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "theorem vectorSpan_insert_eq_vectorSpan (P : Type u_3) (k : Type u_1) (p : P) (ps : Set P) : vectorSpan k (insert p ps) = vectorSpan k ps := by"
  },
  {
    "full_name": "LinearMap.injective_domRestrict_iff",
    "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean",
    "teorema": "lemma LinearMap.injective_domRestrict_iff (M : Type u_6) (M‚ÇÇ : Type u_8) (R : Type u_1) (R‚ÇÇ : Type u_3) (S : Submodule R M) (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) : Injective ‚áë(f.domRestrict S) ‚Üî S ‚äì ker f = ‚ä• := by"
  },
  {
    "full_name": "C_p_pow_dvd_bind‚ÇÅ_rename_wittPolynomial_sub_sum",
    "file_path": "Mathlib/RingTheory/WittVector/StructurePolynomial.lean",
    "teorema": "lemma C_p_pow_dvd_bind‚ÇÅ_rename_wittPolynomial_sub_sum (idx : Type u_2) (n : ‚Ñï) (p : ‚Ñï) (Œ¶ : MvPolynomial idx ‚Ñ§) : C ‚Üë(p ^ n) ‚à£ (bind‚ÇÅ fun b => (rename fun i => (b, i)) (W_ ‚Ñ§ n)) Œ¶ - ‚àë i ‚àà Finset.range n, C (‚Üëp ^ i) * wittStructureInt p Œ¶ i ^ p ^ (n - i) := by"
  },
  {
    "full_name": "SetTheory.PGame.Impartial.nonneg",
    "file_path": "Mathlib/SetTheory/Game/Impartial.lean",
    "teorema": "lemma SetTheory.PGame.Impartial.nonneg : False := by"
  },
  {
    "full_name": "NNReal.ball_zero_eq_Ico'",
    "file_path": "Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean",
    "teorema": "theorem NNReal.ball_zero_eq_Ico' (c : ‚Ñù‚â•0) : ball 0 ‚Üëc = Ico 0 c := by"
  },
  {
    "full_name": "ContDiffOn.comp",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma ContDiffOn.comp (E : Type uE) (F : Type uF) (G : Type uG) (f : E ‚Üí F) (g : F ‚Üí G) (n : ‚Ñï‚àû) (s : Set E) (ùïú : Type u_1) : ContDiffOn ùïú n (g ‚àò f) s := by"
  },
  {
    "full_name": "ProbabilityTheory.mgf_undef",
    "file_path": "Mathlib/Probability/Moments.lean",
    "teorema": "theorem ProbabilityTheory.mgf_undef (X : Œ© ‚Üí ‚Ñù) (t : ‚Ñù) (Œ© : Type u_1) (Œº : Measure Œ©) : mgf X Œº t = 0 := by"
  },
  {
    "full_name": "Embedding.map_nhdsWithin_eq",
    "file_path": "Mathlib/Topology/ContinuousOn.lean",
    "teorema": "theorem Embedding.map_nhdsWithin_eq (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (x : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : map f (ùìù[s] x) = ùìù[f '' s] f x := by"
  },
  {
    "full_name": "Polynomial.ker_mapRingHom",
    "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean",
    "teorema": "lemma Polynomial.ker_mapRingHom (R : Type u) (S : Type u_1) (f : R ‚Üí+* S) : LinearMap.ker (mapRingHom f).toSemilinearMap = map C (RingHom.ker f) := by"
  },
  {
    "full_name": "Seminorm.neg_ball",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "lemma Seminorm.neg_ball (E : Type u_7) (p : Seminorm ùïú E) (r : ‚Ñù) (x : E) (ùïú : Type u_3) : -p.ball x r = p.ball (-x) r := by"
  },
  {
    "full_name": "Finset.sigmaLift_nonempty",
    "file_path": "Mathlib/Data/Finset/Sigma.lean",
    "teorema": "theorem Finset.sigmaLift_nonempty (a : (i : Œπ) √ó Œ± i) (b : (i : Œπ) √ó Œ≤ i) (f : ‚¶Éi : Œπ‚¶Ñ ‚Üí Œ± i ‚Üí Œ≤ i ‚Üí Finset (Œ≥ i)) (Œ± : Œπ ‚Üí Type u_2) (Œ≤ : Œπ ‚Üí Type u_3) (Œ≥ : Œπ ‚Üí Type u_4) (Œπ : Type u_1) : (sigmaLift f a b).Nonempty ‚Üî ‚àÉ (h : a.fst = b.fst), (f (h ‚ñ∏ a.snd) b.snd).Nonempty := by"
  },
  {
    "full_name": "Affine.Simplex.circumsphere_reindex",
    "file_path": "Mathlib/Geometry/Euclidean/Circumcenter.lean",
    "teorema": "lemma Affine.Simplex.circumsphere_reindex (P : Type u_2) (e : Fin (m + 1) ‚âÉ Fin (n + 1)) (m : ‚Ñï) (n : ‚Ñï) (s : Simplex ‚Ñù P m) : (s.reindex e).circumsphere = s.circumsphere := by"
  },
  {
    "full_name": "Pi.basisFun_repr",
    "file_path": "Mathlib/LinearAlgebra/StdBasis.lean",
    "teorema": "lemma Pi.basisFun_repr (R : Type u_1) (i : Œ∑) (x : Œ∑ ‚Üí R) (Œ∑ : Type u_2) : ((basisFun R Œ∑).repr x) i = x i := by"
  },
  {
    "full_name": "Set.projIic_eq_self",
    "file_path": "Mathlib/Order/Interval/Set/ProjIcc.lean",
    "teorema": "lemma Set.projIic_eq_self (b : Œ±) (x : Œ±) (Œ± : Type u_1) : projIic b x = ‚ü®b, ‚ãØ‚ü© ‚Üî b ‚â§ x := by"
  },
  {
    "full_name": "MeasureTheory.SimpleFunc.nnnorm_approxOn_le",
    "file_path": "Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean",
    "teorema": "theorem MeasureTheory.SimpleFunc.nnnorm_approxOn_le (E : Type u_4) (f : Œ≤ ‚Üí E) (hf : Measurable f) (h‚ÇÄ : y‚ÇÄ ‚àà s) (n : ‚Ñï) (s : Set E) (x : Œ≤) (y‚ÇÄ : E) (Œ≤ : Type u_2) : ‚Äñ‚Üë(approxOn f hf s y‚ÇÄ h‚ÇÄ n) x - f x‚Äñ‚Çä ‚â§ ‚Äñf x - y‚ÇÄ‚Äñ‚Çä := by"
  },
  {
    "full_name": "Multiset.rel_refl_of_refl_on",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.rel_refl_of_refl_on (m : Multiset Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : (‚àÄ x ‚àà m, r x x) ‚Üí Rel r m m := by"
  },
  {
    "full_name": "Real.cos_pi_div_four",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
    "teorema": "lemma Real.cos_pi_div_four : cos (œÄ / 4) = ‚àö2 / 2 := by"
  },
  {
    "full_name": "zero_le_two",
    "file_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean",
    "teorema": "theorem zero_le_two : 0 ‚â§ 2 := by"
  },
  {
    "full_name": "UpperHalfPlane.im_inv_neg_coe_pos",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
    "teorema": "theorem UpperHalfPlane.im_inv_neg_coe_pos (z : ‚Ñç) : 0 < (-‚Üëz)‚Åª¬π.im := by"
  },
  {
    "full_name": "LieDerivation.coe_ad_apply_eq_ad_apply",
    "file_path": "Mathlib/Algebra/Lie/Derivation/AdjointAction.lean",
    "teorema": "lemma LieDerivation.coe_ad_apply_eq_ad_apply (L : Type u_2) (R : Type u_1) (x : L) : ‚Üë((ad R L) x) = (LieAlgebra.ad R L) x := by"
  },
  {
    "full_name": "newton_seq_dist",
    "file_path": "Mathlib/NumberTheory/Padics/Hensel.lean",
    "teorema": "lemma newton_seq_dist (F : Polynomial ‚Ñ§_[p]) (a : ‚Ñ§_[p]) (k : ‚Ñï) (n : ‚Ñï) (p : ‚Ñï) : ‚Äñnewton_seq k - newton_seq n‚Äñ ‚â§ ‚ÄñPolynomial.eval a (Polynomial.derivative F)‚Äñ * T_gen p F a ^ 2 ^ n := by"
  },
  {
    "full_name": "CategoryTheory.EffectiveEpiFamily.transitive_of_finite",
    "file_path": "Mathlib/CategoryTheory/Sites/Coherent/CoherentTopology.lean",
    "teorema": "theorem CategoryTheory.EffectiveEpiFamily.transitive_of_finite (C : Type u_1) (X : C) (Y : Œ± ‚Üí C) (Y_n : (a : Œ±) ‚Üí Œ≤ a ‚Üí C) (Œ± : Type) (Œ≤ : Œ± ‚Üí Type) (œÄ : (a : Œ±) ‚Üí Y a ‚ü∂ X) (œÄ_n : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Y_n a b ‚ü∂ Y a) : EffectiveEpiFamily (fun c => Y_n c.fst c.snd) fun c => œÄ_n c.fst c.snd ‚â´ œÄ c.fst := by"
  },
  {
    "full_name": "Matrix.zpow_bit1",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "teorema": "lemma Matrix.zpow_bit1 (A : M) (n : ‚Ñ§) : A ^ bit1 n = A ^ n * A ^ n * A := by"
  },
  {
    "full_name": "MeasureTheory.Measure.exists_measure_inter_spanningSets_pos",
    "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean",
    "teorema": "theorem MeasureTheory.Measure.exists_measure_inter_spanningSets_pos (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (‚àÉ n, 0 < Œº (s ‚à© spanningSets Œº n)) ‚Üî 0 < Œº s := by"
  },
  {
    "full_name": "Set.image_sInter_subset",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "theorem Set.image_sInter_subset (S : Set (Set Œ±)) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : f '' ‚ãÇ‚ÇÄ S ‚äÜ ‚ãÇ s ‚àà S, f '' s := by"
  },
  {
    "full_name": "UniformOnFun.gen_eq_preimage_restrict",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "lemma UniformOnFun.gen_eq_preimage_restrict (S : Set Œ±) (V : Set (Œ≤ √ó Œ≤)) (Œ± : Type u_1) (Œ≤ : Type u_2) (ùîñ : Set (Set Œ±)) : UniformOnFun.gen ùîñ S V = Prod.map (S.restrict ‚àò ‚áëUniformFun.toFun) (S.restrict ‚àò ‚áëUniformFun.toFun) ‚Åª¬π' UniformFun.gen (‚ÜëS) Œ≤ V := by"
  },
  {
    "full_name": "MeasureTheory.locallyIntegrable_finset_sum",
    "file_path": "Mathlib/MeasureTheory/Function/LocallyIntegrable.lean",
    "teorema": "lemma MeasureTheory.locallyIntegrable_finset_sum (E : Type u_3) (X : Type u_1) (f : Œπ ‚Üí X ‚Üí E) (s : Finset Œπ) (Œπ : Type u_6) (Œº : Measure X) : LocallyIntegrable (fun a => ‚àë i ‚àà s, f i a) Œº := by"
  },
  {
    "full_name": "Matrix.charpoly_map",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean",
    "teorema": "lemma Matrix.charpoly_map (M : Matrix n n R) (R : Type u_1) (S : Type u_2) (f : R ‚Üí+* S) (n : Type u_4) : (M.map ‚áëf).charpoly = Polynomial.map f M.charpoly := by"
  },
  {
    "full_name": "Nat.digits_of_lt",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "teorema": "lemma Nat.digits_of_lt (b : ‚Ñï) (x : ‚Ñï) : b.digits x = [x] := by"
  },
  {
    "full_name": "Hyperreal.infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg",
    "file_path": "Mathlib/Data/Real/Hyperreal.lean",
    "teorema": "theorem Hyperreal.infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg (x : ‚Ñù*) (y : ‚Ñù*) : x.InfiniteNeg ‚Üí ¬¨y.Infinitesimal ‚Üí y < 0 ‚Üí (x * y).InfinitePos := by"
  },
  {
    "full_name": "OpenEmbedding.tendsto_nhds_iff'",
    "file_path": "Mathlib/Topology/Maps.lean",
    "teorema": "lemma OpenEmbedding.tendsto_nhds_iff' (X : Type u_1) (Y : Type u_2) (Z : Type u_3) (f : X ‚Üí Y) (g : Y ‚Üí Z) (l : Filter Z) (x : X) : Tendsto (g ‚àò f) (ùìù x) l ‚Üî Tendsto g (ùìù (f x)) l := by"
  },
  {
    "full_name": "Polynomial.pow_mul_divByMonic_rootMultiplicity_eq",
    "file_path": "Mathlib/Algebra/Polynomial/Div.lean",
    "teorema": "lemma Polynomial.pow_mul_divByMonic_rootMultiplicity_eq (R : Type u) (a : R) (p : R[X]) : (X - C a) ^ rootMultiplicity a p * (p /‚Çò (X - C a) ^ rootMultiplicity a p) = p := by"
  },
  {
    "full_name": "WeierstrassCurve.Affine.evalEval_polynomial_zero",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean",
    "teorema": "theorem WeierstrassCurve.Affine.evalEval_polynomial_zero (R : Type u) (W : Affine R) : evalEval 0 0 W.polynomial = -W.a‚ÇÜ := by"
  },
  {
    "full_name": "Fin.min_val",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.min_val (a : Fin n) (n : ‚Ñï) : min (‚Üëa) n = ‚Üëa := by"
  },
  {
    "full_name": "not_summable_indicator_mod_of_antitone_of_neg",
    "file_path": "Mathlib/Analysis/SumOverResidueClass.lean",
    "teorema": "lemma not_summable_indicator_mod_of_antitone_of_neg (f : ‚Ñï ‚Üí ‚Ñù) (k : ZMod m) (m : ‚Ñï) (n : ‚Ñï) : ¬¨Summable ({n | ‚Üën = k}.indicator f) := by"
  },
  {
    "full_name": "lcm_dvd_iff",
    "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean",
    "teorema": "lemma lcm_dvd_iff (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : lcm a b ‚à£ c ‚Üî a ‚à£ c ‚àß b ‚à£ c := by"
  },
  {
    "full_name": "FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos",
    "file_path": "Mathlib/Analysis/Analytic/Inverse.lean",
    "teorema": "lemma FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos (E : Type u_2) (F : Type u_3) (i : E ‚âÉL[ùïú] F) (p : FormalMultilinearSeries ùïú E F) (ùïú : Type u_1) : 0 < (p.rightInv i).radius := by"
  },
  {
    "full_name": "tprod_eq_mul_tprod_ite'",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean",
    "teorema": "lemma tprod_eq_mul_tprod_ite' (b : Œ≤) (f : Œ≤ ‚Üí Œ±) (n : Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : f n = (if n = b then f n else 1) * update f b 1 n := by"
  },
  {
    "full_name": "CategoryTheory.Preadditive.mono_of_isZero_kernel'",
    "file_path": "Mathlib/CategoryTheory/Preadditive/Basic.lean",
    "teorema": "theorem CategoryTheory.Preadditive.mono_of_isZero_kernel' (C : Type u) (P : C) (X : C) (g : P‚úù ‚ü∂ X) : g = 0 := by"
  },
  {
    "full_name": "balancedCoreAux_subset",
    "file_path": "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean",
    "teorema": "lemma balancedCoreAux_subset (E : Type u_2) (s : Set E) (x : E) : x ‚àà s := by"
  },
  {
    "full_name": "Equiv.swap_smul_self_smul",
    "file_path": "Mathlib/GroupTheory/Perm/Basic.lean",
    "teorema": "lemma Equiv.swap_smul_self_smul (i : Œ±) (j : Œ±) (x : Œ≤) (Œ± : Type u) (Œ≤ : Type v) : swap i j ‚Ä¢ swap i j ‚Ä¢ x = x := by"
  },
  {
    "full_name": "BddBelow.isBoundedUnder",
    "file_path": "Mathlib/Order/LiminfLimsup.lean",
    "teorema": "theorem BddBelow.isBoundedUnder (b : Œ±) (u : Œ≤ ‚Üí Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : ‚àÄ (x : Œ≤), u x ‚â• b := by"
  },
  {
    "full_name": "MeasureTheory.SimpleFunc.ennrealRatEmbed_encode",
    "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean",
    "teorema": "lemma MeasureTheory.SimpleFunc.ennrealRatEmbed_encode (q : ‚Ñö) : ennrealRatEmbed (Encodable.encode q) = ‚Üë(‚Üëq).toNNReal := by"
  },
  {
    "full_name": "Stream'.Seq.not_terminates_iff",
    "file_path": "Mathlib/Data/Seq/Seq.lean",
    "teorema": "theorem Stream'.Seq.not_terminates_iff (s : Seq Œ±) (Œ± : Type u) : ¬¨s.Terminates ‚Üî ‚àÄ (n : ‚Ñï), (s.get? n).isSome = true := by"
  },
  {
    "full_name": "MulAction.card_orbit_mul_card_stabilizer_eq_card_group",
    "file_path": "Mathlib/GroupTheory/GroupAction/Quotient.lean",
    "teorema": "theorem MulAction.card_orbit_mul_card_stabilizer_eq_card_group (b : Œ≤) (Œ± : Type u) (Œ≤ : Type v) : Fintype.card ‚Üë(orbit Œ± b) * Fintype.card ‚Ü•(stabilizer Œ± b) = Fintype.card Œ± := by"
  },
  {
    "full_name": "MeasureTheory.Measure.addHaar_parallelepiped",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean",
    "teorema": "lemma MeasureTheory.Measure.addHaar_parallelepiped (G : Type u_4) (b : Basis Œπ ‚Ñù G) (v : Œπ ‚Üí G) (Œπ : Type u_3) : b.addHaar (parallelepiped v) = ENNReal.ofReal |b.det v| := by"
  },
  {
    "full_name": "ContMDiffWithinAt.prod_mk",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Product.lean",
    "teorema": "theorem ContMDiffWithinAt.prod_mk (E : Type u_2) (F : Type u_11) (G : Type u_12) (H : Type u_3) (I : ModelWithCorners ùïú E H) (J : ModelWithCorners ùïú F G) (M : Type u_4) (N : Type u_13) (f : M ‚Üí M') (g : M ‚Üí N') (n : ‚Ñï‚àû) (s : Set M) (x : M) (ùïú : Type u_1) : ContMDiffWithinAt I (I'.prod J') n (fun x => (f x, g x)) s x := by"
  },
  {
    "full_name": "Trivialization.coordChange_coordChange",
    "file_path": "Mathlib/Topology/FiberBundle/Trivialization.lean",
    "teorema": "theorem Trivialization.coordChange_coordChange (B : Type u_2) (F : Type u_3) (Z : Type u_5) (b : B) (e‚ÇÅ : Trivialization F proj) (e‚ÇÇ : Trivialization F proj) (e‚ÇÉ : Trivialization F proj) (proj : Z ‚Üí B) (x : F) : e‚ÇÇ.coordChange e‚ÇÉ b (e‚ÇÅ.coordChange e‚ÇÇ b x) = e‚ÇÅ.coordChange e‚ÇÉ b x := by"
  },
  {
    "full_name": "TensorProduct.LieModule.lie_tmul_right",
    "file_path": "Mathlib/Algebra/Lie/TensorProduct.lean",
    "teorema": "theorem TensorProduct.LieModule.lie_tmul_right (L : Type v) (M : Type w) (N : Type w‚ÇÅ) (R : Type u) (m : M) (n : N) (x : L) : (hasBracketAux x) (m ‚äó‚Çú[R] n) = ‚ÅÖx, m‚ÅÜ ‚äó‚Çú[R] n + m ‚äó‚Çú[R] ‚ÅÖx, n‚ÅÜ := by"
  },
  {
    "full_name": "LieModule.coe_linearMap_maxTrivLinearMapEquivLieModuleHom",
    "file_path": "Mathlib/Algebra/Lie/Abelian.lean",
    "teorema": "theorem LieModule.coe_linearMap_maxTrivLinearMapEquivLieModuleHom (L : Type v) (M : Type w) (N : Type w‚ÇÅ) (R : Type u) (f : ‚Ü•(maxTrivSubmodule R L (M ‚Üí‚Çó[R] N))) : ‚Üë(maxTrivLinearMapEquivLieModuleHom f) = ‚Üëf := by"
  },
  {
    "full_name": "Ordinal.IsNormal.bsup_eq",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "theorem Ordinal.IsNormal.bsup_eq (f : Ordinal.{u} ‚Üí Ordinal.{max u v}) (o : Ordinal.{u}) : (o.bsup fun x x_1 => f x) = f o := by"
  },
  {
    "full_name": "EReal.sign_mul",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "lemma EReal.sign_mul (x : EReal) (y : EReal) : sign (x * y) = sign x * sign y := by"
  },
  {
    "full_name": "TopCat.Presheaf.ext",
    "file_path": "Mathlib/Topology/Sheaves/Presheaf.lean",
    "teorema": "lemma TopCat.Presheaf.ext (C : Type u) (P : Presheaf C X) (Q : Presheaf C X) (X : TopCat) (f : P ‚ü∂ Q) (g : P ‚ü∂ Q) : f = g := by"
  },
  {
    "full_name": "Finset.isGLB_mem",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "theorem Finset.isGLB_mem (i : Œ±) (s : Finset Œ±) (Œ± : Type u_2) : i ‚àà s := by"
  },
  {
    "full_name": "pow_eq_one_iff_cases",
    "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean",
    "teorema": "theorem pow_eq_one_iff_cases (R : Type u_2) (a : R) (n : ‚Ñï) : a ^ n = 1 ‚Üî n = 0 ‚à® a = 1 ‚à® a = -1 ‚àß Even n := by"
  },
  {
    "full_name": "CoxeterSystem.simple_mul_simple_cancel_left",
    "file_path": "Mathlib/GroupTheory/Coxeter/Basic.lean",
    "teorema": "theorem CoxeterSystem.simple_mul_simple_cancel_left (B : Type u_1) (M : CoxeterMatrix B) (W : Type u_3) (cs : CoxeterSystem M W) (i : B) (w : W) : cs.simple i * (cs.simple i * w) = w := by"
  },
  {
    "full_name": "Associates.factors_subsingleton",
    "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean",
    "teorema": "theorem Associates.factors_subsingleton (a : Associates Œ±) (Œ± : Type u_1) : a.factors = ‚ä§ := by"
  },
  {
    "full_name": "Fintype.card_piFinset",
    "file_path": "Mathlib/Data/Fintype/BigOperators.lean",
    "teorema": "lemma Fintype.card_piFinset (s : (i : Œπ) ‚Üí Finset (Œ± i)) (Œ± : Œπ ‚Üí Type u_6) (Œπ : Type u_4) : (piFinset s).card = ‚àè i : Œπ, (s i).card := by"
  },
  {
    "full_name": "Ordnode.BalancedSz.symm",
    "file_path": "Mathlib/Data/Ordmap/Ordset.lean",
    "teorema": "theorem Ordnode.BalancedSz.symm (l : ‚Ñï) (r : ‚Ñï) : l + r ‚â§ 1 ‚Üí r + l ‚â§ 1 := by"
  },
  {
    "full_name": "Filter.map_inf",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "theorem Filter.map_inf (f : Filter Œ±) (g : Filter Œ±) (m : Œ± ‚Üí Œ≤) (Œ± : Type u) (Œ≤ : Type v) : map m (f ‚äì g) = map m f ‚äì map m g := by"
  },
  {
    "full_name": "Set.image2_iUnion_left",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "lemma Set.image2_iUnion_left (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : Œπ ‚Üí Set Œ±) (t : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œπ : Sort u_4) : image2 f (‚ãÉ i, s i) t = ‚ãÉ i, image2 f (s i) t := by"
  },
  {
    "full_name": "Finset.sdiff_erase",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma Finset.sdiff_erase (a : Œ±) (s : Finset Œ±) (t : Finset Œ±) (Œ± : Type u_1) : s \\ t.erase a = insert a (s \\ t) := by"
  },
  {
    "full_name": "ZMod.valMinAbs_eq_zero",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "teorema": "theorem ZMod.valMinAbs_eq_zero (n : ‚Ñï) (x : ZMod n) : x.valMinAbs = 0 ‚Üî x = 0 := by"
  },
  {
    "full_name": "Fintype.prod_bool",
    "file_path": "Mathlib/Data/Fintype/BigOperators.lean",
    "teorema": "lemma Fintype.prod_bool (f : Bool ‚Üí Œ±) (Œ± : Type u_1) : ‚àè b : Bool, f b = f true * f false := by"
  },
  {
    "full_name": "Mathlib.Meta.NormNum.isRat_div",
    "file_path": "Mathlib/Tactic/NormNum/Basic.lean",
    "teorema": "theorem Mathlib.Meta.NormNum.isRat_div (x‚úù : ‚Ñï) (x‚úù¬≤ : Œ±) (x‚úù¬≥ : Œ±) (x‚úù¬π : ‚Ñ§) (Œ± : Type u_1) : IsRat (x‚úù¬≥ / x‚úù¬≤) x‚úù¬π x‚úù := by"
  },
  {
    "full_name": "ENNReal.rpow_lt_top_iff_of_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "lemma ENNReal.rpow_lt_top_iff_of_pos (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù) : x ^ y < ‚ä§ ‚Üî x < ‚ä§ := by"
  },
  {
    "full_name": "AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_nonneg_or_nonpos",
    "file_path": "Mathlib/Computability/AkraBazzi/GrowsPolynomially.lean",
    "teorema": "theorem AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_nonneg_or_nonpos (f : ‚Ñù ‚Üí ‚Ñù) : (‚àÄ·∂† (x : ‚Ñù) in atTop, 0 ‚â§ f x) ‚à® ‚àÄ·∂† (x : ‚Ñù) in atTop, f x ‚â§ 0 := by"
  },
  {
    "full_name": "IsBoundedBilinearMap.fderivWithin",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean",
    "teorema": "theorem IsBoundedBilinearMap.fderivWithin (E : Type u_2) (F : Type u_3) (G : Type u_4) (b : E √ó F ‚Üí G) (h : IsBoundedBilinearMap ùïú b) (p : E √ó F) (u : Set (E √ó F)) (ùïú : Type u_1) : fderivWithin ùïú b u p = h.deriv p := by"
  },
  {
    "full_name": "Real.Angle.toReal_nonneg_iff_sign_nonneg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "lemma Real.Angle.toReal_nonneg_iff_sign_nonneg (Œ∏ : Angle) : 0 ‚â§ Œ∏.toReal ‚Üî 0 ‚â§ Œ∏.sign := by"
  },
  {
    "full_name": "DirectSum.IsInternal.addSubmonoid_iSup_eq_top",
    "file_path": "Mathlib/Algebra/DirectSum/Basic.lean",
    "teorema": "lemma DirectSum.IsInternal.addSubmonoid_iSup_eq_top (A : Œπ ‚Üí AddSubmonoid M) (M : Type u_1) (Œπ : Type v) : iSup A = ‚ä§ := by"
  },
  {
    "full_name": "ENNReal.log_pow",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/ENNReal.lean",
    "teorema": "lemma ENNReal.log_pow (n : ‚Ñï) (x : ‚Ñù‚â•0‚àû) : (x ^ n).log = ‚Üë‚Üën * x.log := by"
  },
  {
    "full_name": "List.count_attach",
    "file_path": "Mathlib/Data/List/Count.lean",
    "teorema": "theorem List.count_attach (a : { x // x ‚àà l }) (l : List Œ±) (x‚úù : x‚úù¬π ‚àà l.attach) (x‚úù¬π : { x // x ‚àà l }) (Œ± : Type u_1) : (x‚úù¬π == a) = true ‚Üî (‚Üëx‚úù¬π == ‚Üëa) = true := by"
  },
  {
    "full_name": "LinearMap.range_zero",
    "file_path": "Mathlib/Algebra/Module/Submodule/Range.lean",
    "teorema": "theorem LinearMap.range_zero : range 0 = ‚ä• := by"
  },
  {
    "full_name": "MetricSpace.ext",
    "file_path": "Mathlib/Topology/MetricSpace/Basic.lean",
    "teorema": "lemma MetricSpace.ext (m : MetricSpace Œ±) (Œ± : Type u_3) : m = m' := by"
  },
  {
    "full_name": "Set.image2_image_right",
    "file_path": "Mathlib/Data/Set/NAry.lean",
    "teorema": "theorem Set.image2_image_right (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≥ ‚Üí Œ¥) (g : Œ≤ ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_3) (Œ≥ : Type u_5) (Œ¥ : Type u_7) : image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t := by"
  },
  {
    "full_name": "IsLindelof.elim_nhds_subcover'",
    "file_path": "Mathlib/Topology/Compactness/Lindelof.lean",
    "teorema": "theorem IsLindelof.elim_nhds_subcover' (U : (x : X) ‚Üí x ‚àà s ‚Üí Set X) (X : Type u) (s : Set X) (t : Set X) : ‚àÉ t, t.Countable ‚àß s ‚äÜ ‚ãÉ x ‚àà t, U ‚Üëx ‚ãØ := by"
  },
  {
    "full_name": "TopCat.GlueData.isOpen_iff",
    "file_path": "Mathlib/Topology/Gluing.lean",
    "teorema": "theorem TopCat.GlueData.isOpen_iff (D : GlueData) (U : Set ‚ÜëD.glued) : IsOpen U ‚Üî ‚àÄ (i : D.J), IsOpen (‚áë(D.Œπ i) ‚Åª¬π' U) := by"
  },
  {
    "full_name": "Erased.out_mk",
    "file_path": "Mathlib/Data/Erased.lean",
    "teorema": "lemma Erased.out_mk (a : Œ±) (Œ± : Sort u_1) : (mk a).out = a := by"
  },
  {
    "full_name": "exists_vector_zero",
    "file_path": "Mathlib/Data/Vector3.lean",
    "teorema": "lemma exists_vector_zero (f : Vector3 Œ± 0 ‚Üí Prop) (Œ± : Type u_1) : f [] := by"
  },
  {
    "full_name": "negSucc_zsmul",
    "file_path": "Mathlib/Algebra/Group/Defs.lean",
    "teorema": "lemma negSucc_zsmul (G : Type u_2) (a : G) (n : ‚Ñï) : Int.negSucc n ‚Ä¢ a = -((n + 1) ‚Ä¢ a) := by"
  },
  {
    "full_name": "CategoryTheory.Functor.Monoidal.tensorHom_app_snd",
    "file_path": "Mathlib/CategoryTheory/ChosenFiniteProducts/FunctorCategory.lean",
    "teorema": "theorem CategoryTheory.Functor.Monoidal.tensorHom_app_snd (C : Type u_2) (F‚ÇÅ : J ‚•§ C) (F‚ÇÇ : J ‚•§ C) (J : Type u_1) (f : F‚ÇÅ ‚ü∂ F‚ÇÅ') (g : F‚ÇÇ ‚ü∂ F‚ÇÇ') (j : J) : (f ‚äó g).app j ‚â´ snd (F‚ÇÅ'.obj j) (F‚ÇÇ'.obj j) = snd (F‚ÇÅ.obj j) (F‚ÇÇ.obj j) ‚â´ g.app j := by"
  },
  {
    "full_name": "CategoryTheory.Limits.prod.lift_fst_snd",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
    "teorema": "theorem CategoryTheory.Limits.prod.lift_fst_snd (C : Type u) (X : C) (Y : C) : lift fst snd = ùüô (X ‚®Ø Y) := by"
  },
  {
    "full_name": "DFinsupp.toFinsupp_single",
    "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean",
    "teorema": "lemma DFinsupp.toFinsupp_single (M : Type u_3) (i : Œπ) (m : M) (Œπ : Type u_1) : (single i m).toFinsupp = Finsupp.single i m := by"
  },
  {
    "full_name": "StrictConcaveOn.lt_slope_of_hasDerivWithinAt_Iio",
    "file_path": "Mathlib/Analysis/Convex/Deriv.lean",
    "teorema": "lemma StrictConcaveOn.lt_slope_of_hasDerivWithinAt_Iio (f : ‚Ñù ‚Üí ‚Ñù) (x : ‚Ñù) (y : ‚Ñù) : f' < slope f x y := by"
  },
  {
    "full_name": "lt_compl_self",
    "file_path": "Mathlib/Order/Heyting/Basic.lean",
    "teorema": "theorem lt_compl_self (a : Œ±) (Œ± : Type u_2) : a < a·∂ú ‚Üî a = ‚ä• := by"
  },
  {
    "full_name": "Ring.image_closure",
    "file_path": "Mathlib/Deprecated/Subring.lean",
    "teorema": "theorem Ring.image_closure (R : Type u) (S : Type u_1) (f : R ‚Üí+* S) (s : Set R) : ‚áëf '' closure s = closure (‚áëf '' s) := by"
  },
  {
    "full_name": "CategoryTheory.Subobject.inf_factors",
    "file_path": "Mathlib/CategoryTheory/Subobject/Lattice.lean",
    "teorema": "theorem CategoryTheory.Subobject.inf_factors (A : C) (B : C) (C : Type u‚ÇÅ) (X : Subobject B) (Y : Subobject B) (f : A ‚ü∂ B) : X.Factors f ‚àß Y.Factors f ‚Üí (X ‚äì Y).Factors f := by"
  },
  {
    "full_name": "Nat.even_xor_odd'",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "lemma Nat.even_xor_odd' (n : ‚Ñï) : ‚àÉ k, Xor' (n = 2 * k) (n = 2 * k + 1) := by"
  },
  {
    "full_name": "LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer",
    "file_path": "Mathlib/Algebra/Lie/Engel.lean",
    "teorema": "theorem LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer (K : LieSubalgebra R L) (L : Type u‚ÇÇ) (R : Type u‚ÇÅ) : ‚àÉ K', IsEngelian R ‚Ü•K' ‚àß K < K' := by"
  },
  {
    "full_name": "SimpleGraph.Walk.length_edges",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "lemma SimpleGraph.Walk.length_edges (G : SimpleGraph V) (V : Type u) (p : G.Walk u v) (u : V) (v : V) : p.edges.length = p.length := by"
  },
  {
    "full_name": "CategoryTheory.Limits.Sigma.map_id",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Products.lean",
    "teorema": "theorem CategoryTheory.Limits.Sigma.map_id (C : Type u) (f : Œ± ‚Üí C) (Œ± : Type w‚ÇÇ) : (map fun a => ùüô (f a)) = ùüô (‚àê f) := by"
  },
  {
    "full_name": "Polynomial.exists_forall_norm_le",
    "file_path": "Mathlib/Topology/Algebra/Polynomial.lean",
    "teorema": "theorem Polynomial.exists_forall_norm_le (R : Type u_2) (p : R[X]) : ‚àÄ (y : R), ‚Äñeval (p.coeff 0) p‚Äñ ‚â§ ‚Äñeval y p‚Äñ := by"
  },
  {
    "full_name": "Pi.mulSingle_comm",
    "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean",
    "teorema": "theorem Pi.mulSingle_comm (I : Type u) (i : I) (x : Œ≤) (Œ≤ : Type u_2) : mulSingle i x i' = mulSingle i' x i := by"
  },
  {
    "full_name": "aux_add",
    "file_path": "Mathlib/Analysis/Convex/Strong.lean",
    "teorema": "theorem aux_add (E : Type u_1) (a : ‚Ñù) (b : ‚Ñù) (f : E ‚Üí ‚Ñù) (m : ‚Ñù) (x : E) (y : E) : a * (f x + m / 2 * ‚Äñx‚Äñ ^ 2) + b * (f y + m / 2 * ‚Äñy‚Äñ ^ 2) - m / 2 * ‚Äña ‚Ä¢ x + b ‚Ä¢ y‚Äñ ^ 2 = a * f x + b * f y + m / 2 * a * b * ‚Äñx - y‚Äñ ^ 2 := by"
  },
  {
    "full_name": "OrderRingHom.cancel_left",
    "file_path": "Mathlib/Algebra/Order/Hom/Ring.lean",
    "teorema": "lemma OrderRingHom.cancel_left (a : Œ±) (f : Œ≤ ‚Üí+*o Œ≥) (g‚ÇÅ : Œ± ‚Üí+*o Œ≤) (g‚ÇÇ : Œ± ‚Üí+*o Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œ≥ : Type u_4) : f (g‚ÇÅ a) = f (g‚ÇÇ a) := by"
  },
  {
    "full_name": "LinearIndependent.image_subtype",
    "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean",
    "teorema": "lemma LinearIndependent.image_subtype (M : Type u_4) (R : Type u_2) (f : M ‚Üí‚Çó[R] M') (s : Set M) (x : M) : LinearIndependent R fun (x : ‚Üë(‚áëf '' s)) => ‚Üëx := by"
  },
  {
    "full_name": "OrdinalApprox.lfpApprox_mem_fixedPoints_of_eq",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPointApproximants.lean",
    "teorema": "lemma OrdinalApprox.lfpApprox_mem_fixedPoints_of_eq (c : Ordinal.{u}) (f : Œ± ‚Üío Œ±) (x : Œ±) (Œ± : Type u) : lfpApprox f x c ‚àà fixedPoints ‚áëf := by"
  },
  {
    "full_name": "Substring.Valid.prevn",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "theorem Substring.Valid.prevn (m‚ÇÅ : List Char) : ‚àÄ (n : Nat), x‚úù.prevn n { byteIdx := utf8Len m‚ÇÅ } = { byteIdx := utf8Len (List.drop n m‚ÇÅ) } := by"
  },
  {
    "full_name": "Multiset.count_sub",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.count_sub (a : Œ±) (s : Multiset Œ±) (t : Multiset Œ±) (Œ± : Type u_1) : count a (s - t) = count a s - count a t := by"
  },
  {
    "full_name": "List.prod_map_erase",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "lemma List.prod_map_erase (M : Type u_4) (a : Œ±) (b : Œ±) (f : Œ± ‚Üí M) (l : List Œ±) (Œ± : Type u_2) : f a * (map f ((b :: l).erase a)).prod = (map f (b :: l)).prod := by"
  },
  {
    "full_name": "SzemerediRegularity.initialBound_le_bound",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Regularity/Bound.lean",
    "teorema": "theorem SzemerediRegularity.initialBound_le_bound (l : ‚Ñï) (Œµ : ‚Ñù) : 0 < 16 ^ stepBound^[‚åä4 / Œµ ^ 5‚åã‚Çä] (initialBound Œµ l) := by"
  },
  {
    "full_name": "Polynomial.coeff_eq_zero_of_lt_natTrailingDegree",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean",
    "teorema": "lemma Polynomial.coeff_eq_zero_of_lt_natTrailingDegree (R : Type u) (n : ‚Ñï) (p : R[X]) : p.coeff n = 0 := by"
  },
  {
    "full_name": "AddCircle.norm_coe_eq_abs_iff",
    "file_path": "Mathlib/Analysis/Normed/Group/AddCircle.lean",
    "teorema": "lemma AddCircle.norm_coe_eq_abs_iff (p : ‚Ñù) (x : ‚Ñù) : ‚Äñ‚Üëx‚Äñ = |x| ‚Üî |x| ‚â§ |p| / 2 := by"
  },
  {
    "full_name": "Nat.multinomial_insert",
    "file_path": "Mathlib/Data/Nat/Choose/Multinomial.lean",
    "teorema": "lemma Nat.multinomial_insert (a : Œ±) (f : Œ± ‚Üí ‚Ñï) (s : Finset Œ±) (Œ± : Type u_1) : multinomial (insert a s) f = (f a + ‚àë i ‚àà s, f i).choose (f a) * multinomial s f := by"
  },
  {
    "full_name": "Prefunctor.mapPath_comp",
    "file_path": "Mathlib/Combinatorics/Quiver/Path.lean",
    "teorema": "lemma Prefunctor.mapPath_comp (F : V ‚•§q W) (V : Type u‚ÇÅ) (W : Type u‚ÇÇ) (a : V) (b : V) (c : V) (e : b‚úù ‚ü∂ c) (p : Path a b) (q : Path b b‚úù) : F.mapPath (p.comp (q.cons e)) = (F.mapPath p).comp (F.mapPath (q.cons e)) := by"
  },
  {
    "full_name": "MeasureTheory.predictablePart_zero",
    "file_path": "Mathlib/Probability/Martingale/Centering.lean",
    "teorema": "theorem MeasureTheory.predictablePart_zero (E : Type u_2) (f : ‚Ñï ‚Üí Œ© ‚Üí E) (m0 : MeasurableSpace Œ©) (Œ© : Type u_1) (Œº : Measure Œ©) (‚Ñ± : Filtration ‚Ñï m0) : predictablePart f ‚Ñ± Œº 0 = 0 := by"
  },
  {
    "full_name": "List.takeWhile_cons_of_pos",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "theorem List.takeWhile_cons_of_pos (l : List Œ±) (p : Œ± ‚Üí Bool) (x : Œ±) (Œ± : Type u) : takeWhile p (x :: l) = x :: takeWhile p l := by"
  },
  {
    "full_name": "Zspan.repr_ceil_apply",
    "file_path": "Mathlib/Algebra/Module/Zlattice/Basic.lean",
    "teorema": "theorem Zspan.repr_ceil_apply (E : Type u_1) (K : Type u_3) (b : Basis Œπ K E) (i : Œπ) (m : E) (Œπ : Type u_2) : (b.repr ‚Üë(ceil b m)) i = ‚Üë‚åà(b.repr m) i‚åâ := by"
  },
  {
    "full_name": "SignType.le_antisymm",
    "file_path": "Mathlib/Data/Sign.lean",
    "teorema": "theorem SignType.le_antisymm (a : SignType) (b : SignType) : a = b := by"
  },
  {
    "full_name": "MvQPF.Fix.rec_unique",
    "file_path": "Mathlib/Data/QPF/Multivariate/Constructions/Fix.lean",
    "teorema": "theorem MvQPF.Fix.rec_unique (F : TypeVec.{u} (n + 1) ‚Üí Type u) (g : F (Œ± ::: Œ≤) ‚Üí Œ≤) (h : Fix F Œ± ‚Üí Œ≤) (n : ‚Ñï) (Œ± : TypeVec.{u} n) (Œ≤ : Type u) : rec g = h := by"
  },
  {
    "full_name": "IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed",
    "file_path": "Mathlib/Topology/Compactness/Compact.lean",
    "teorema": "lemma IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed (X : Type u) (t : Œπ ‚Üí Set X) (Œπ : Type v) : (‚ãÇ i, t i).Nonempty := by"
  },
  {
    "full_name": "Function.IsFixedPt.apply",
    "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean",
    "teorema": "lemma Function.IsFixedPt.apply (f : Œ± ‚Üí Œ±) (x : Œ±) (Œ± : Type u) : IsFixedPt f (f x) := by"
  },
  {
    "full_name": "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "file_path": "Mathlib/MeasureTheory/Integral/Bochner.lean",
    "teorema": "theorem MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part (f : Œ± ‚Üí ‚Ñù) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´ (a : Œ±), f a ‚àÇŒº = (‚à´‚Åª (a : Œ±), ENNReal.ofReal (f a) ‚àÇŒº).toReal - (‚à´‚Åª (a : Œ±), ENNReal.ofReal (-f a) ‚àÇŒº).toReal := by"
  },
  {
    "full_name": "HomogeneousLocalization.val_sub",
    "file_path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean",
    "teorema": "theorem HomogeneousLocalization.val_sub (A : Type u_3) (R : Type u_2) (x : Submonoid A) (y1 : HomogeneousLocalization ùíú x) (y2 : HomogeneousLocalization ùíú x) (Œπ : Type u_1) (ùíú : Œπ ‚Üí Submodule R A) : (y1 - y2).val = y1.val - y2.val := by"
  },
  {
    "full_name": "Set.preimage_const_add_Icc",
    "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean",
    "teorema": "lemma Set.preimage_const_add_Icc (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : (fun x => a + x) ‚Åª¬π' Icc b c = Icc (b - a) (c - a) := by"
  },
  {
    "full_name": "Nat.floor_eq_iff",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem Nat.floor_eq_iff (a : Œ±) (n : ‚Ñï) (Œ± : Type u_2) : ‚åäa‚åã‚Çä = n ‚Üî ‚Üën ‚â§ a ‚àß a < ‚Üën + 1 := by"
  },
  {
    "full_name": "List.IsPrefix.ne_nil",
    "file_path": "Mathlib/Data/List/Infix.lean",
    "teorema": "theorem List.IsPrefix.ne_nil (y : List Œ±) (Œ± : Type u_1) : y ‚â† [] := by"
  },
  {
    "full_name": "OreLocalization.add_assoc",
    "file_path": "Mathlib/RingTheory/OreLocalization/Basic.lean",
    "teorema": "theorem OreLocalization.add_assoc (R : Type u_1) (S : Submonoid R) (X : Type u_2) (x : OreLocalization S X) (y : OreLocalization S X) (z : OreLocalization S X) : x + y + z = x + (y + z) := by"
  },
  {
    "full_name": "ENNReal.toReal_le_toReal",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "teorema": "lemma ENNReal.toReal_le_toReal (a : ‚Ñù‚â•0‚àû) (b : ‚Ñù‚â•0‚àû) : a.toReal ‚â§ b.toReal ‚Üî a ‚â§ b := by"
  },
  {
    "full_name": "Subgroup.mem_ofUnits_iff_toUnits_mem",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Units.lean",
    "teorema": "lemma Subgroup.mem_ofUnits_iff_toUnits_mem (G : Type u_2) (H : Subgroup GÀ£) (x : G) : x ‚àà H.ofUnits ‚Üî toUnits x ‚àà H := by"
  },
  {
    "full_name": "Equiv.Perm.card_cycleType_eq_zero",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean",
    "teorema": "lemma Equiv.Perm.card_cycleType_eq_zero (Œ± : Type u_1) (œÉ : Perm Œ±) : card œÉ.cycleType = 0 ‚Üî œÉ = 1 := by"
  },
  {
    "full_name": "Finite.isDomain_to_isField",
    "file_path": "Mathlib/RingTheory/LittleWedderburn.lean",
    "teorema": "theorem Finite.isDomain_to_isField (D : Type u_1) : IsField D := by"
  },
  {
    "full_name": "Filter.iInf_principal_finite",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "theorem Filter.iInf_principal_finite (f : Œπ ‚Üí Set Œ±) (s : Set Œπ) (Œ± : Type u) (Œπ : Type w) : ‚®Ö i ‚àà s, ùìü (f i) = ùìü (‚ãÇ i ‚àà s, f i) := by"
  },
  {
    "full_name": "MeasureTheory.Lp.ae_tendsto_of_cauchy_snorm'",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "lemma MeasureTheory.Lp.ae_tendsto_of_cauchy_snorm' (E : Type u_2) (f : ‚Ñï ‚Üí Œ± ‚Üí E) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÉ l, Tendsto (fun n => f n x) atTop (ùìù l) := by"
  },
  {
    "full_name": "Ideal.isUnit_iff",
    "file_path": "Mathlib/RingTheory/Ideal/Operations.lean",
    "teorema": "theorem Ideal.isUnit_iff (I : Ideal R) (R : Type u) : ‚ä§ = I * ‚ä§ := by"
  },
  {
    "full_name": "List.nodup_enum_map_fst",
    "file_path": "Mathlib/Data/List/Sigma.lean",
    "teorema": "theorem List.nodup_enum_map_fst (l : List Œ±) (Œ± : Type u) : (map Prod.fst l.enum).Nodup := by"
  },
  {
    "full_name": "Projectivization.Subspace.sup_span",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Subspace.lean",
    "teorema": "theorem Projectivization.Subspace.sup_span (K : Type u_1) (S : Set (‚Ñô K V)) (V : Type u_2) (W : Subspace K V) : W ‚äî span S = span (‚ÜëW ‚à™ S) := by"
  },
  {
    "full_name": "FiniteDimensional.finrank_self",
    "file_path": "Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean",
    "teorema": "lemma FiniteDimensional.finrank_self (R : Type u) : Module.rank R R = ‚Üë1 := by"
  },
  {
    "full_name": "Matrix.mem_range_scalar_iff_commute_stdBasisMatrix",
    "file_path": "Mathlib/Data/Matrix/Basis.lean",
    "teorema": "lemma Matrix.mem_range_scalar_iff_commute_stdBasisMatrix (M : Matrix n n Œ±) (n : Type u_3) (Œ± : Type u_5) : M ‚àà Set.range ‚áë(scalar n) ‚Üî ‚àÄ (i j : n), i ‚â† j ‚Üí Commute (stdBasisMatrix i j 1) M := by"
  },
  {
    "full_name": "ProbabilityTheory.gaussianReal_map_add_const",
    "file_path": "Mathlib/Probability/Distributions/Gaussian.lean",
    "teorema": "theorem ProbabilityTheory.gaussianReal_map_add_const (v : ‚Ñù‚â•0) (y : ‚Ñù) (Œº : ‚Ñù) : Measure.map (fun x => x + y) (gaussianReal Œº v) = gaussianReal (Œº + y) v := by"
  },
  {
    "full_name": "LipschitzWith.pow_end",
    "file_path": "Mathlib/Topology/EMetricSpace/Lipschitz.lean",
    "teorema": "theorem LipschitzWith.pow_end (K : ‚Ñù‚â•0) (f : Function.End Œ±) (Œ± : Type u) : LipschitzWith (K ^ 0) (f ^ 0) := by"
  },
  {
    "full_name": "YoungDiagram.mk_mem_col_iff",
    "file_path": "Mathlib/Combinatorics/Young/YoungDiagram.lean",
    "teorema": "theorem YoungDiagram.mk_mem_col_iff (i : ‚Ñï) (j : ‚Ñï) (Œº : YoungDiagram) : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº := by"
  },
  {
    "full_name": "Finset.geomSum_ofColex_strictMono",
    "file_path": "Mathlib/Combinatorics/Colex.lean",
    "teorema": "theorem Finset.geomSum_ofColex_strictMono (n : ‚Ñï) (s : Finset ‚Ñï) : StrictMono fun s => ‚àë k ‚àà s.ofColex, n ^ k := by"
  },
  {
    "full_name": "CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj",
    "file_path": "Mathlib/CategoryTheory/Shift/InducedShiftSequence.lean",
    "teorema": "theorem CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj (A : Type u_3) (C : Type u_1) (D : Type u_2) (F : D ‚•§ A) (G : C ‚•§ A) (L : C ‚•§ D) (M : Type u_4) (X : C) (a : M) (e : L ‚ãô F ‚âÖ G) (n : M) : (F.shiftIso n a a' ha').hom.app (L.obj X) = (F.shift a).map ((L.commShiftIso n).inv.app X) ‚â´ (e' a).hom.app ((shiftFunctor C n).obj X) ‚â´ (G.shiftIso n a a' ha').hom.app X ‚â´ (e' a').inv.app X := by"
  },
  {
    "full_name": "Polynomial.degree_eq_card_roots",
    "file_path": "Mathlib/Algebra/Polynomial/Splits.lean",
    "teorema": "lemma Polynomial.degree_eq_card_roots (K : Type v) (L : Type w) (i : K ‚Üí+* L) (p : K[X]) : p.degree = ‚Üë(Multiset.card (map i p).roots) := by"
  },
  {
    "full_name": "UniformOnFun.uniformContinuous_toFun",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "lemma UniformOnFun.uniformContinuous_toFun (Œ± : Type u_1) (ùîñ : Set (Set Œ±)) : UniformContinuous ‚áë(toFun ùîñ) := by"
  },
  {
    "full_name": "AlgebraicGeometry.ProjectiveSpectrum.Proj.stalkMap_toSpec",
    "file_path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",
    "teorema": "lemma AlgebraicGeometry.ProjectiveSpectrum.Proj.stalkMap_toSpec (A : Type u_2) (R : Type u_1) (f : A) (f_deg : f ‚àà ùíú m) (hm : 0 < m) (m : ‚Ñï) (x : ‚Ü•(pbo f)) (ùíú : ‚Ñï ‚Üí Submodule R A) : awayToŒì ùíú f ‚â´ (Proj.restrict ‚ãØ).ŒìToStalk x = RingHom.comp ((specStalkEquiv ùíú f x f_deg hm).hom ‚â´ (Proj.stalkIso' ùíú ‚Üëx).toCommRingCatIso.inv ‚â´ (Proj.restrictStalkIso ‚ãØ x).inv) (algebraMap (A‚Å∞_ f) ‚Üë((Spec.structureSheaf (A‚Å∞_ f)).presheaf.stalk ((toSpec ùíú f).val.base x))) := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_tilted",
    "file_path": "Mathlib/MeasureTheory/Measure/Tilted.lean",
    "teorema": "lemma MeasureTheory.lintegral_tilted (f : Œ± ‚Üí ‚Ñù) (g : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±), g x ‚àÇŒº.tilted f = ‚à´‚Åª (x : Œ±), ENNReal.ofReal (rexp (f x) / ‚à´ (x : Œ±), rexp (f x) ‚àÇŒº) * g x ‚àÇŒº := by"
  },
  {
    "full_name": "Nat.choose_two_right",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "teorema": "theorem Nat.choose_two_right (n : ‚Ñï) : n.choose 2 = n * (n - 1) / 2 := by"
  },
  {
    "full_name": "Vector.replicate_succ_to_snoc",
    "file_path": "Mathlib/Data/Vector/Snoc.lean",
    "teorema": "theorem Vector.replicate_succ_to_snoc (n : ‚Ñï) (val : Œ±) (Œ± : Type u_1) : replicate (n + 1) val = (replicate n val).snoc val := by"
  },
  {
    "full_name": "Computable.list_ofFn",
    "file_path": "Mathlib/Computability/Partrec.lean",
    "teorema": "lemma Computable.list_ofFn (x‚úù : ‚àÄ (i : Fin 0), Computable (x‚úù¬π i)) (x‚úù¬π : Fin 0 ‚Üí Œ± ‚Üí œÉ) (Œ± : Type u_1) (œÉ : Type u_4) : Computable fun a => List.ofFn fun i => x‚úù¬π i a := by"
  },
  {
    "full_name": "IsSquare.pow",
    "file_path": "Mathlib/Algebra/Group/Even.lean",
    "teorema": "theorem IsSquare.pow (a : Œ±) (n : ‚Ñï) (Œ± : Type u_2) : IsSquare a ‚Üí IsSquare (a ^ n) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.coequalizerComparison_map_desc",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean",
    "teorema": "theorem CategoryTheory.Limits.coequalizerComparison_map_desc (C : Type u) (D : Type u‚ÇÇ) (G : C ‚•§ D) (X : C) (Y : C) (Z : C) (f : X ‚ü∂ Y) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z) : G.map f ‚â´ G.map h = G.map g ‚â´ G.map h := by"
  },
  {
    "full_name": "sbtw_one_zero_iff",
    "file_path": "Mathlib/Analysis/Convex/Between.lean",
    "teorema": "lemma sbtw_one_zero_iff (R : Type u_1) (x : R) : Sbtw R 1 x 0 ‚Üî x ‚àà Set.Ioo 0 1 := by"
  },
  {
    "full_name": "CompositionSeries.isMaximal_eraseLast_last",
    "file_path": "Mathlib/Order/JordanHolder.lean",
    "teorema": "lemma CompositionSeries.isMaximal_eraseLast_last (X : Type u) (s : CompositionSeries X) : IsMaximal (eraseLast s).last (last s) := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean",
    "teorema": "theorem MeasureTheory.OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top (m : OuterMeasure Œ±) (s : ‚Ñï ‚Üí Set Œ±) (Œ± : Type u_1) : m (‚ãÉ n, s n) = ‚®Ü n, m (s n) := by"
  },
  {
    "full_name": "Batteries.RBNode.lowerBound?_le'",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "teorema": "lemma Batteries.RBNode.lowerBound?_le' (cut : Œ± ‚Üí Ordering) (lb : Option Œ±) (t : RBNode Œ±) (x : Œ±) (Œ± : Type u_1) : lowerBound? cut t lb = some x ‚Üí cut x ‚â† Ordering.lt := by"
  },
  {
    "full_name": "LieAlgebra.IsKilling.traceForm_eq_zero_of_mem_ker_of_mem_span_coroot",
    "file_path": "Mathlib/Algebra/Lie/Weights/Killing.lean",
    "teorema": "theorem LieAlgebra.IsKilling.traceForm_eq_zero_of_mem_ker_of_mem_span_coroot (H : LieSubalgebra K L) (K : Type u_2) (L : Type u_3) (x : ‚Ü•H) (y : ‚Ü•H) : ((traceForm K (‚Ü•H) L) x) y = 0 := by"
  },
  {
    "full_name": "one_le_pow_mul_abs_eval_div",
    "file_path": "Mathlib/Algebra/Polynomial/DenomsClearable.lean",
    "teorema": "lemma one_le_pow_mul_abs_eval_div (K : Type u_1) (a : ‚Ñ§) (b : ‚Ñ§) (f : ‚Ñ§[X]) : 1 ‚â§ ‚Üëb ^ f.natDegree * |eval (‚Üëa / ‚Üëb) (Polynomial.map (algebraMap ‚Ñ§ K) f)| := by"
  },
  {
    "full_name": "ENNReal.iSup_add_iSup",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "lemma ENNReal.iSup_add_iSup (a : ‚Ñù‚â•0‚àû) (f : Œπ ‚Üí ‚Ñù‚â•0‚àû) (g : Œπ ‚Üí ‚Ñù‚â•0‚àû) (Œπ : Sort u_4) : iSup f + iSup g = ‚®Ü a, f a + g a := by"
  },
  {
    "full_name": "le_egauge_smul_right",
    "file_path": "Mathlib/Analysis/Convex/EGauge.lean",
    "teorema": "theorem le_egauge_smul_right (E : Type u_3) (c : ùïú) (s : Set E) (x : E) (ùïú : Type u_1) : ‚Üë‚Äñc‚Äñ‚Çä * egauge ùïú s x ‚â§ egauge ùïú s (c ‚Ä¢ x) := by"
  },
  {
    "full_name": "subsingleton_or_nontrivial",
    "file_path": "Mathlib/Logic/Nontrivial/Defs.lean",
    "teorema": "lemma subsingleton_or_nontrivial (Œ± : Type u_3) : Subsingleton Œ± ‚à® Nontrivial Œ± := by"
  },
  {
    "full_name": "LinearMap.finiteDimensional_of_det_ne_one",
    "file_path": "Mathlib/LinearAlgebra/Determinant.lean",
    "teorema": "theorem LinearMap.finiteDimensional_of_det_ne_one (M : Type u_2) (ùïú : Type u_7) : FiniteDimensional ùïú M := by"
  },
  {
    "full_name": "Int.even_pow",
    "file_path": "Mathlib/Algebra/Group/Int.lean",
    "teorema": "lemma Int.even_pow (m : ‚Ñ§) (n : ‚Ñï) : Even (m ^ n) ‚Üî Even m ‚àß n ‚â† 0 := by"
  },
  {
    "full_name": "Zsqrtd.le_antisymm",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "theorem Zsqrtd.le_antisymm (a : ‚Ñ§‚àö‚Üëd) (b : ‚Ñ§‚àö‚Üëd) (d : ‚Ñï) : (-(a - b)).Nonneg := by"
  },
  {
    "full_name": "LinearMap.rank_comp_le_left",
    "file_path": "Mathlib/LinearAlgebra/Dimension/LinearMap.lean",
    "teorema": "lemma LinearMap.rank_comp_le_left (K : Type u) (V : Type v) (f : V' ‚Üí‚Çó[K] V'') (g : V ‚Üí‚Çó[K] V') : (f ‚àò‚Çó g).rank ‚â§ f.rank := by"
  },
  {
    "full_name": "ENNReal.rpow_eq_top_of_nonneg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "lemma ENNReal.rpow_eq_top_of_nonneg (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù) : x ^ y = ‚ä§ ‚Üí x = ‚ä§ := by"
  },
  {
    "full_name": "PiNat.cylinder_eq_cylinder_of_le_firstDiff",
    "file_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
    "teorema": "theorem PiNat.cylinder_eq_cylinder_of_le_firstDiff (E : ‚Ñï ‚Üí Type u_1) (n : ‚Ñï) (x : (n : ‚Ñï) ‚Üí E n) (y : (n : ‚Ñï) ‚Üí E n) : cylinder x n = cylinder y n := by"
  },
  {
    "full_name": "Function.invFun_eq_of_injective_of_rightInverse",
    "file_path": "Mathlib/Logic/Function/Basic.lean",
    "teorema": "theorem Function.invFun_eq_of_injective_of_rightInverse (b : Œ≤) (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (Œ± : Sort u_1) (Œ≤ : Sort u_2) : f (invFun f b) = f (g b) := by"
  },
  {
    "full_name": "MeasureTheory.tendsto_setToFun_filter_of_dominated_convergence",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "theorem MeasureTheory.tendsto_setToFun_filter_of_dominated_convergence (C : ‚Ñù) (E : Type u_2) (F : Type u_3) (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (f : Œ± ‚Üí E) (fs : Œπ ‚Üí Œ± ‚Üí E) (hT : DominatedFinMeasAdditive Œº T C) (l : Filter Œπ) (Œ± : Type u_1) (Œπ : Type u_7) (Œº : Measure Œ±) : Tendsto (fun n => setToFun Œº T hT (fs n)) l (ùìù (setToFun Œº T hT f)) := by"
  },
  {
    "full_name": "LieAlgebra.zeroRootSubalgebra_normalizer_eq_self",
    "file_path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
    "teorema": "theorem LieAlgebra.zeroRootSubalgebra_normalizer_eq_self (H : LieSubalgebra R L) (L : Type u_2) (R : Type u_1) : (zeroRootSubalgebra R L H).normalizer = zeroRootSubalgebra R L H := by"
  },
  {
    "full_name": "CategoryTheory.PresheafHom.IsSheafFor.exists_app",
    "file_path": "Mathlib/CategoryTheory/Sites/SheafHom.lean",
    "teorema": "theorem CategoryTheory.PresheafHom.IsSheafFor.exists_app : ‚àÉ œÜ, := by"
  },
  {
    "full_name": "AdjoinRoot.isRoot_root",
    "file_path": "Mathlib/RingTheory/AdjoinRoot.lean",
    "teorema": "lemma AdjoinRoot.isRoot_root (R : Type u) (f : R[X]) : (Polynomial.map (of f) f).IsRoot (root f) := by"
  },
  {
    "full_name": "CauSeq.abv_pos_of_not_limZero",
    "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean",
    "teorema": "theorem CauSeq.abv_pos_of_not_limZero (abv : Œ≤ ‚Üí Œ±) (f : CauSeq Œ≤ abv) (Œ± : Type u_1) (Œ≤ : Type u_2) : ‚àÉ K > 0, ‚àÉ i, ‚àÄ j ‚â• i, K ‚â§ abv (‚Üëf j) := by"
  },
  {
    "full_name": "MeasureTheory.norm_condexpIndL1_le",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean",
    "teorema": "theorem MeasureTheory.norm_condexpIndL1_le (G : Type u_5) (hm : m ‚â§ m0) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (s : Set Œ±) (x : G) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚ÄñcondexpIndL1 hm Œº s x‚Äñ ‚â§ (Œº s).toReal * ‚Äñx‚Äñ := by"
  },
  {
    "full_name": "Function.Antiperiodic.add",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "theorem Function.Antiperiodic.add (c‚ÇÅ : Œ±) (c‚ÇÇ : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : Periodic f (c‚ÇÅ + c‚ÇÇ) := by"
  },
  {
    "full_name": "MulMemClass.mul_mem_add_closure",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
    "teorema": "theorem MulMemClass.mul_mem_add_closure (M : Type u_1) (R : Type u_4) (S : M) (a : R) (b : R) : a * b ‚àà AddSubmonoid.closure ‚ÜëS := by"
  },
  {
    "full_name": "Polynomial.IsPrimitive.dvd_of_fraction_map_dvd_fraction_map",
    "file_path": "Mathlib/RingTheory/Polynomial/GaussLemma.lean",
    "teorema": "lemma Polynomial.IsPrimitive.dvd_of_fraction_map_dvd_fraction_map (R : Type u_1) (p : R[X]) (q : R[X]) : p ‚à£ q := by"
  },
  {
    "full_name": "Nat.swap_mem_divisorsAntidiagonal",
    "file_path": "Mathlib/NumberTheory/Divisors.lean",
    "teorema": "lemma Nat.swap_mem_divisorsAntidiagonal (n : ‚Ñï) (x : ‚Ñï √ó ‚Ñï) : x.swap ‚àà n.divisorsAntidiagonal ‚Üî x ‚àà n.divisorsAntidiagonal := by"
  },
  {
    "full_name": "Representation.asAlgebraHom_single",
    "file_path": "Mathlib/RepresentationTheory/Basic.lean",
    "teorema": "lemma Representation.asAlgebraHom_single (G : Type u_2) (V : Type u_3) (g : G) (k : Type u_1) (r : k) (œÅ : Representation k G V) : œÅ.asAlgebraHom (Finsupp.single g r) = r ‚Ä¢ œÅ g := by"
  },
  {
    "full_name": "Topology.IsLowerSet.monotone_iff_continuous",
    "file_path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
    "teorema": "theorem Topology.IsLowerSet.monotone_iff_continuous (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : Monotone f ‚Üî Continuous f := by"
  },
  {
    "full_name": "DifferentiableWithinAt.mono",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
    "teorema": "lemma DifferentiableWithinAt.mono (E : Type u_2) (F : Type u_3) (f : E ‚Üí F) (s : Set E) (x : E) (ùïú : Type u_1) : DifferentiableWithinAt ùïú f s x := by"
  },
  {
    "full_name": "Equiv.toFun_inducedStructureEquiv_Symm",
    "file_path": "Mathlib/ModelTheory/Basic.lean",
    "teorema": "theorem Equiv.toFun_inducedStructureEquiv_Symm (M : Type u_1) (N : Type u_2) : N ‚Üí M := by"
  },
  {
    "full_name": "UpperHalfPlane.dist_coe_le",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean",
    "teorema": "lemma UpperHalfPlane.dist_coe_le (w : ‚Ñç) (z : ‚Ñç) : dist ‚Üëz ‚Üë(w.center (dist z w)) + dist ‚Üëw ‚Üë(w.center (dist z w)) = w.im * (rexp (dist z w) - 1) := by"
  },
  {
    "full_name": "CategoryTheory.Functor.flip_injective",
    "file_path": "Mathlib/CategoryTheory/Functor/Currying.lean",
    "teorema": "lemma CategoryTheory.Functor.flip_injective (B : Type u‚ÇÅ) (C : Type u‚ÇÇ) (D : Type u‚ÇÉ) (F‚ÇÅ : B ‚•§ C ‚•§ D) (F‚ÇÇ : B ‚•§ C ‚•§ D) : F‚ÇÅ = F‚ÇÇ := by"
  },
  {
    "full_name": "ProbabilityTheory.monotone_defaultRatCDF",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/MeasurableStieltjes.lean",
    "teorema": "theorem ProbabilityTheory.monotone_defaultRatCDF : Monotone defaultRatCDF := by"
  },
  {
    "full_name": "Filter.map‚ÇÇ_mk_eq_prod",
    "file_path": "Mathlib/Order/Filter/NAry.lean",
    "teorema": "lemma Filter.map‚ÇÇ_mk_eq_prod (f : Filter Œ±) (g : Filter Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_3) : map‚ÇÇ Prod.mk f g = f √óÀ¢ g := by"
  },
  {
    "full_name": "ULower.up_down",
    "file_path": "Mathlib/Logic/Encodable/Basic.lean",
    "teorema": "theorem ULower.up_down (a : Œ±) (Œ± : Type u_1) : (down a).up = a := by"
  },
  {
    "full_name": "MultilinearMap.bound_of_shell_of_norm_map_coord_zero",
    "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean",
    "teorema": "theorem MultilinearMap.bound_of_shell_of_norm_map_coord_zero (C : ‚Ñù) (E : Œπ ‚Üí Type wE) (G : Type wG) (f : MultilinearMap ùïú E G) (m : (i : Œπ) ‚Üí E i) (Œπ : Type v) (ùïú : Type u) : ‚Äñf m‚Äñ ‚â§ C * ‚àè i : Œπ, ‚Äñm i‚Äñ := by"
  },
  {
    "full_name": "contMDiff_inclusion",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Basic.lean",
    "teorema": "theorem contMDiff_inclusion (E : Type u_2) (H : Type u_3) (I : ModelWithCorners ùïú E H) (M : Type u_4) (U : Opens M) (V : Opens M) (h : U ‚â§ V) (n : ‚Ñï‚àû) (ùïú : Type u_1) : ContMDiff I I n (inclusion h) := by"
  },
  {
    "full_name": "Nat.prime_three",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "theorem Nat.prime_three : Prime 3 := by"
  },
  {
    "full_name": "LinearMap.trace_tensorProduct'",
    "file_path": "Mathlib/LinearAlgebra/Trace.lean",
    "teorema": "theorem LinearMap.trace_tensorProduct' (M : Type u_2) (N : Type u_3) (R : Type u_1) (f : M ‚Üí‚Çó[R] M) (g : N ‚Üí‚Çó[R] N) : (trace R (M ‚äó[R] N)) (TensorProduct.map f g) = (trace R M) f * (trace R N) g := by"
  },
  {
    "full_name": "Set.Ioo_add_bij",
    "file_path": "Mathlib/Algebra/Order/Interval/Set/Monoid.lean",
    "teorema": "lemma Set.Ioo_add_bij (M : Type u_1) (a : M) (b : M) (d : M) : BijOn (fun x => x + d) (Ioo a b) (Ioo (a + d) (b + d)) := by"
  },
  {
    "full_name": "Set.Ioc_union_Ioi'",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Ioc_union_Ioi' (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : Ioc a b ‚à™ Ioi c = Ioi (min a c) := by"
  },
  {
    "full_name": "LucasLehmer.œâ_pow_formula",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "teorema": "theorem LucasLehmer.œâ_pow_formula : ‚àÉ k, œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1 := by"
  },
  {
    "full_name": "MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "lemma MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe (s : Set Œ±) (t : Set ‚Üës) (Œ± : Type u_2) (Œº : Measure Œ±) : NullMeasurableSet (Subtype.val '' t) Œº := by"
  },
  {
    "full_name": "MeasureTheory.Measure.integral_comp_mul_left",
    "file_path": "Mathlib/MeasureTheory/Measure/Haar/NormedSpace.lean",
    "teorema": "lemma MeasureTheory.Measure.integral_comp_mul_left (F : Type u_2) (a : ‚Ñù) (g : ‚Ñù ‚Üí F) : ‚à´ (x : ‚Ñù), g (a * x) = |a‚Åª¬π| ‚Ä¢ ‚à´ (y : ‚Ñù), g y := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.Point.toAffine_of_equiv",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.Point.toAffine_of_equiv (F : Type v) (P : Fin 3 ‚Üí F) (Q : Fin 3 ‚Üí F) (W : Jacobian F) : toAffine W P = toAffine W Q := by"
  },
  {
    "full_name": "Finsupp.sigma_support",
    "file_path": "Mathlib/Data/Finsupp/Basic.lean",
    "teorema": "lemma Finsupp.sigma_support (M : Type u_5) (l : (i : Œπ) √ó Œ±s i ‚Üí‚ÇÄ M) (Œ±s : Œπ ‚Üí Type u_13) (Œπ : Type u_4) : l.support = l.splitSupport.sigma fun i => (l.split i).support := by"
  },
  {
    "full_name": "List.Nat.mem_antidiagonalTuple",
    "file_path": "Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean",
    "teorema": "theorem List.Nat.mem_antidiagonalTuple (n : ‚Ñï) : Fin.elim0 ‚àà antidiagonalTuple 0 n ‚Üî ‚àë i : Fin 0, i.elim0 = n := by"
  },
  {
    "full_name": "MeasureTheory.tendsto_condexp_unique",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean",
    "teorema": "theorem MeasureTheory.tendsto_condexp_unique (F : Type u_2) (f : Œ± ‚Üí F') (g : Œ± ‚Üí F') (m : MeasurableSpace Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº[f|m] =·∂†[ae Œº] Œº[g|m] := by"
  },
  {
    "full_name": "RingHom.codomain_trivial_iff_map_one_eq_zero",
    "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
    "teorema": "theorem RingHom.codomain_trivial_iff_map_one_eq_zero (f : Œ± ‚Üí+* Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : 0 = 1 ‚Üî f 1 = 0 := by"
  },
  {
    "full_name": "cfc_nonpos",
    "file_path": "Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean",
    "teorema": "theorem cfc_nonpos (A : Type u_2) (R : Type u_1) (a : A) (f : R ‚Üí R) : cfc f a ‚â§ 0 := by"
  },
  {
    "full_name": "RelEmbedding.exists_not_acc_lt_of_not_acc",
    "file_path": "Mathlib/Order/OrderIsoNat.lean",
    "teorema": "lemma RelEmbedding.exists_not_acc_lt_of_not_acc (a : Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : ‚àÉ b, ¬¨Acc r b ‚àß r b a := by"
  },
  {
    "full_name": "Set.image_prod_mk_subset_prod_left",
    "file_path": "Mathlib/Data/Set/Prod.lean",
    "teorema": "lemma Set.image_prod_mk_subset_prod_left (a : Œ±) (b : Œ≤) (s : Set Œ±) (t : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (fun a => (a, b)) '' s ‚äÜ s √óÀ¢ t := by"
  },
  {
    "full_name": "PMF.map_apply",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Constructions.lean",
    "teorema": "lemma PMF.map_apply (b : Œ≤) (f : Œ± ‚Üí Œ≤) (p : PMF Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : (map f p) b = ‚àë' (a : Œ±), if b = f a then p a else 0 := by"
  },
  {
    "full_name": "LieHom.mem_idealRange",
    "file_path": "Mathlib/Algebra/Lie/Submodule.lean",
    "teorema": "theorem LieHom.mem_idealRange (L : Type v) (R : Type u) (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') (x : L) : f x ‚àà f.idealRange := by"
  },
  {
    "full_name": "SimpleGraph.map_singletonSubgraph",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean",
    "teorema": "lemma SimpleGraph.map_singletonSubgraph (G : SimpleGraph V) (V : Type u) (f : G ‚Üíg G') (v : V) : Subgraph.map f (G.singletonSubgraph v) = G'.singletonSubgraph (f v) := by"
  },
  {
    "full_name": "Int.even_iff_not_odd",
    "file_path": "Mathlib/Algebra/Ring/Int.lean",
    "teorema": "theorem Int.even_iff_not_odd (n : ‚Ñ§) : Even n ‚Üî ¬¨Odd n := by"
  },
  {
    "full_name": "vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "theorem vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan (P : Type u_3) (V : Type u_2) (k : Type u_1) (p : P) (s : Set P) (v : V) : v +·µ• p ‚àà spanPoints k s := by"
  },
  {
    "full_name": "HasFDerivWithinAt.mul",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean",
    "teorema": "lemma HasFDerivWithinAt.mul (E : Type u_2) (c : E ‚Üí ùî∏') (d : E ‚Üí ùî∏') (s : Set E) (x : E) (ùî∏ : Type u_6) : HasFDerivWithinAt (fun y => c y * d y) (c x ‚Ä¢ d' + d x ‚Ä¢ c') s x := by"
  },
  {
    "full_name": "Polynomial.mirror_leadingCoeff",
    "file_path": "Mathlib/Algebra/Polynomial/Mirror.lean",
    "teorema": "lemma Polynomial.mirror_leadingCoeff (R : Type u_1) (p : R[X]) : p.mirror.leadingCoeff = p.trailingCoeff := by"
  },
  {
    "full_name": "AddCommGrp.asHom_injective",
    "file_path": "Mathlib/Algebra/Category/Grp/Basic.lean",
    "teorema": "theorem AddCommGrp.asHom_injective (G : AddCommGrp) (h : ‚ÜëG) (k : ‚ÜëG) : h = k := by"
  },
  {
    "full_name": "bernoulli'_one",
    "file_path": "Mathlib/NumberTheory/Bernoulli.lean",
    "teorema": "lemma bernoulli'_one : bernoulli' 1 = 1 / 2 := by"
  },
  {
    "full_name": "CategoryTheory.induct_on_objects",
    "file_path": "Mathlib/CategoryTheory/IsConnected.lean",
    "teorema": "lemma CategoryTheory.induct_on_objects (J : Type u‚ÇÅ) (j : J) (p : Set J) : j ‚àà p := by"
  },
  {
    "full_name": "CategoryTheory.MonoidalCategory.leftUnitor_inv_tensor_id",
    "file_path": "Mathlib/CategoryTheory/Monoidal/CoherenceLemmas.lean",
    "teorema": "theorem CategoryTheory.MonoidalCategory.leftUnitor_inv_tensor_id (C : Type u_1) (X : C) (Y : C) : (Œª_ X).inv ‚äó ùüô Y = (Œª_ (X ‚äó Y)).inv ‚â´ (Œ±_ (ùüô_ C) X Y).inv := by"
  },
  {
    "full_name": "DFinsupp.neLocus_zero_right",
    "file_path": "Mathlib/Data/DFinsupp/NeLocus.lean",
    "teorema": "lemma DFinsupp.neLocus_zero_right (N : Œ± ‚Üí Type u_2) (f : Œ†‚ÇÄ (a : Œ±), N a) (Œ± : Type u_1) : f.neLocus 0 = f.support := by"
  },
  {
    "full_name": "Ideal.le_toIdeal_homogeneousHull",
    "file_path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean",
    "teorema": "lemma Ideal.le_toIdeal_homogeneousHull (A : Type u_4) (I : Ideal A) (Œπ : Type u_1) (œÉ : Type u_2) (ùíú : Œπ ‚Üí œÉ) : I ‚â§ (homogeneousHull ùíú I).toIdeal := by"
  },
  {
    "full_name": "Fintype.prod_boole",
    "file_path": "Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean",
    "teorema": "lemma Fintype.prod_boole (p : Œπ ‚Üí Prop) (Œπ : Type u_1) : (‚àè i : Œπ, if p i then 1 else 0) = if ‚àÄ (i : Œπ), p i then 1 else 0 := by"
  },
  {
    "full_name": "LinearMap.range_rangeRestrict",
    "file_path": "Mathlib/Algebra/Module/Submodule/Range.lean",
    "teorema": "theorem LinearMap.range_rangeRestrict (M : Type u_6) (M‚ÇÇ : Type u_7) (R : Type u_1) (R‚ÇÇ : Type u_2) (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) : range f.rangeRestrict = ‚ä§ := by"
  },
  {
    "full_name": "Orientation.oangle_zero_right",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean",
    "teorema": "lemma Orientation.oangle_zero_right (V : Type u_1) (o : Orientation ‚Ñù V (Fin 2)) (x : V) : o.oangle x 0 = 0 := by"
  },
  {
    "full_name": "List.get_eq_iff",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "theorem List.get_eq_iff (l : List Œ±‚úù) (n : Fin l.length) (x : Œ±‚úù) : l.get n = x ‚Üî l.get? ‚Üën = some x := by"
  },
  {
    "full_name": "Matrix.mulVec_one",
    "file_path": "Mathlib/Data/Matrix/Basic.lean",
    "teorema": "theorem Matrix.mulVec_one (A : Matrix m n Œ±) (m : Type u_2) (n : Type u_3) (Œ± : Type v) : A *·µ• 1 = fun i => ‚àë j : n, A i j := by"
  },
  {
    "full_name": "Set.le_edist_of_le_infsep",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "teorema": "theorem Set.le_edist_of_le_infsep (d : ‚Ñù) (x : Œ±) (y : Œ±) (Œ± : Type u_1) : d ‚â§ dist x y := by"
  },
  {
    "full_name": "WeierstrassCurve.Œ¶_one",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "teorema": "lemma WeierstrassCurve.Œ¶_one (R : Type r) (W : WeierstrassCurve R) : W.Œ¶ 1 = X := by"
  },
  {
    "full_name": "FiniteField.pow_card",
    "file_path": "Mathlib/FieldTheory/Finite/Basic.lean",
    "teorema": "theorem FiniteField.pow_card (K : Type u_1) (a : K) : a ^ q = a := by"
  },
  {
    "full_name": "Zsqrtd.nonneg_mul",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "theorem Zsqrtd.nonneg_mul (w : ‚Ñï) (x : ‚Ñï) (y : ‚Ñï) (z : ‚Ñï) : ({ re := -‚Üëx, im := ‚Üëy } * { re := ‚Üëz, im := ‚Üëw }).Nonneg := by"
  },
  {
    "full_name": "equicontinuousAt_iff_range",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "theorem equicontinuousAt_iff_range (F : Œπ ‚Üí X ‚Üí Œ±) (X : Type u_3) (x‚ÇÄ : X) (Œ± : Type u_7) (Œπ : Type u_1) : EquicontinuousAt F x‚ÇÄ ‚Üî EquicontinuousAt Subtype.val x‚ÇÄ := by"
  },
  {
    "full_name": "Finsupp.iInf_ker_lapply_le_bot",
    "file_path": "Mathlib/LinearAlgebra/Finsupp.lean",
    "teorema": "theorem Finsupp.iInf_ker_lapply_le_bot : ‚®Ö a, ker (lapply a) ‚â§ ‚ä• := by"
  },
  {
    "full_name": "Path.truncate_self",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "teorema": "theorem Path.truncate_self (X : Type u_1) (a : X) (b : X) (t : ‚Ñù) (Œ≥ : Path a b) : Œ≥.extend (min t t) = Œ≥.extend t := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.map_addX",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.map_addX (F : Type v) (P : Fin 3 ‚Üí R) (Q : Fin 3 ‚Üí R) (R : Type u) (S : Type u_1) (W : Jacobian F) (f : R ‚Üí+* S) : addX (map W' f) (‚áëf ‚àò P) (‚áëf ‚àò Q) = f (W'.addX P Q) := by"
  },
  {
    "full_name": "Set.ncard_le_one_iff",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "lemma Set.ncard_le_one_iff (s : Set Œ±) (Œ± : Type u_1) : s.ncard ‚â§ 1 ‚Üî ‚àÄ {a b : Œ±}, a ‚àà s ‚Üí b ‚àà s ‚Üí a = b := by"
  },
  {
    "full_name": "NNReal.tendsto_rpow_atTop",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean",
    "teorema": "theorem NNReal.tendsto_rpow_atTop (y : ‚Ñù) : Tendsto (fun x => x ^ y) atTop atTop := by"
  },
  {
    "full_name": "pcontinuous_iff'",
    "file_path": "Mathlib/Topology/Partial.lean",
    "teorema": "theorem pcontinuous_iff' (X : Type u_1) (Y : Type u_2) (f : X ‚Üí. Y) : PContinuous f ‚Üî ‚àÄ {x : X} {y : Y}, y ‚àà f x ‚Üí PTendsto' f (ùìù x) (ùìù y) := by"
  },
  {
    "full_name": "Matrix.det_nonsing_inv_mul_det",
    "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
    "teorema": "theorem Matrix.det_nonsing_inv_mul_det (A : Matrix n n Œ±) (n : Type u') (Œ± : Type v) : A‚Åª¬π.det * A.det = 1 := by"
  },
  {
    "full_name": "Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "lemma Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous (f : Œ≤ ‚Üí Œ±) (Œ± : Type u_7) (Œ≤ : Type u_9) : UniformContinuous f := by"
  },
  {
    "full_name": "List.range_eq_range'",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "theorem List.range_eq_range' (n : Nat) : range' 0 (0 + n) = range' 0 n := by"
  },
  {
    "full_name": "List.mem_mem_ranges_iff_lt_natSum",
    "file_path": "Mathlib/Data/List/Range.lean",
    "teorema": "lemma List.mem_mem_ranges_iff_lt_natSum (l : List ‚Ñï) (n : ‚Ñï) : (‚àÉ s ‚àà l.ranges, n ‚àà s) ‚Üî n < Nat.sum l := by"
  },
  {
    "full_name": "Ordinal.fp_family_unbounded",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "teorema": "lemma Ordinal.fp_family_unbounded (a : Ordinal.{max u v}) (f : Œπ ‚Üí Ordinal.{max u v} ‚Üí Ordinal.{max u v}) (s : Set Ordinal.{max u v}) (Œπ : Type u) : nfpFamily f a ‚àà s := by"
  },
  {
    "full_name": "Field.primitive_element_inf_aux_of_finite_intermediateField",
    "file_path": "Mathlib/FieldTheory/PrimitiveElement.lean",
    "teorema": "lemma Field.primitive_element_inf_aux_of_finite_intermediateField (E : Type u_2) (F : Type u_1) (Œ± : E) (Œ≤ : E) : ‚àÉ Œ≥, F‚üÆŒ±, Œ≤‚üØ = F‚üÆŒ≥‚üØ := by"
  },
  {
    "full_name": "antilipschitzWith_lineMap",
    "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean",
    "teorema": "theorem antilipschitzWith_lineMap (Q : Type u_5) (c‚ÇÅ : ùïú) (c‚ÇÇ : ùïú) (p‚ÇÅ : Q) (p‚ÇÇ : Q) (ùïú : Type u_6) : dist c‚ÇÅ c‚ÇÇ ‚â§ ‚Üë(nndist p‚ÇÅ p‚ÇÇ)‚Åª¬π * dist ((lineMap p‚ÇÅ p‚ÇÇ) c‚ÇÅ) ((lineMap p‚ÇÅ p‚ÇÇ) c‚ÇÇ) := by"
  },
  {
    "full_name": "exists_setIndependent_isCompl_sSup_atoms",
    "file_path": "Mathlib/Order/CompactlyGenerated/Basic.lean",
    "teorema": "theorem exists_setIndependent_isCompl_sSup_atoms (b : Œ±) (Œ± : Type u_2) : ‚àÉ s, CompleteLattice.SetIndependent s ‚àß IsCompl b (sSup s) ‚àß ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà s ‚Üí IsAtom a := by"
  },
  {
    "full_name": "sub_div_sub_smul_slope_add_sub_div_sub_smul_slope",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean",
    "teorema": "theorem sub_div_sub_smul_slope_add_sub_div_sub_smul_slope (PE : Type u_3) (a : k) (b : k) (c : k) (f : k ‚Üí PE) (k : Type u_1) : ((b - a) / (c - a)) ‚Ä¢ slope f a b + ((c - b) / (c - a)) ‚Ä¢ slope f b c = slope f a c := by"
  },
  {
    "full_name": "Besicovitch.SatelliteConfig.exists_normalized_aux1",
    "file_path": "Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean",
    "teorema": "theorem Besicovitch.SatelliteConfig.exists_normalized_aux1 (E : Type u_1) (N : ‚Ñï) (a : SatelliteConfig E N œÑ) (i : Fin N.succ) (j : Fin N.succ) (Œ¥ : ‚Ñù) (œÑ : ‚Ñù) : 1 - Œ¥ ‚â§ ‚Äña.c i - a.c j‚Äñ := by"
  },
  {
    "full_name": "rightCoset_mem_rightCoset",
    "file_path": "Mathlib/GroupTheory/Coset.lean",
    "teorema": "lemma rightCoset_mem_rightCoset (a : Œ±) (b : Œ±) (s : Subgroup Œ±) (Œ± : Type u_1) : b ‚àà op a ‚Ä¢ ‚Üës ‚Üî b ‚àà ‚Üës := by"
  },
  {
    "full_name": "EuclideanGeometry.orthogonalProjection_mem_subspace_eq_self",
    "file_path": "Mathlib/Geometry/Euclidean/Basic.lean",
    "teorema": "theorem EuclideanGeometry.orthogonalProjection_mem_subspace_eq_self (P : Type u_2) (p : ‚Ü•s) (s : AffineSubspace ‚Ñù P) : (orthogonalProjection s) ‚Üëp = p := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.add_measure",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.Integrable.add_measure (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) (ŒΩ : Measure Œ±) : Integrable f (Œº + ŒΩ) := by"
  },
  {
    "full_name": "Function.update_idem",
    "file_path": "Mathlib/Logic/Function/Basic.lean",
    "teorema": "theorem Function.update_idem (a : Œ±) (f : (a : Œ±) ‚Üí Œ≤ a) (v : Œ≤ a) (w : Œ≤ a) (Œ± : Sort u_2) (Œ≤ : Œ± ‚Üí Sort u_1) : update (update f a v) a w = update f a w := by"
  },
  {
    "full_name": "Ordinal.one_lt_omega",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "lemma Ordinal.one_lt_omega : 1 < œâ := by"
  },
  {
    "full_name": "CategoryTheory.FintypeCat.Action.pretransitive_of_isConnected",
    "file_path": "Mathlib/CategoryTheory/Galois/Examples.lean",
    "teorema": "lemma CategoryTheory.FintypeCat.Action.pretransitive_of_isConnected (G : Type u) (X : Action FintypeCat (MonCat.of G)) (x : ‚ÜëX.V) (y : ‚ÜëX.V) : ‚àÉ g, g ‚Ä¢ x = y := by"
  },
  {
    "full_name": "MeasureTheory.addContent_union_le",
    "file_path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
    "teorema": "theorem MeasureTheory.addContent_union_le (C : Set (Set Œ±)) (m : AddContent C) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) : m (s ‚à™ t) ‚â§ m s + m t := by"
  },
  {
    "full_name": "Set.countable_pi",
    "file_path": "Mathlib/Data/Set/Countable.lean",
    "teorema": "theorem Set.countable_pi (s : (a : Œ±) ‚Üí Set (œÄ a)) (Œ± : Type u) (œÄ : Œ± ‚Üí Type u_1) : {f | ‚àÄ (a : Œ±), f a ‚àà s a}.Countable := by"
  },
  {
    "full_name": "LieAlgebra.IsSemisimple.isSimple_of_isAtom",
    "file_path": "Mathlib/Algebra/Lie/Semisimple/Basic.lean",
    "teorema": "lemma LieAlgebra.IsSemisimple.isSimple_of_isAtom (I : LieIdeal R L) (L : Type u_2) (R : Type u_1) : ‚àÄ (I_1 : LieIdeal R ‚Ü•‚ÜëI), I_1 = ‚ä• ‚à® I_1 = ‚ä§ := by"
  },
  {
    "full_name": "Projectivization.Subspace.span_eq_sInf",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Subspace.lean",
    "teorema": "lemma Projectivization.Subspace.span_eq_sInf (K : Type u_1) (S : Set (‚Ñô K V)) (V : Type u_2) : span S = sInf {W | S ‚äÜ ‚ÜëW} := by"
  },
  {
    "full_name": "isConformalMap_complex_linear",
    "file_path": "Mathlib/Analysis/Complex/Conformal.lean",
    "teorema": "theorem isConformalMap_complex_linear (E : Type u_1) (map : ‚ÑÇ ‚ÜíL[‚ÑÇ] E) : IsConformalMap (restrictScalars ‚Ñù map) := by"
  },
  {
    "full_name": "LucasLehmer.sMod_lt",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "teorema": "lemma LucasLehmer.sMod_lt (i : ‚Ñï) (p : ‚Ñï) : sMod p i < 2 ^ p - 1 := by"
  },
  {
    "full_name": "ZFSet.toSet_sdiff",
    "file_path": "Mathlib/SetTheory/ZFC/Basic.lean",
    "teorema": "theorem ZFSet.toSet_sdiff (x : ZFSet) (y : ZFSet) : (x \\ y).toSet = x.toSet \\ y.toSet := by"
  },
  {
    "full_name": "ContinuousLinearMap.zero_comp",
    "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean",
    "teorema": "lemma ContinuousLinearMap.zero_comp (M‚ÇÅ : Type u_4) (M‚ÇÇ : Type u_6) (R‚ÇÅ : Type u_1) (R‚ÇÇ : Type u_2) (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ) : comp 0 f = 0 := by"
  },
  {
    "full_name": "Filter.eventually_prod_self_iff",
    "file_path": "Mathlib/Order/Filter/Bases.lean",
    "teorema": "theorem Filter.eventually_prod_self_iff (la : Filter Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : (‚àÉ t ‚àà la, t √óÀ¢ t ‚äÜ {x | (fun x => r x.1 x.2) x}) ‚Üî ‚àÉ t ‚àà la, ‚àÄ x ‚àà t, ‚àÄ y ‚àà t, r x y := by"
  },
  {
    "full_name": "PiTensorProduct.nonempty_lifts",
    "file_path": "Mathlib/LinearAlgebra/PiTensorProduct.lean",
    "teorema": "theorem PiTensorProduct.nonempty_lifts (R : Type u_4) (s : Œπ ‚Üí Type u_7) (x : ‚®Ç[R] (i : Œπ), s i) (Œπ : Type u_1) : x.lifts.Nonempty := by"
  },
  {
    "full_name": "Complex.tan_mul_I",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.tan_mul_I (x : ‚ÑÇ) : tan (x * I) = tanh x * I := by"
  },
  {
    "full_name": "IsBezout.gcd_dvd_left",
    "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean",
    "teorema": "lemma IsBezout.gcd_dvd_left (R : Type u) (x : R) (y : R) : x ‚àà {x, y} := by"
  },
  {
    "full_name": "Matrix.sub_mulVec",
    "file_path": "Mathlib/Data/Matrix/Basic.lean",
    "teorema": "lemma Matrix.sub_mulVec (A : Matrix m n Œ±) (B : Matrix m n Œ±) (m : Type u_2) (n : Type u_3) (x : n ‚Üí Œ±) (Œ± : Type v) : (A - B) *·µ• x = A *·µ• x - B *·µ• x := by"
  },
  {
    "full_name": "IsSelfAdjoint.neg_algebraMap_norm_le_self",
    "file_path": "Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Order.lean",
    "teorema": "theorem IsSelfAdjoint.neg_algebraMap_norm_le_self (A : Type u_1) (a : A) : -(algebraMap ‚Ñù A) ‚Äña‚Äñ ‚â§ a := by"
  },
  {
    "full_name": "MeasureTheory.Measure.compProd_apply_prod",
    "file_path": "Mathlib/Probability/Kernel/MeasureCompProd.lean",
    "teorema": "theorem MeasureTheory.Measure.compProd_apply_prod (s : Set Œ±) (t : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ∫ : ‚Ü•(kernel Œ± Œ≤)) (Œº : Measure Œ±) : (Œº ‚äó‚Çò Œ∫) (s √óÀ¢ t) = ‚à´‚Åª (a : Œ±) in s, (Œ∫ a) t ‚àÇŒº := by"
  },
  {
    "full_name": "Rat.neg_normalize",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.neg_normalize (d : Nat) (n : Int) (z : d ‚â† 0) : -normalize n d z = normalize (-n) d z := by"
  },
  {
    "full_name": "QPF.recF_eq_of_Wequiv",
    "file_path": "Mathlib/Data/QPF/Univariate/Basic.lean",
    "teorema": "theorem QPF.recF_eq_of_Wequiv (F : Type u ‚Üí Type u) (u : F Œ± ‚Üí Œ±) (x : (P F).W) (y : (P F).W) (Œ± : Type u) : Wequiv x y ‚Üí recF u x = recF u y := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.id_homMap",
    "file_path": "Mathlib/CategoryTheory/Localization/HomEquiv.lean",
    "teorema": "theorem CategoryTheory.LocalizerMorphism.id_homMap (C‚ÇÅ : Type u_2) (D‚ÇÅ : Type u_5) (L‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (W‚ÇÅ : MorphismProperty C‚ÇÅ) (X : C‚ÇÅ) (Y : C‚ÇÅ) (f : L‚ÇÅ.obj X ‚ü∂ L‚ÇÅ.obj Y) : (id W‚ÇÅ).homMap L‚ÇÅ L‚ÇÅ f = f := by"
  },
  {
    "full_name": "Complex.tsum_exp_neg_mul_int_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean",
    "teorema": "theorem Complex.tsum_exp_neg_mul_int_sq (a : ‚ÑÇ) : ‚àë' (n : ‚Ñ§), cexp (-‚ÜëœÄ * a * ‚Üën ^ 2) = 1 / a ^ (1 / 2) * ‚àë' (n : ‚Ñ§), cexp (-‚ÜëœÄ / a * ‚Üën ^ 2) := by"
  },
  {
    "full_name": "Nat.gcd_add_mul_right_right",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "teorema": "theorem Nat.gcd_add_mul_right_right (k : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) : m.gcd (n + k * m) = m.gcd n := by"
  },
  {
    "full_name": "affineSpan_singleton_union_vadd_eq_top_of_span_eq_top",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "lemma affineSpan_singleton_union_vadd_eq_top_of_span_eq_top (P : Type u_3) (V : Type u_2) (k : Type u_1) (p : P) (s : Set V) : affineSpan k ({p} ‚à™ (fun v => v +·µ• p) '' s) = ‚ä§ := by"
  },
  {
    "full_name": "MeasureTheory.pdf.lintegral_eq_measure_univ",
    "file_path": "Mathlib/Probability/Density.lean",
    "teorema": "theorem MeasureTheory.pdf.lintegral_eq_measure_univ (E : Type u_2) (X : Œ© ‚Üí E) (Œ© : Type u_1) (Œº : Measure E) (‚Ñô : Measure Œ©) : ‚à´‚Åª (x : E), pdf X ‚Ñô Œº x ‚àÇŒº = ‚Ñô Set.univ := by"
  },
  {
    "full_name": "CochainComplex.HomComplex.Cochain.id_comp",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean",
    "teorema": "lemma CochainComplex.HomComplex.Cochain.id_comp (C : Type u) (F : CochainComplex C ‚Ñ§) (G : CochainComplex C ‚Ñ§) (n : ‚Ñ§) (z‚ÇÇ : Cochain F G n) : (ofHom (ùüô F)).comp z‚ÇÇ ‚ãØ = z‚ÇÇ := by"
  },
  {
    "full_name": "Finset.val_eq_singleton_iff",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "theorem Finset.val_eq_singleton_iff (a : Œ±) (s : Finset Œ±) (Œ± : Type u_1) : s.val = {a} ‚Üî s = {a} := by"
  },
  {
    "full_name": "BooleanAlgebra.le_iff_atom_le_imp",
    "file_path": "Mathlib/Order/Atoms.lean",
    "teorema": "lemma BooleanAlgebra.le_iff_atom_le_imp (x : Œ±) (y : Œ±) (Œ± : Type u_4) : x ‚â§ y := by"
  },
  {
    "full_name": "Zsqrtd.dmuld",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "lemma Zsqrtd.dmuld (d : ‚Ñ§) : sqrtd * sqrtd = ‚Üëd := by"
  },
  {
    "full_name": "round_neg_two_inv",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem round_neg_two_inv : round (-2‚Åª¬π) = 0 := by"
  },
  {
    "full_name": "TensorProduct.toDirectLimit_tmul_of",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/DirectLimit.lean",
    "teorema": "lemma TensorProduct.toDirectLimit_tmul_of (G : Œπ ‚Üí Type u_3) (M : Type u_4) (R : Type u_1) (f : (i j : Œπ) ‚Üí i ‚â§ j ‚Üí G i ‚Üí‚Çó[R] G j) (g : G i) (i : Œπ) (m : M) (Œπ : Type u_2) : (toDirectLimit f M) ((of R Œπ G f i) g ‚äó‚Çú[R] m) = (of R Œπ (fun x => G x ‚äó[R] M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (g ‚äó‚Çú[R] m) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.Œπ_colimitConstInitial_hom",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean",
    "teorema": "theorem CategoryTheory.Limits.Œπ_colimitConstInitial_hom (C : Type u_2) (J : Type u_1) (j : J) : colimit.Œπ ((Functor.const J).obj (‚ä•_ C)) j ‚â´ colimitConstInitial.hom = initial.to (‚ä•_ C) := by"
  },
  {
    "full_name": "Submodule.map_op_mul",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "theorem Submodule.map_op_mul (A : Type v) (M : Submodule R A) (N : Submodule R A) (R : Type u) : map (‚Üë(opLinearEquiv R)) (M * N) = map (‚Üë(opLinearEquiv R)) N * map (‚Üë(opLinearEquiv R)) M := by"
  },
  {
    "full_name": "CategoryTheory.Limits.biprod.isoProd_hom",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean",
    "teorema": "theorem CategoryTheory.Limits.biprod.isoProd_hom (C : Type u) (X : C) (Y : C) : (isoProd X Y).hom = prod.lift fst snd := by"
  },
  {
    "full_name": "CategoryTheory.Discrete.natIso_app",
    "file_path": "Mathlib/CategoryTheory/DiscreteCategory.lean",
    "teorema": "lemma CategoryTheory.Discrete.natIso_app (C : Type u‚ÇÇ) (F : Discrete I ‚•§ C) (G : Discrete I ‚•§ C) (I : Type u‚ÇÅ) (f : (i : Discrete I) ‚Üí F.obj i ‚âÖ G.obj i) (i : Discrete I) : (natIso f).app i = f i := by"
  },
  {
    "full_name": "Part.inv_mem_inv",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.inv_mem_inv (a : Part Œ±) (ma : Œ±) (Œ± : Type u_1) : ma‚Åª¬π ‚àà a‚Åª¬π := by"
  },
  {
    "full_name": "Int.fract_sub_nat",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Int.fract_sub_nat (a : Œ±) (n : ‚Ñï) (Œ± : Type u_2) : fract (a - ‚Üën) = fract a := by"
  },
  {
    "full_name": "AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.lift_uniq",
    "file_path": "Mathlib/Geometry/RingedSpace/OpenImmersion.lean",
    "teorema": "theorem AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.lift_uniq (C : Type u) (H : Set.range ‚áëg.base ‚äÜ Set.range ‚áëf.base) (X : PresheafedSpace C) (Y : PresheafedSpace C) (Z : PresheafedSpace C) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (l : Y ‚ü∂ X) : l = lift f g H := by"
  },
  {
    "full_name": "Filter.Tendsto.of_tendsto_comp",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.Tendsto.of_tendsto_comp (a : Filter Œ±) (b : Filter Œ≤) (f : Œ± ‚Üí Œ≤) (Œ± : Type u) (Œ≤ : Type v) : Tendsto f a b := by"
  },
  {
    "full_name": "Polynomial.eval_comp",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "lemma Polynomial.eval_comp (R : Type u) (p : R[X]) (q : R[X]) (x : R) : eval x (p.comp q) = eval (eval x q) p := by"
  },
  {
    "full_name": "LinearMap.adjoint_adjoint",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Adjoint.lean",
    "teorema": "lemma LinearMap.adjoint_adjoint (A : E ‚Üí‚Çó[ùïú] F) (E : Type u_2) (F : Type u_3) (ùïú : Type u_1) : adjoint (adjoint A) = A := by"
  },
  {
    "full_name": "contDiff_top_iff_deriv",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "theorem contDiff_top_iff_deriv (F : Type uF) (f‚ÇÇ : ùïú ‚Üí F) (ùïú : Type u_1) : ContDiff ùïú ‚ä§ f‚ÇÇ ‚Üî Differentiable ùïú f‚ÇÇ ‚àß ContDiff ùïú ‚ä§ (deriv f‚ÇÇ) := by"
  },
  {
    "full_name": "WeierstrassCurve.Œ®Sq_odd",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "teorema": "theorem WeierstrassCurve.Œ®Sq_odd (R : Type r) (W : WeierstrassCurve R) (m : ‚Ñï) : W.Œ®Sq (2 * (‚Üëm + 2) + 1) = ((W.preŒ®' (m + 4) * W.preŒ®' (m + 2) ^ 3 * if Even m then W.Œ®‚ÇÇSq ^ 2 else 1) - W.preŒ®' (m + 1) * W.preŒ®' (m + 3) ^ 3 * if Even m then 1 else W.Œ®‚ÇÇSq ^ 2) ^ 2 := by"
  },
  {
    "full_name": "ProbabilityTheory.IdentDistrib.evariance_eq",
    "file_path": "Mathlib/Probability/IdentDistrib.lean",
    "teorema": "theorem ProbabilityTheory.IdentDistrib.evariance_eq (f : Œ± ‚Üí ‚Ñù) (g : Œ≤ ‚Üí ‚Ñù) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) (ŒΩ : Measure Œ≤) : evariance f Œº = evariance g ŒΩ := by"
  },
  {
    "full_name": "Basis.sumCoords_reindex",
    "file_path": "Mathlib/LinearAlgebra/Basis.lean",
    "teorema": "theorem Basis.sumCoords_reindex (M : Type u_6) (R : Type u_3) (b : Basis Œπ R M) (e : Œπ ‚âÉ Œπ') (Œπ : Type u_1) : (b.reindex e).sumCoords = b.sumCoords := by"
  },
  {
    "full_name": "Monoid.exponent_dvd",
    "file_path": "Mathlib/GroupTheory/Exponent.lean",
    "teorema": "theorem Monoid.exponent_dvd (G : Type u) (n : ‚Ñï) : exponent G ‚à£ n ‚Üî ‚àÄ (g : G), orderOf g ‚à£ n := by"
  },
  {
    "full_name": "JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup",
    "file_path": "Mathlib/Order/JordanHolder.lean",
    "teorema": "theorem JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup (X : Type u) (x : X) (y : X) : IsMaximal (x ‚äì y) y := by"
  },
  {
    "full_name": "FirstOrder.Language.LHom.setOf_realize_onFormula",
    "file_path": "Mathlib/ModelTheory/Semantics.lean",
    "teorema": "lemma FirstOrder.Language.LHom.setOf_realize_onFormula (L : Language) (Œ± : Type u') (œÜ : L ‚Üí·¥∏ L') (œà : L.Formula Œ±) : setOf (œÜ.onFormula œà).Realize = setOf œà.Realize := by"
  },
  {
    "full_name": "Collinear.oangle_sign_of_sameRay_vsub",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean",
    "teorema": "lemma Collinear.oangle_sign_of_sameRay_vsub (P : Type u_2) (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) (p‚ÇÖ : P) : (‚à° p‚ÇÅ p‚ÇÖ p‚ÇÇ).sign = (‚à° p‚ÇÉ p‚ÇÖ p‚ÇÑ).sign := by"
  },
  {
    "full_name": "MeasureTheory.Measure.InnerRegularWRT.of_restrict",
    "file_path": "Mathlib/MeasureTheory/Measure/Regular.lean",
    "teorema": "lemma MeasureTheory.Measure.InnerRegularWRT.of_restrict (p : Set Œ± ‚Üí Prop) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº.InnerRegularWRT p MeasurableSet := by"
  },
  {
    "full_name": "Finset.sum_nat_mod",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "lemma Finset.sum_nat_mod (f : Œ± ‚Üí ‚Ñï) (n : ‚Ñï) (s : Finset Œ±) (Œ± : Type u_3) : (Multiset.map (fun x => x % n) (Multiset.map (fun i => f i) s.val)).sum % n = (‚àë i ‚àà s, f i % n) % n := by"
  },
  {
    "full_name": "Associates.dvdNotUnit_of_lt",
    "file_path": "Mathlib/Algebra/Associated.lean",
    "teorema": "theorem Associates.dvdNotUnit_of_lt (a : Associates Œ±) (b : Associates Œ±) (Œ± : Type u_1) : DvdNotUnit a b := by"
  },
  {
    "full_name": "exists_maximal_orthonormal",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
    "teorema": "lemma exists_maximal_orthonormal (E : Type u_2) (s : Set E) (ùïú : Type u_1) : ‚àÉ w ‚äá s, Orthonormal ùïú Subtype.val ‚àß ‚àÄ u ‚äá w, Orthonormal ùïú Subtype.val ‚Üí u = w := by"
  },
  {
    "full_name": "mem_segment_translate",
    "file_path": "Mathlib/Analysis/Convex/Segment.lean",
    "teorema": "lemma mem_segment_translate (E : Type u_2) (a : E) (b : E) (c : E) (x : E) (ùïú : Type u_1) : a + x ‚àà [a + b-[ùïú]a + c] ‚Üî x ‚àà [b-[ùïú]c] := by"
  },
  {
    "full_name": "IsBoundedLinearMap.snd",
    "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean",
    "teorema": "theorem IsBoundedLinearMap.snd (ùïú : Type u_1) : IsBoundedLinearMap ùïú fun x => x.2 := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.measure_le_lt_top",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "theorem MeasureTheory.Integrable.measure_le_lt_top (c : ‚Ñù) (f : Œ± ‚Üí ‚Ñù) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº {a | f a ‚â§ c} < ‚ä§ := by"
  },
  {
    "full_name": "HasDerivWithinAt.norm_sq",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Calculus.lean",
    "teorema": "theorem HasDerivWithinAt.norm_sq (F : Type u_3) (f : ‚Ñù ‚Üí F) (s : Set ‚Ñù) (x : ‚Ñù) : HasDerivWithinAt (fun x => ‚Äñf x‚Äñ ^ 2) (2 * ‚ü™f x, f'‚ü´_‚Ñù) s x := by"
  },
  {
    "full_name": "FiniteDimensional.finrank_pi",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Constructions.lean",
    "teorema": "lemma FiniteDimensional.finrank_pi (R : Type u) (Œπ : Type v) : finrank R (Œπ ‚Üí R) = Fintype.card Œπ := by"
  },
  {
    "full_name": "isOpenMap_eval",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "lemma isOpenMap_eval (i : Œπ) (Œπ : Type u_1) : IsOpenMap (eval i) := by"
  },
  {
    "full_name": "tsum_sq_fourierCoeff",
    "file_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
    "teorema": "theorem tsum_sq_fourierCoeff (T : ‚Ñù) (f : ‚Ü•(Lp ‚ÑÇ 2 haarAddCircle)) : ‚àë' (i : ‚Ñ§), ‚ÄñfourierCoeff (‚Üë‚Üëf) i‚Äñ ^ 2 = ‚à´ (t : AddCircle T), ‚Äñ‚Üë‚Üëf t‚Äñ ^ 2 ‚àÇhaarAddCircle := by"
  },
  {
    "full_name": "GaussianInt.natCast_natAbs_norm",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
    "teorema": "lemma GaussianInt.natCast_natAbs_norm (x : ‚Ñ§[i]) : ‚Üë(norm x).natAbs = ‚Üë(norm x) := by"
  },
  {
    "full_name": "Basis.mem_submodule_iff'",
    "file_path": "Mathlib/LinearAlgebra/Basis.lean",
    "teorema": "lemma Basis.mem_submodule_iff' (M : Type u_6) (P : Submodule R M) (R : Type u_3) (b : Basis Œπ R ‚Ü•P) (c : Œπ ‚Üí R) (x : M) (Œπ : Type u_1) : (x = (Finsupp.equivFunOnFinite.symm c).sum fun i x => x ‚Ä¢ ‚Üë(b i)) ‚Üî x = ‚àë i : Œπ, c i ‚Ä¢ ‚Üë(b i) := by"
  },
  {
    "full_name": "variationOnFromTo.monotoneOn",
    "file_path": "Mathlib/Analysis/BoundedVariation.lean",
    "teorema": "lemma variationOnFromTo.monotoneOn (E : Type u_2) (a : Œ±) (f : Œ± ‚Üí E) (s : Set Œ±) (Œ± : Type u_1) : MonotoneOn (variationOnFromTo f s a) s := by"
  },
  {
    "full_name": "List.length_sigma",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "theorem List.length_sigma (l‚ÇÅ : List Œ±) (l‚ÇÇ : (a : Œ±) ‚Üí List (œÉ a)) (Œ± : Type u_2) (œÉ : Œ± ‚Üí Type u_8) : (l‚ÇÅ.sigma l‚ÇÇ).length = (map (fun a => (l‚ÇÇ a).length) l‚ÇÅ).sum := by"
  },
  {
    "full_name": "Polynomial.smeval_comp",
    "file_path": "Mathlib/Algebra/Polynomial/Smeval.lean",
    "teorema": "lemma Polynomial.smeval_comp (R : Type u_1) (S : Type u_2) (p : R[X]) (q : R[X]) (x : S) : (p.comp q).smeval x = p.smeval (q.smeval x) := by"
  },
  {
    "full_name": "Option.map_bind'",
    "file_path": "Mathlib/Data/Option/Basic.lean",
    "teorema": "lemma Option.map_bind' (f : Œ≤ ‚Üí Œ≥) (g : Œ± ‚Üí Option Œ≤) (x : Option Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : Option.map f (x.bind g) = x.bind fun a => Option.map f (g a) := by"
  },
  {
    "full_name": "SimpleGraph.cliqueFinset_map_of_equiv",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "teorema": "theorem SimpleGraph.cliqueFinset_map_of_equiv (G : SimpleGraph Œ±) (e : Œ± ‚âÉ Œ≤) (n : ‚Ñï) (Œ± : Type u_1) (Œ≤ : Type u_2) : ‚Üë((SimpleGraph.map e.toEmbedding G).cliqueFinset n) = := by"
  },
  {
    "full_name": "Submonoid.LocalizationMap.eq_iff_exists",
    "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean",
    "teorema": "theorem Submonoid.LocalizationMap.eq_iff_exists (M : Type u_1) (N : Type u_2) (S : Submonoid M) (f : S.LocalizationMap N) (x : M) (y : M) : f.toMap x = f.toMap y := by"
  },
  {
    "full_name": "Set.Intersecting.exists_card_eq",
    "file_path": "Mathlib/Combinatorics/SetFamily/Intersecting.lean",
    "teorema": "theorem Set.Intersecting.exists_card_eq (s : Finset Œ±) (Œ± : Type u_1) : ‚àÉ t, s ‚äÜ t ‚àß 2 * t.card = Fintype.card Œ± ‚àß (‚Üët).Intersecting := by"
  },
  {
    "full_name": "Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean",
    "teorema": "lemma Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint (P : Type u_3) (b : P) (k : Type u_1) (p‚ÇÅ : P) (p‚ÇÇ : Œπ ‚Üí P) (s : Finset Œπ) (w : Œπ ‚Üí k) (Œπ : Type u_4) : ‚àë i ‚àà s, w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i) = (‚àë i ‚àà s, w i) ‚Ä¢ (p‚ÇÅ -·µ• b) - (s.weightedVSubOfPoint p‚ÇÇ b) w := by"
  },
  {
    "full_name": "MeasurableSpace.cardinal_generateMeasurable_le_continuum",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Card.lean",
    "teorema": "lemma MeasurableSpace.cardinal_generateMeasurable_le_continuum (s : Set (Set Œ±)) (Œ± : Type u) : max (#‚Üës) 2 ^ ‚Ñµ‚ÇÄ ‚â§ ùî† := by"
  },
  {
    "full_name": "Fin.coe_of_injective_castLE_symm",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.coe_of_injective_castLE_symm (h : n ‚â§ k) (hi : i ‚àà Set.range (castLE h)) (i : Fin k) (k : ‚Ñï) (n : ‚Ñï) : ‚Üë((Equiv.ofInjective (castLE h) ‚ãØ).symm ‚ü®i, hi‚ü©) = ‚Üëi := by"
  },
  {
    "full_name": "cfc_inv_id",
    "file_path": "Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean",
    "teorema": "lemma cfc_inv_id (a : AÀ£) : cfc (fun x => x‚Åª¬π) ‚Üëa = ‚Üëa‚Åª¬π := by"
  },
  {
    "full_name": "summable_of_ratio_norm_eventually_le",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "theorem summable_of_ratio_norm_eventually_le (f : ‚Ñï ‚Üí Œ±) (Œ± : Type u_4) : Summable f := by"
  },
  {
    "full_name": "CategoryTheory.whisker_eq",
    "file_path": "Mathlib/CategoryTheory/Category/Basic.lean",
    "teorema": "theorem CategoryTheory.whisker_eq (C : Type u) (X : C) (Y : C) (Z : C) (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : Y ‚ü∂ Z) : f ‚â´ g = f ‚â´ h := by"
  },
  {
    "full_name": "IntermediateField.AdjoinSimple.norm_gen_eq_one",
    "file_path": "Mathlib/RingTheory/Norm.lean",
    "teorema": "lemma IntermediateField.AdjoinSimple.norm_gen_eq_one (K : Type u_4) (L : Type u_5) (x : L) : (norm K) (AdjoinSimple.gen K x) = 1 := by"
  },
  {
    "full_name": "List.permutationsAux2_fst",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "teorema": "theorem List.permutationsAux2_fst (f : List Œ± ‚Üí Œ≤) (r : List Œ≤) (t : Œ±) (ts : List Œ±) (y : Œ±) (ys : List Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : (permutationsAux2 t ts r (y :: ys) f).1 = y :: ys ++ ts := by"
  },
  {
    "full_name": "Set.image_iUnion‚ÇÇ",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "lemma Set.image_iUnion‚ÇÇ (f : Œ± ‚Üí Œ≤) (s : (i : Œπ) ‚Üí Œ∫ i ‚Üí Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œπ : Sort u_4) (Œ∫ : Œπ ‚Üí Sort u_7) : f '' ‚ãÉ i, ‚ãÉ j, s i j = ‚ãÉ i, ‚ãÉ j, f '' s i j := by"
  },
  {
    "full_name": "Int.preimage_Ioc",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Int.preimage_Ioc (a : Œ±) (b : Œ±) (Œ± : Type u_2) : Int.cast ‚Åª¬π' Ioc a b = Ioc ‚åäa‚åã ‚åäb‚åã := by"
  },
  {
    "full_name": "EuclideanGeometry.two_zsmul_oangle_of_vectorSpan_eq",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean",
    "teorema": "lemma EuclideanGeometry.two_zsmul_oangle_of_vectorSpan_eq (P : Type u_2) (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) (p‚ÇÖ : P) (p‚ÇÜ : P) : 2 ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÇ p‚ÇÉ = 2 ‚Ä¢ ‚à° p‚ÇÑ p‚ÇÖ p‚ÇÜ := by"
  },
  {
    "full_name": "Matrix.frobenius_nnnorm_diagonal",
    "file_path": "Mathlib/Analysis/Matrix.lean",
    "teorema": "lemma Matrix.frobenius_nnnorm_diagonal (n : Type u_4) (v : n ‚Üí Œ±) (Œ± : Type u_5) : ‚Äñdiagonal v‚Äñ‚Çä = ‚Äñ(WithLp.equiv 2 (n ‚Üí Œ±)).symm v‚Äñ‚Çä := by"
  },
  {
    "full_name": "LieModule.Weight.ext_iff",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "theorem LieModule.Weight.ext_iff (L : Type u_3) (M : Type u_4) (R : Type u_2) (œá‚ÇÅ : Weight R L M) (œá‚ÇÇ : Weight R L M) : ‚áëœá‚ÇÅ = ‚áëœá‚ÇÇ ‚Üî œá‚ÇÅ = œá‚ÇÇ := by"
  },
  {
    "full_name": "NoZeroSMulDivisors.trans",
    "file_path": "Mathlib/Algebra/Algebra/Basic.lean",
    "teorema": "theorem NoZeroSMulDivisors.trans (M : Type u_7) (R : Type u_5) : NoZeroSMulDivisors R M := by"
  },
  {
    "full_name": "CategoryTheory.Subobject.ofLEMk_comp",
    "file_path": "Mathlib/CategoryTheory/Subobject/Basic.lean",
    "teorema": "lemma CategoryTheory.Subobject.ofLEMk_comp (A : C) (B : C) (C : Type u‚ÇÅ) (X : Subobject B) (f : A ‚ü∂ B) (h : X ‚â§ mk f) : X.ofLEMk f h ‚â´ f = X.arrow := by"
  },
  {
    "full_name": "EMetric.isClosed_subsets_of_isClosed",
    "file_path": "Mathlib/Topology/MetricSpace/Closeds.lean",
    "teorema": "lemma EMetric.isClosed_subsets_of_isClosed (s : Set Œ±) (Œ± : Type u) : IsClosed {t | ‚Üët ‚äÜ s} := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.iIndepFun.indepFun_prod_mk",
    "file_path": "Mathlib/Probability/Independence/Kernel.lean",
    "teorema": "lemma ProbabilityTheory.kernel.iIndepFun.indepFun_prod_mk (f : (i : Œπ) ‚Üí Œ© ‚Üí Œ≤ i) (i : Œπ) (j : Œπ) (k : Œπ) (Œ© : Type u_2) (Œ± : Type u_1) (Œ≤ : Œπ ‚Üí Type u_8) (Œπ : Type u_3) (Œ∫ : ‚Ü•(kernel Œ± Œ©)) (Œº : Measure Œ±) : IndepFun (fun a => (f i a, f j a)) (f k) Œ∫ Œº := by"
  },
  {
    "full_name": "QPF.liftp_iff",
    "file_path": "Mathlib/Data/QPF/Univariate/Basic.lean",
    "teorema": "theorem QPF.liftp_iff (F : Type u ‚Üí Type u) (p : Œ± ‚Üí Prop) (x : F Œ±) (Œ± : Type u) : Liftp p x ‚Üî ‚àÉ a f, x = abs ‚ü®a, f‚ü© ‚àß ‚àÄ (i : (P F).B a), p (f i) := by"
  },
  {
    "full_name": "differentiableWithinAt_univ",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
    "teorema": "theorem differentiableWithinAt_univ (E : Type u_2) (F : Type u_3) (f : E ‚Üí F) (x : E) (ùïú : Type u_1) : DifferentiableWithinAt ùïú f univ x ‚Üî DifferentiableAt ùïú f x := by"
  },
  {
    "full_name": "FirstOrder.Language.Embedding.coe_injective",
    "file_path": "Mathlib/ModelTheory/Basic.lean",
    "teorema": "lemma FirstOrder.Language.Embedding.coe_injective (L : Language) (M : Type w) (N : Type w') (f : M ‚Ü™[L] N) (g : M ‚Ü™[L] N) : f = g := by"
  },
  {
    "full_name": "Polynomial.Monic.mul_left_ne_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "teorema": "lemma Polynomial.Monic.mul_left_ne_zero (R : Type u) (p : R[X]) (q : R[X]) : q * p ‚â† 0 := by"
  },
  {
    "full_name": "Filter.principal_mono",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.principal_mono (s : Set Œ±) (t : Set Œ±) (Œ± : Type u) : ùìü s ‚â§ ùìü t ‚Üî s ‚äÜ t := by"
  },
  {
    "full_name": "denseRange_discrete",
    "file_path": "Mathlib/Topology/Order.lean",
    "teorema": "theorem denseRange_discrete (f : Œπ ‚Üí Œ±) (Œ± : Type u_1) (Œπ : Type u_3) : DenseRange f ‚Üî Surjective f := by"
  },
  {
    "full_name": "MulAction.map_stabilizer_le",
    "file_path": "Mathlib/Algebra/Pointwise/Stabilizer.lean",
    "teorema": "theorem MulAction.map_stabilizer_le (G : Type u_1) (H : Type u_2) (f : G ‚Üí* H) (s : Set G) : Subgroup.map f (stabilizer G s) ‚â§ stabilizer H (‚áëf '' s) := by"
  },
  {
    "full_name": "AffineSubspace.wSameSide_vadd_left_iff",
    "file_path": "Mathlib/Analysis/Convex/Side.lean",
    "teorema": "theorem AffineSubspace.wSameSide_vadd_left_iff (P : Type u_4) (R : Type u_1) (V : Type u_2) (s : AffineSubspace R P) (v : V) (x : P) (y : P) : s.WSameSide (v +·µ• x) y ‚Üî s.WSameSide x y := by"
  },
  {
    "full_name": "CategoryTheory.eqToIso_map",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "lemma CategoryTheory.eqToIso_map (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (F : C ‚•§ D) (X : C) (Y : C) (p : X = Y) : F.mapIso (eqToIso p) = eqToIso ‚ãØ := by"
  },
  {
    "full_name": "le_iff_compact_le_imp",
    "file_path": "Mathlib/Order/CompactlyGenerated/Basic.lean",
    "teorema": "lemma le_iff_compact_le_imp (a : Œ±) (b : Œ±) (Œ± : Type u_2) : a ‚â§ b := by"
  },
  {
    "full_name": "LucasLehmer.X.card_units_lt",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "teorema": "theorem LucasLehmer.X.card_units_lt (q : ‚Ñï+) : Fintype.card (X q)À£ < ‚Üëq ^ 2 := by"
  },
  {
    "full_name": "Batteries.RBNode.Path.zoom_zoomed‚ÇÇ",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "teorema": "theorem Batteries.RBNode.Path.zoom_zoomed‚ÇÇ (cut : Œ±‚úù ‚Üí Ordering) (path : Path Œ±‚úù) : Zoomed cut path' := by"
  },
  {
    "full_name": "Trivialization.linearMapAt_apply",
    "file_path": "Mathlib/Topology/VectorBundle/Basic.lean",
    "teorema": "lemma Trivialization.linearMapAt_apply (B : Type u_2) (E : B ‚Üí Type u_4) (F : Type u_3) (R : Type u_1) (b : B) (e : Trivialization F TotalSpace.proj) (y : E b) : (Trivialization.linearMapAt R e b) y = if b ‚àà e.baseSet then (‚Üëe { proj := b, snd := y }).2 else 0 := by"
  },
  {
    "full_name": "Matroid.Basis.exchange",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "teorema": "lemma Matroid.Basis.exchange (I : Set Œ±) (J : Set Œ±) (M : Matroid Œ±) (X : Set Œ±) (e : Œ±) (Œ± : Type u_1) : ‚àÉ f ‚àà J \\ I, M.Basis (insert f (I \\ {e})) X := by"
  },
  {
    "full_name": "Multiset.inf_union",
    "file_path": "Mathlib/Data/Multiset/Lattice.lean",
    "teorema": "theorem Multiset.inf_union (s‚ÇÅ : Multiset Œ±) (s‚ÇÇ : Multiset Œ±) (Œ± : Type u_1) : (s‚ÇÅ ‚à™ s‚ÇÇ).inf = s‚ÇÅ.inf ‚äì s‚ÇÇ.inf := by"
  },
  {
    "full_name": "Vector.mapAccumr_snoc",
    "file_path": "Mathlib/Data/Vector/Snoc.lean",
    "teorema": "theorem Vector.mapAccumr_snoc (f : Œ± ‚Üí Œ±‚úù ‚Üí Œ±‚úù √ó Œ≤‚úù) (n : ‚Ñï) (s : Œ±‚úù) (x : Œ±) (xs : Vector Œ± n) (Œ± : Type u_2) : mapAccumr f (xs.snoc x) s = := by"
  },
  {
    "full_name": "orthogonalProjection_eq_self_iff",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Projection.lean",
    "teorema": "lemma orthogonalProjection_eq_self_iff (E : Type u_2) (K : Submodule ùïú E) (v : E) (ùïú : Type u_1) : ‚Üë((orthogonalProjection K) v) = v ‚Üî v ‚àà K := by"
  },
  {
    "full_name": "OrthonormalBasis.coe_toBasis",
    "file_path": "Mathlib/Analysis/InnerProductSpace/PiL2.lean",
    "teorema": "theorem OrthonormalBasis.coe_toBasis (E : Type u_4) (b : OrthonormalBasis Œπ ùïú E) (Œπ : Type u_1) (ùïú : Type u_3) : ‚áëb.toBasis = ‚áëb := by"
  },
  {
    "full_name": "Finset.preimage_union",
    "file_path": "Mathlib/Data/Finset/Preimage.lean",
    "teorema": "lemma Finset.preimage_union (f : Œ± ‚Üí Œ≤) (hst : InjOn f (f ‚Åª¬π' ‚Üë(s ‚à™ t))) (s : Finset Œ≤) (t : Finset Œ≤) (Œ± : Type u) (Œ≤ : Type v) : ‚Üë((s ‚à™ t).preimage f hst) = ‚Üë(s.preimage f ‚ãØ ‚à™ t.preimage f ‚ãØ) := by"
  },
  {
    "full_name": "ArithmeticFunction.LSeriesSummable_vonMangoldt",
    "file_path": "Mathlib/NumberTheory/LSeries/Dirichlet.lean",
    "teorema": "lemma ArithmeticFunction.LSeriesSummable_vonMangoldt (s : ‚ÑÇ) : LSeriesSummable (fun n => ‚Üë(Œõ n)) s := by"
  },
  {
    "full_name": "nilpotent_iff_finite_descending_central_series",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "teorema": "theorem nilpotent_iff_finite_descending_central_series (G : Type u_1) (H : Subgroup G) : Group.IsNilpotent G ‚Üî ‚àÉ n H, IsDescendingCentralSeries H ‚àß H n = ‚ä• := by"
  },
  {
    "full_name": "mulIndicator_biUnion_finset_eventuallyEq",
    "file_path": "Mathlib/Order/Filter/IndicatorFunction.lean",
    "teorema": "lemma mulIndicator_biUnion_finset_eventuallyEq (a : Œ±) (f : Œ± ‚Üí Œ≤) (s : Œπ ‚Üí Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œπ : Type u_5) : (fun n => (‚ãÉ i ‚àà n, s i).mulIndicator f a) =·∂†[atTop] fun x => (iUnion s).mulIndicator f a := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_eq_pi_iff",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "teorema": "theorem InnerProductGeometry.angle_eq_pi_iff (V : Type u_1) (x : V) (y : V) : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r < 0, y = r ‚Ä¢ x := by"
  },
  {
    "full_name": "CovBy.Ico_eq",
    "file_path": "Mathlib/Order/Cover.lean",
    "teorema": "theorem CovBy.Ico_eq (a : Œ±) (b : Œ±) (Œ± : Type u_1) : Ico a b = {a} := by"
  },
  {
    "full_name": "PSet.not_nonempty_empty",
    "file_path": "Mathlib/SetTheory/ZFC/Basic.lean",
    "teorema": "lemma PSet.not_nonempty_empty : ¬¨‚àÖ.Nonempty := by"
  },
  {
    "full_name": "Surreal.Multiplication.P2_neg_right",
    "file_path": "Mathlib/SetTheory/Surreal/Multiplication.lean",
    "teorema": "lemma Surreal.Multiplication.P2_neg_right (x‚ÇÅ : PGame) (x‚ÇÇ : PGame) (y : PGame) : P2 x‚ÇÅ x‚ÇÇ y ‚Üî P2 x‚ÇÅ x‚ÇÇ (-y) := by"
  },
  {
    "full_name": "IsSubmonoid.multiset_prod_mem",
    "file_path": "Mathlib/Deprecated/Submonoid.lean",
    "teorema": "lemma IsSubmonoid.multiset_prod_mem (M : Type u_3) (m : Multiset M) (s : Set M) : (‚àÄ a ‚àà m, a ‚àà s) ‚Üí m.prod ‚àà s := by"
  },
  {
    "full_name": "StructureGroupoid.restriction_in_maximalAtlas",
    "file_path": "Mathlib/Geometry/Manifold/ChartedSpace.lean",
    "teorema": "theorem StructureGroupoid.restriction_in_maximalAtlas (G : StructureGroupoid H) (H : Type u) (M : Type u_2) (e : PartialHomeomorph M H) (hs : Nonempty ‚Ü•s) (s : Opens M) : e.subtypeRestr hs ‚àà maximalAtlas (‚Ü•s) G := by"
  },
  {
    "full_name": "one_lt_of_lt_mul_left",
    "file_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
    "teorema": "lemma one_lt_of_lt_mul_left (a : Œ±) (Œ± : Type u_1) : 1 * ?m.28643 < a * ?m.28643 := by"
  },
  {
    "full_name": "Set.image_fst_graphOn",
    "file_path": "Mathlib/Data/Set/Function.lean",
    "teorema": "lemma Set.image_fst_graphOn (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : Prod.fst '' graphOn f s = s := by"
  },
  {
    "full_name": "LipschitzOnWith.extend_pi",
    "file_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean",
    "teorema": "theorem LipschitzOnWith.extend_pi (K : ‚Ñù‚â•0) (f : Œ± ‚Üí Œπ ‚Üí ‚Ñù) (s : Set Œ±) (Œ± : Type u) (Œπ : Type x) : ‚àÉ g, LipschitzWith K g ‚àß EqOn f g s := by"
  },
  {
    "full_name": "Finset.mem_sym_iff",
    "file_path": "Mathlib/Data/Finset/Sym.lean",
    "teorema": "theorem Finset.mem_sym_iff (a : Œ±) (m : Sym Œ± n) (n : ‚Ñï) (s : Finset Œ±) (Œ± : Type u_1) : m ‚àà s.sym n ‚Üî ‚àÄ a ‚àà m, a ‚àà s := by"
  },
  {
    "full_name": "OrthonormalBasis.orthonormal_adjustToOrientation",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Orientation.lean",
    "teorema": "theorem OrthonormalBasis.orthonormal_adjustToOrientation (E : Type u_1) (e : OrthonormalBasis Œπ ‚Ñù E) (x : Orientation ‚Ñù E Œπ) (Œπ : Type u_2) : Orthonormal ‚Ñù ‚áë(e.toBasis.adjustToOrientation x) := by"
  },
  {
    "full_name": "HurwitzZeta.completedHurwitzZetaOdd_one_sub",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaOdd.lean",
    "teorema": "lemma HurwitzZeta.completedHurwitzZetaOdd_one_sub (a : UnitAddCircle) (s : ‚ÑÇ) : completedHurwitzZetaOdd a (1 - s) = completedSinZeta a s := by"
  },
  {
    "full_name": "List.cons_diff_of_mem",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "lemma List.cons_diff_of_mem (a : Œ±) (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (Œ± : Type u_1) : (a :: l‚ÇÅ).diff l‚ÇÇ = l‚ÇÅ.diff (l‚ÇÇ.erase a) := by"
  },
  {
    "full_name": "Substring.Valid.next",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "theorem Substring.Valid.next (c : Char) (m‚ÇÅ : List Char) : x‚úù.next { byteIdx := utf8Len m‚ÇÅ } = { byteIdx := utf8Len m‚ÇÅ + c.utf8Size } := by"
  },
  {
    "full_name": "exists_set_linearIndependent_of_isDomain",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Localization.lean",
    "teorema": "theorem exists_set_linearIndependent_of_isDomain (M : Type v) (R : Type u) : ‚àÉ s, #‚Üës = Module.rank R M ‚àß LinearIndependent (Œπ := ‚Üës) R Subtype.val := by"
  },
  {
    "full_name": "CategoryTheory.topologyOfClosureOperator_self",
    "file_path": "Mathlib/CategoryTheory/Sites/Closed.lean",
    "teorema": "theorem CategoryTheory.topologyOfClosureOperator_self (C : Type u) (J‚ÇÅ : GrothendieckTopology C) : topologyOfClosureOperator J‚ÇÅ.closureOperator ‚ãØ = J‚ÇÅ := by"
  },
  {
    "full_name": "Nat.prime_two",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "theorem Nat.prime_two : Prime 2 := by"
  },
  {
    "full_name": "FiniteDimensional.finrank_eq_zero_iff_isTorsion",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Finite.lean",
    "teorema": "theorem FiniteDimensional.finrank_eq_zero_iff_isTorsion (M : Type v) (R : Type u_1) : finrank R M = 0 ‚Üî Module.IsTorsion R M := by"
  },
  {
    "full_name": "IsPGroup.powEquiv_symm_apply",
    "file_path": "Mathlib/GroupTheory/PGroup.lean",
    "teorema": "theorem IsPGroup.powEquiv_symm_apply (G : Type u_1) (g : G) (hG : IsPGroup p G) (hn : p.Coprime n) (n : ‚Ñï) (p : ‚Ñï) : (hG.powEquiv hn).symm g = g ^ (orderOf g).gcdB n := by"
  },
  {
    "full_name": "VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable",
    "file_path": "Mathlib/MeasureTheory/Covering/Differentiation.lean",
    "teorema": "lemma VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable (E : Type u_2) (f : Œ± ‚Üí E) (v : VitaliFamily Œº) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚àÄ·µê (x : Œ±) ‚àÇŒº, Tendsto (fun a => (‚à´‚Åª (y : Œ±) in a, ‚Üë‚Äñf y - f x‚Äñ‚Çä ‚àÇŒº) / Œº a) (v.filterAt x) (ùìù 0) := by"
  },
  {
    "full_name": "Units.mul_right_eq_zero",
    "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
    "teorema": "theorem Units.mul_right_eq_zero (M‚ÇÄ : Type u_2) (a : M‚ÇÄ) : a = 0 := by"
  },
  {
    "full_name": "Seminorm.finset_sup_le_sum",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "theorem Seminorm.finset_sup_le_sum (E : Type u_7) (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) (Œπ : Type u_12) (ùïú : Type u_3) : s.sup p ‚â§ ‚àë i ‚àà s, p i := by"
  },
  {
    "full_name": "LinearMap.trace_tensorProduct",
    "file_path": "Mathlib/LinearAlgebra/Trace.lean",
    "teorema": "theorem LinearMap.trace_tensorProduct (M : Type u_2) (N : Type u_3) (R : Type u_1) : (mapBilinear R M N M N).compr‚ÇÇ (trace R (M ‚äó[R] N)) = (lsmul R R).compl‚ÇÅ‚ÇÇ (trace R M) (trace R N) := by"
  },
  {
    "full_name": "Finset.sum_pow'",
    "file_path": "Mathlib/Algebra/BigOperators/Ring.lean",
    "teorema": "lemma Finset.sum_pow' (a : Œ±) (f : Œπ ‚Üí Œ±) (i : Œπ) (n : ‚Ñï) (s : Finset Œπ) (Œ± : Type u_2) (Œπ : Type u_1) : (‚àë a ‚àà s, f a) ^ n = ‚àë p ‚àà piFinset fun _i => s, ‚àè i : Fin n, f (p i) := by"
  },
  {
    "full_name": "Finset.surj_on_of_inj_on_of_card_le",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "lemma Finset.surj_on_of_inj_on_of_card_le (f : (a : Œ±) ‚Üí a ‚àà s ‚Üí Œ≤) (s : Finset Œ±) (t : Finset Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : ‚àÄ b ‚àà t, ‚àÉ a, ‚àÉ (ha : a ‚àà s), b = f a ha := by"
  },
  {
    "full_name": "Finsupp.neLocus_self_sub_right",
    "file_path": "Mathlib/Data/Finsupp/NeLocus.lean",
    "teorema": "lemma Finsupp.neLocus_self_sub_right (N : Type u_3) (f : Œ± ‚Üí‚ÇÄ N) (g : Œ± ‚Üí‚ÇÄ N) (Œ± : Type u_1) : f.neLocus (f - g) = g.support := by"
  },
  {
    "full_name": "UpperHalfPlane.center_zero",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean",
    "teorema": "theorem UpperHalfPlane.center_zero (z : ‚Ñç) : (z.center 0).im = z.im := by"
  },
  {
    "full_name": "ContinuousLinearMap.prod_ext_iff",
    "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean",
    "teorema": "lemma ContinuousLinearMap.prod_ext_iff (M : Type u_6) (N‚ÇÇ : Type u_9) (N‚ÇÉ : Type u_10) (R : Type u_1) (f : M √ó N‚ÇÇ ‚ÜíL[R] N‚ÇÉ) (g : M √ó N‚ÇÇ ‚ÜíL[R] N‚ÇÉ) : f = g ‚Üî f.comp (inl R M N‚ÇÇ) = g.comp (inl R M N‚ÇÇ) ‚àß f.comp (inr R M N‚ÇÇ) = g.comp (inr R M N‚ÇÇ) := by"
  },
  {
    "full_name": "Polynomial.eval‚ÇÇ_neg",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "theorem Polynomial.eval‚ÇÇ_neg (R : Type u) (S : Type u_1) (f : R ‚Üí+* S) (p : R[X]) (x : S) : eval‚ÇÇ f x (-p) = -eval‚ÇÇ f x p := by"
  },
  {
    "full_name": "eq_of_vsub_eq_zero",
    "file_path": "Mathlib/Algebra/AddTorsor.lean",
    "teorema": "lemma eq_of_vsub_eq_zero (P : Type u_2) (p‚ÇÅ : P) (p‚ÇÇ : P) : p‚ÇÅ = p‚ÇÇ := by"
  },
  {
    "full_name": "Complex.Gamma‚Ñù_ne_zero_of_re_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean",
    "teorema": "theorem Complex.Gamma‚Ñù_ne_zero_of_re_pos (s : ‚ÑÇ) : s.Gamma‚Ñù ‚â† 0 := by"
  },
  {
    "full_name": "HasProd.mul",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean",
    "teorema": "theorem HasProd.mul (a : Œ±) (b : Œ±) (f : Œ≤ ‚Üí Œ±) (g : Œ≤ ‚Üí Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : HasProd (fun b => f b * g b) (a * b) := by"
  },
  {
    "full_name": "Lagrange.degree_interpolate_lt",
    "file_path": "Mathlib/LinearAlgebra/Lagrange.lean",
    "teorema": "theorem Lagrange.degree_interpolate_lt (F : Type u_1) (r : Œπ ‚Üí F) (s : Finset Œπ) (v : Œπ ‚Üí F) (Œπ : Type u_2) : ((interpolate s v) r).degree < ‚Üës.card := by"
  },
  {
    "full_name": "Projectivization.submodule_injective",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Basic.lean",
    "teorema": "theorem Projectivization.submodule_injective (K : Type u_1) (V : Type u_2) (u : ‚Ñô K V) (v : ‚Ñô K V) : u = v := by"
  },
  {
    "full_name": "Rel.mul_edgeDensity_le_edgeDensity",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Density.lean",
    "teorema": "lemma Rel.mul_edgeDensity_le_edgeDensity (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (s‚ÇÅ : Finset Œ±) (s‚ÇÇ : Finset Œ±) (t‚ÇÅ : Finset Œ≤) (t‚ÇÇ : Finset Œ≤) (Œ± : Type u_4) (Œ≤ : Type u_5) : ‚Üës‚ÇÇ.card / ‚Üës‚ÇÅ.card * (‚Üët‚ÇÇ.card / ‚Üët‚ÇÅ.card) * edgeDensity r s‚ÇÇ t‚ÇÇ ‚â§ edgeDensity r s‚ÇÅ t‚ÇÅ := by"
  },
  {
    "full_name": "left_eq_midpoint_iff",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean",
    "teorema": "theorem left_eq_midpoint_iff (P : Type u_4) (R : Type u_1) (x : P) (y : P) : x = midpoint R x y ‚Üî x = y := by"
  },
  {
    "full_name": "Function.not_injective_iff",
    "file_path": "Mathlib/Logic/Function/Basic.lean",
    "teorema": "lemma Function.not_injective_iff (f : Œ± ‚Üí Œ≤) (Œ± : Sort u_1) (Œ≤ : Sort u_2) : ¬¨Injective f ‚Üî ‚àÉ a b, f a = f b ‚àß a ‚â† b := by"
  },
  {
    "full_name": "Finset.sup'_union",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "lemma Finset.sup'_union (a : Œ±) (f : Œ≤ ‚Üí Œ±) (h‚ÇÅ : s‚ÇÅ.Nonempty) (h‚ÇÇ : s‚ÇÇ.Nonempty) (s‚ÇÅ : Finset Œ≤) (s‚ÇÇ : Finset Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : (s‚ÇÅ ‚à™ s‚ÇÇ).sup' ‚ãØ f ‚â§ a ‚Üî s‚ÇÅ.sup' h‚ÇÅ f ‚äî s‚ÇÇ.sup' h‚ÇÇ f ‚â§ a := by"
  },
  {
    "full_name": "Polynomial.cyclotomic_irreducible_pow_of_irreducible_pow",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean",
    "teorema": "theorem Polynomial.cyclotomic_irreducible_pow_of_irreducible_pow (R : Type u_1) (m : ‚Ñï) (p : ‚Ñï) : Irreducible (cyclotomic (p ^ m) R) := by"
  },
  {
    "full_name": "SignType.nonneg_iff_ne_neg_one",
    "file_path": "Mathlib/Data/Sign.lean",
    "teorema": "lemma SignType.nonneg_iff_ne_neg_one (a : SignType) : 0 ‚â§ a ‚Üî a ‚â† -1 := by"
  },
  {
    "full_name": "CoxeterSystem.length_eq_one_iff",
    "file_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
    "teorema": "theorem CoxeterSystem.length_eq_one_iff (B : Type u_1) (M : CoxeterMatrix B) (W : Type u_2) (cs : CoxeterSystem M W) (w : W) : cs.length w = 1 ‚Üî ‚àÉ i, w = cs.simple i := by"
  },
  {
    "full_name": "HahnSeries.single_coeff",
    "file_path": "Mathlib/RingTheory/HahnSeries/Basic.lean",
    "teorema": "lemma HahnSeries.single_coeff (R : Type u_2) (a : Œì) (b : Œì) (r : R) (Œì : Type u_1) : ((single a) r).coeff b = if b = a then r else 0 := by"
  },
  {
    "full_name": "Filter.EventuallyEq.mfderivWithin_eq",
    "file_path": "Mathlib/Geometry/Manifold/MFDeriv/Basic.lean",
    "teorema": "lemma Filter.EventuallyEq.mfderivWithin_eq (E : Type u_2) (H : Type u_3) (I : ModelWithCorners ùïú E H) (M : Type u_4) (f : M ‚Üí M') (f‚ÇÅ : M ‚Üí M') (s : Set M) (x : M) (ùïú : Type u_1) : mfderivWithin I I' f‚ÇÅ s x = mfderivWithin I I' f s x := by"
  },
  {
    "full_name": "MeasureTheory.Measure.restrict_toMeasurable_of_sFinite",
    "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean",
    "teorema": "theorem MeasureTheory.Measure.restrict_toMeasurable_of_sFinite (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (Œº.restrict (toMeasurable Œº s)) t = (Œº.restrict s) t := by"
  },
  {
    "full_name": "TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "theorem TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff (s : Set Œ±) (t : Set Œ±) (Œ± : Type u) : s = t := by"
  },
  {
    "full_name": "List.sum_take_map_length_splitWrtComposition",
    "file_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
    "teorema": "theorem List.sum_take_map_length_splitWrtComposition (c : Composition l.length) (i : ‚Ñï) (l : List Œ±) (Œ± : Type u_1) : (take i (map length (l.splitWrtComposition c))).sum = c.sizeUpTo i := by"
  },
  {
    "full_name": "IsSl2Triple.f_ne_zero",
    "file_path": "Mathlib/Algebra/Lie/Sl2.lean",
    "teorema": "lemma IsSl2Triple.f_ne_zero (L : Type u_2) (f : L) : f ‚â† 0 := by"
  },
  {
    "full_name": "Finsupp.mem_neLocus",
    "file_path": "Mathlib/Data/Finsupp/NeLocus.lean",
    "teorema": "lemma Finsupp.mem_neLocus (N : Type u_3) (a : Œ±) (f : Œ± ‚Üí‚ÇÄ N) (g : Œ± ‚Üí‚ÇÄ N) (Œ± : Type u_1) : a ‚àà f.neLocus g ‚Üî f a ‚â† g a := by"
  },
  {
    "full_name": "Order.isPredLimit_toDual_iff",
    "file_path": "Mathlib/Order/SuccPred/Limit.lean",
    "teorema": "theorem Order.isPredLimit_toDual_iff (a : Œ±) (Œ± : Type u_1) : IsPredLimit (toDual a) ‚Üî IsSuccLimit a := by"
  },
  {
    "full_name": "Multiset.powerset_cons",
    "file_path": "Mathlib/Data/Multiset/Powerset.lean",
    "teorema": "lemma Multiset.powerset_cons (a : Œ±) (l : List Œ±) (Œ± : Type u_1) : (a ::‚Çò ‚ü¶l‚üß).powerset = powerset ‚ü¶l‚üß + map (cons a) (powerset ‚ü¶l‚üß) := by"
  },
  {
    "full_name": "Polynomial.degree_erase_lt",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "theorem Polynomial.degree_erase_lt (R : Type u) (p : R[X]) : (erase p.natDegree p).degree < p.degree := by"
  },
  {
    "full_name": "ContinuousMultilinearMap.ext_iff",
    "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean",
    "teorema": "lemma ContinuousMultilinearMap.ext_iff (M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ) (M‚ÇÇ : Type w‚ÇÇ) (R : Type u) (f : ContinuousMultilinearMap R M‚ÇÅ M‚ÇÇ) (Œπ : Type v) : f = f' ‚Üî ‚àÄ (x : (i : Œπ) ‚Üí M‚ÇÅ i), f x = f' x := by"
  },
  {
    "full_name": "SimpleGraph.Subgraph.subgraphOfAdj_connected",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
    "teorema": "theorem SimpleGraph.Subgraph.subgraphOfAdj_connected (G : SimpleGraph V) (V : Type u) (hvw : G.Adj v w) (v : V) (w : V) : (G.subgraphOfAdj hvw).Connected := by"
  },
  {
    "full_name": "CliffordAlgebra.Œπ_sq_scalar",
    "file_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Basic.lean",
    "teorema": "theorem CliffordAlgebra.Œπ_sq_scalar (M : Type u_2) (Q : QuadraticForm R M) (R : Type u_1) (m : M) : (Œπ Q) m * (Œπ Q) m = (algebraMap R (CliffordAlgebra Q)) (Q m) := by"
  },
  {
    "full_name": "Real.mk_neg",
    "file_path": "Mathlib/Data/Real/Basic.lean",
    "teorema": "lemma Real.mk_neg (f : CauSeq ‚Ñö abs) : mk (-f) = -mk f := by"
  },
  {
    "full_name": "Polynomial.eval‚ÇÇ_mul_noncomm",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "lemma Polynomial.eval‚ÇÇ_mul_noncomm (R : Type u) (S : Type v) (f : R ‚Üí+* S) (p : R[X]) (q : R[X]) (x : S) : eval‚ÇÇ f x (p * q) = eval‚ÇÇ f x p * eval‚ÇÇ f x q := by"
  },
  {
    "full_name": "Stream'.get_succ_iterate",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "teorema": "theorem Stream'.get_succ_iterate (a : Œ±) (f : Œ± ‚Üí Œ±) (n : ‚Ñï) (Œ± : Type u) : (iterate f a).get n.succ = (iterate f (f a)).get n := by"
  },
  {
    "full_name": "Real.volume_ball",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean",
    "teorema": "theorem Real.volume_ball (a : ‚Ñù) (r : ‚Ñù) : volume (Metric.ball a r) = ofReal (2 * r) := by"
  },
  {
    "full_name": "ProbabilityTheory.IsCondKernelCDF.setLIntegral",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean",
    "teorema": "theorem ProbabilityTheory.IsCondKernelCDF.setLIntegral (a : Œ±) (f : Œ± √ó Œ≤ ‚Üí StieltjesFunction) (s : Set Œ≤) (x : ‚Ñù) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ∫ : ‚Ü•(kernel Œ± (Œ≤ √ó ‚Ñù))) (ŒΩ : ‚Ü•(kernel Œ± Œ≤)) : ‚à´‚Åª (b : Œ≤) in s, ENNReal.ofReal (‚Üë(f (a, b)) x) ‚àÇŒΩ a = (Œ∫ a) (s √óÀ¢ Iic x) := by"
  },
  {
    "full_name": "Affine.Simplex.reindex_reindex_symm",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean",
    "teorema": "lemma Affine.Simplex.reindex_reindex_symm (P : Type u_3) (e : Fin (m + 1) ‚âÉ Fin (n + 1)) (k : Type u_1) (m : ‚Ñï) (n : ‚Ñï) (s : Simplex k P m) : (s.reindex e).reindex e.symm = s := by"
  },
  {
    "full_name": "AlgebraicGeometry.diagonal_targetAffineLocally_eq_targetAffineLocally",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/Constructors.lean",
    "teorema": "lemma AlgebraicGeometry.diagonal_targetAffineLocally_eq_targetAffineLocally (P : AffineTargetMorphismProperty) : (targetAffineLocally P).diagonal = targetAffineLocally P.diagonal := by"
  },
  {
    "full_name": "Filter.HasBasis.frequently_iff",
    "file_path": "Mathlib/Order/Filter/Bases.lean",
    "teorema": "lemma Filter.HasBasis.frequently_iff (i : Œπ) (l : Filter Œ±) (p : Œπ ‚Üí Prop) (q : Œ± ‚Üí Prop) (s : Œπ ‚Üí Set Œ±) (Œ± : Type u_1) (Œπ : Sort u_4) : (‚àÉ·∂† (x : Œ±) in l, q x) ‚Üî ‚àÄ (i : Œπ), p i ‚Üí ‚àÉ x ‚àà s i, q x := by"
  },
  {
    "full_name": "MvPolynomial.vanishingIdeal_pointToPoint",
    "file_path": "Mathlib/RingTheory/Nullstellensatz.lean",
    "teorema": "theorem MvPolynomial.vanishingIdeal_pointToPoint (k : Type u_1) (x : œÉ ‚Üí k) (œÉ : Type u_2) : (vanishingIdeal {x}).IsPrime := by"
  },
  {
    "full_name": "List.permutationsAux_cons",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "teorema": "lemma List.permutationsAux_cons (is : List Œ±) (t : Œ±) (ts : List Œ±) (Œ± : Type u_1) : (t :: ts).permutationsAux is = := by"
  },
  {
    "full_name": "Nat.factorization_eq_zero_of_not_dvd",
    "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
    "teorema": "lemma Nat.factorization_eq_zero_of_not_dvd (n : ‚Ñï) (p : ‚Ñï) : n.factorization p = 0 := by"
  },
  {
    "full_name": "Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic",
    "file_path": "Mathlib/FieldTheory/PurelyInseparable.lean",
    "teorema": "lemma Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic (E : Type v) (F : Type u) (K : Type w) : Cardinal.lift.{w, v} (sepDegree F E) * Cardinal.lift.{v, w} (sepDegree E K) = Cardinal.lift.{v, w} (sepDegree F K) := by"
  },
  {
    "full_name": "HasLineDerivAt.le_of_lipschitzOn",
    "file_path": "Mathlib/Analysis/Calculus/LineDeriv/Basic.lean",
    "teorema": "theorem HasLineDerivAt.le_of_lipschitzOn (C : ‚Ñù‚â•0) (E : Type u_3) (F : Type u_2) (f : E ‚Üí F) (v : E) : ‚Äñf'‚Äñ ‚â§ ‚ÜëC * ‚Äñv‚Äñ := by"
  },
  {
    "full_name": "LinearIndependent.cardinal_mk_le_finrank",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Finite.lean",
    "teorema": "lemma LinearIndependent.cardinal_mk_le_finrank (M : Type v) (R : Type u) (Œπ : Type w) : #Œπ ‚â§ ‚Üë(finrank R M) := by"
  },
  {
    "full_name": "prime_dvd_prime_iff_eq",
    "file_path": "Mathlib/Algebra/Associated.lean",
    "teorema": "theorem prime_dvd_prime_iff_eq (M : Type u_5) (p : M) (q : M) : p ‚à£ q ‚Üî p = q := by"
  },
  {
    "full_name": "NNRat.add_def",
    "file_path": "Mathlib/Data/NNRat/Defs.lean",
    "teorema": "theorem NNRat.add_def (q : ‚Ñö‚â•0) (r : ‚Ñö‚â•0) : q + r = divNat (q.num * r.den + r.num * q.den) (q.den * r.den) := by"
  },
  {
    "full_name": "dualTensorHomEquivOfBasis_apply",
    "file_path": "Mathlib/LinearAlgebra/Contraction.lean",
    "teorema": "lemma dualTensorHomEquivOfBasis_apply (M : Type v‚ÇÅ) (N : Type v‚ÇÇ) (R : Type u) (b : Basis Œπ R M) (x : Dual R M ‚äó[R] N) (Œπ : Type w) : (dualTensorHomEquivOfBasis b) x = (dualTensorHom R M N) x := by"
  },
  {
    "full_name": "FloorRing.exists_prime_mul_pow_div_factorial_lt_one",
    "file_path": "Mathlib/Algebra/Order/Floor/Prime.lean",
    "teorema": "theorem FloorRing.exists_prime_mul_pow_div_factorial_lt_one (K : Type u_1) (a : K) (c : K) (n : ‚Ñï) : ‚àÉ p > n, Nat.Prime p ‚àß a * c ^ p / ‚Üë(p - 1)! < 1 := by"
  },
  {
    "full_name": "Option.map‚ÇÇ_coe_right",
    "file_path": "Mathlib/Data/Option/NAry.lean",
    "teorema": "lemma Option.map‚ÇÇ_coe_right (a : Option Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : map‚ÇÇ f a (some b) = Option.map (fun a => f a b) a := by"
  },
  {
    "full_name": "Fin.foldl_zero",
    "file_path": ".lake/packages/batteries/Batteries/Data/Fin/Lemmas.lean",
    "teorema": "theorem Fin.foldl_zero (f : Œ± ‚Üí Fin 0 ‚Üí Œ±) (x : Œ±) (Œ± : Sort u_1) : foldl 0 f x = x := by"
  },
  {
    "full_name": "Complex.sin_add_sin",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.sin_add_sin (x : ‚ÑÇ) (y : ‚ÑÇ) : sin x + sin y = 2 * sin ((x + y) / 2) * cos ((x - y) / 2) := by"
  },
  {
    "full_name": "Complex.monotone_ofReal",
    "file_path": "Mathlib/Data/Complex/Order.lean",
    "teorema": "lemma Complex.monotone_ofReal : Monotone ofReal' := by"
  },
  {
    "full_name": "LinearMap.orthogonal_span_singleton_eq_to_lin_ker",
    "file_path": "Mathlib/LinearAlgebra/SesquilinearForm.lean",
    "teorema": "theorem LinearMap.orthogonal_span_singleton_eq_to_lin_ker (B : V ‚Üí‚Çó[K] V ‚Üí‚Çõ‚Çó[J] V‚ÇÇ) (J : K ‚Üí+* K) (K : Type u_13) (V : Type u_16) (V‚ÇÇ : Type u_18) (x : V) : (Submodule.span K {x}).orthogonalBilin B = ker (B x) := by"
  },
  {
    "full_name": "MvPowerSeries.inv_eq_zero",
    "file_path": "Mathlib/RingTheory/MvPowerSeries/Inverse.lean",
    "teorema": "lemma MvPowerSeries.inv_eq_zero (k : Type u_3) (œÉ : Type u_1) (œÜ : MvPowerSeries œÉ k) : (constantCoeff œÉ k) œÜ = 0 := by"
  },
  {
    "full_name": "Polynomial.degree_C_mul_X_pow_le",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "theorem Polynomial.degree_C_mul_X_pow_le (R : Type u) (a : R) (n : ‚Ñï) : (C a * X ^ n).degree ‚â§ ‚Üën := by"
  },
  {
    "full_name": "Submodule.le_one_toAddSubmonoid",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "theorem Submodule.le_one_toAddSubmonoid : 1 ‚â§ toAddSubmonoid 1 := by"
  },
  {
    "full_name": "Finpartition.part_surjOn",
    "file_path": "Mathlib/Order/Partition/Finpartition.lean",
    "teorema": "theorem Finpartition.part_surjOn (P : Finpartition s) (p : Finset Œ±) (s : Finset Œ±) (Œ± : Type u_1) : p ‚àà P.part '' ‚Üës := by"
  },
  {
    "full_name": "UniformFun.uniformSpace_eq_inf_precomp_of_cover",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "theorem UniformFun.uniformSpace_eq_inf_precomp_of_cover (x : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ¥‚ÇÅ : Type u_6) (Œ¥‚ÇÇ : Type u_7) (œÜ‚ÇÅ : Œ¥‚ÇÅ ‚Üí Œ±) (œÜ‚ÇÇ : Œ¥‚ÇÇ ‚Üí Œ±) : uniformSpace Œ± Œ≤ = UniformSpace.comap (‚áëofFun ‚àò (fun x => x ‚àò œÜ‚ÇÅ) ‚àò ‚áëtoFun) (uniformSpace Œ¥‚ÇÅ Œ≤) ‚äì UniformSpace.comap (‚áëofFun ‚àò (fun x => x ‚àò œÜ‚ÇÇ) ‚àò ‚áëtoFun) (uniformSpace Œ¥‚ÇÇ Œ≤) := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_sub_eq_arccos_of_inner_eq_zero",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean",
    "teorema": "lemma InnerProductGeometry.angle_sub_eq_arccos_of_inner_eq_zero (V : Type u_1) (x : V) (y : V) : angle x (x - y) = Real.arccos (‚Äñx‚Äñ / ‚Äñx - y‚Äñ) := by"
  },
  {
    "full_name": "CategoryTheory.Abelian.exact_iff_exact_coimage_œÄ",
    "file_path": "Mathlib/CategoryTheory/Abelian/Exact.lean",
    "teorema": "theorem CategoryTheory.Abelian.exact_iff_exact_coimage_œÄ (C : Type u‚ÇÅ) (X : C) (Y : C) (Z : C) (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : Exact f g ‚Üî Exact f (coimage.œÄ g) := by"
  },
  {
    "full_name": "Matroid.comap_base_iff",
    "file_path": "Mathlib/Data/Matroid/Map.lean",
    "teorema": "lemma Matroid.comap_base_iff (B : Set Œ±) (E : Set Œ±) (N : Matroid Œ≤) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (N.comap f).Base B ‚Üî N.Basis (f '' B) (f '' (f ‚Åª¬π' N.E)) ‚àß InjOn f B ‚àß B ‚äÜ f ‚Åª¬π' N.E := by"
  },
  {
    "full_name": "MulAction.set_mem_fixedBy_of_subset_fixedBy",
    "file_path": "Mathlib/GroupTheory/GroupAction/FixedPoints.lean",
    "teorema": "theorem MulAction.set_mem_fixedBy_of_subset_fixedBy (G : Type u_2) (g : G) (s : Set Œ±) (Œ± : Type u_1) : s ‚àà fixedBy (Set Œ±) g := by"
  },
  {
    "full_name": "Matrix.BlockTriangular.det_fintype",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Block.lean",
    "teorema": "theorem Matrix.BlockTriangular.det_fintype (M : Matrix m m R) (R : Type v) (b : m ‚Üí Œ±) (m : Type u_3) (Œ± : Type u_1) : M.det = ‚àè k : Œ±, (M.toSquareBlock b k).det := by"
  },
  {
    "full_name": "DirectSum.equivCongrLeft_apply",
    "file_path": "Mathlib/Algebra/DirectSum/Basic.lean",
    "teorema": "lemma DirectSum.equivCongrLeft_apply (f : ‚®Å (i : Œπ), Œ≤ i) (h : Œπ ‚âÉ Œ∫) (k : Œ∫) (Œ≤ : Œπ ‚Üí Type w) (Œπ : Type v) (Œ∫ : Type u_1) : ((equivCongrLeft h) f) k = f (h.symm k) := by"
  },
  {
    "full_name": "GeneralizedContinuedFraction.compExactValue_correctness_of_stream_eq_some",
    "file_path": "Mathlib/Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean",
    "teorema": "lemma GeneralizedContinuedFraction.compExactValue_correctness_of_stream_eq_some (K : Type u_1) (n : ‚Ñï) (v : K) : ‚àÄ {ifp_n : IntFractPair K}, IntFractPair.stream v n = some ifp_n ‚Üí v = compExactValue ((of v).continuantsAux n) ((of v).continuantsAux (n + 1)) ifp_n.fr := by"
  },
  {
    "full_name": "ConvexOn.average_mem_epigraph",
    "file_path": "Mathlib/Analysis/Convex/Integral.lean",
    "teorema": "lemma ConvexOn.average_mem_epigraph (E : Type u_2) (f : Œ± ‚Üí E) (g : E ‚Üí ‚Ñù) (s : Set E) (Œ± : Type u_1) (Œº : Measure Œ±) : (‚®ç (x : Œ±), f x ‚àÇŒº, ‚®ç (x : Œ±), g (f x) ‚àÇŒº) ‚àà {p | p.1 ‚àà s ‚àß g p.1 ‚â§ p.2} := by"
  },
  {
    "full_name": "StrictConcaveOn.eq_of_map_sum_eq",
    "file_path": "Mathlib/Analysis/Convex/Jensen.lean",
    "teorema": "theorem StrictConcaveOn.eq_of_map_sum_eq (E : Type u_2) (p : Œπ ‚Üí E) (t : Finset Œπ) (Œπ : Type u_5) : ‚àÄ ‚¶Éj : Œπ‚¶Ñ, j ‚àà t ‚Üí ‚àÄ ‚¶Ék : Œπ‚¶Ñ, k ‚àà t ‚Üí p j = p k := by"
  },
  {
    "full_name": "Finsupp.card_Ico",
    "file_path": "Mathlib/Data/Finsupp/Interval.lean",
    "teorema": "theorem Finsupp.card_Ico (f : Œπ ‚Üí‚ÇÄ Œ±) (g : Œπ ‚Üí‚ÇÄ Œ±) (Œ± : Type u_2) (Œπ : Type u_1) : (Ico f g).card = ‚àè i ‚àà f.support ‚à™ g.support, (Icc (f i) (g i)).card - 1 := by"
  },
  {
    "full_name": "neg_one_sq",
    "file_path": "Mathlib/Algebra/Ring/Commute.lean",
    "teorema": "theorem neg_one_sq : (-1) ^ 2 = 1 := by"
  },
  {
    "full_name": "Real.Angle.eq_iff_sign_eq_and_abs_toReal_eq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "lemma Real.Angle.eq_iff_sign_eq_and_abs_toReal_eq (Œ∏ : Angle) (œà : Angle) : Œ∏ = œà ‚Üî Œ∏.sign = œà.sign ‚àß |Œ∏.toReal| = |œà.toReal| := by"
  },
  {
    "full_name": "Submodule.restrictScalars_mul",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "lemma Submodule.restrictScalars_mul (A : Type u_1) (B : Type u_2) (C : Type u_3) (I : Submodule B C) (J : Submodule B C) : restrictScalars A (I * J) = restrictScalars A I * restrictScalars A J := by"
  },
  {
    "full_name": "Subalgebra.iSupLift_of_mem",
    "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Directed.lean",
    "teorema": "lemma Subalgebra.iSupLift_of_mem (A : Type u_2) (B : Type u_3) (K : Œπ ‚Üí Subalgebra R A) (R : Type u_1) (T : Subalgebra R A) (dir : Directed (fun x x_1 => x ‚â§ x_1) K) (f : (i : Œπ) ‚Üí ‚Ü•(K i) ‚Üí‚Çê[R] B) (hT : T = iSup K) (hf : ‚àÄ (i j : Œπ) (h : K i ‚â§ K j), f i = (f j).comp (inclusion h)) (hx : ‚Üëx ‚àà K i) (i : Œπ) (x : ‚Ü•T) (Œπ : Type u_4) : (iSupLift K dir f hf T hT) x = (f i) ‚ü®‚Üëx, hx‚ü© := by"
  },
  {
    "full_name": "Cardinal.lift_le_continuum",
    "file_path": "Mathlib/SetTheory/Cardinal/Continuum.lean",
    "teorema": "lemma Cardinal.lift_le_continuum (c : Cardinal.{u}) : lift.{v, u} c ‚â§ ùî† ‚Üî c ‚â§ ùî† := by"
  },
  {
    "full_name": "Int.fract_add_int",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Int.fract_add_int (a : Œ±) (m : ‚Ñ§) (Œ± : Type u_2) : fract (a + ‚Üëm) = fract a := by"
  },
  {
    "full_name": "exists_mem_frontier_infDist_compl_eq_dist",
    "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean",
    "teorema": "theorem exists_mem_frontier_infDist_compl_eq_dist (E : Type u_1) (s : Set E) (x : E) : ‚àÉ y ‚àà frontier s, infDist x s·∂ú = dist x y := by"
  },
  {
    "full_name": "Multiset.product_cons",
    "file_path": "Mathlib/Data/Multiset/Bind.lean",
    "teorema": "lemma Multiset.product_cons (a : Œ±) (b : Œ≤) (s : Multiset Œ±) (t : Multiset Œ≤) (Œ± : Type u_1) (Œ≤ : Type v) : s √óÀ¢ (b ::‚Çò t) = map (fun a => (a, b)) s + s √óÀ¢ t := by"
  },
  {
    "full_name": "integrable_rpow_mul_exp_neg_mul_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",
    "teorema": "lemma integrable_rpow_mul_exp_neg_mul_sq (b : ‚Ñù) (s : ‚Ñù) : Integrable (fun x => x ^ s * rexp (-b * x ^ 2)) volume := by"
  },
  {
    "full_name": "TopCat.Presheaf.covering_presieve_eq_self",
    "file_path": "Mathlib/Topology/Sheaves/SheafCondition/Sites.lean",
    "teorema": "lemma TopCat.Presheaf.covering_presieve_eq_self (R : Presieve Y) (X : TopCat) (Y : Opens ‚ÜëX) : presieveOfCoveringAux (coveringOfPresieve Y R) Y = R := by"
  },
  {
    "full_name": "Finset.prod_eq_prod_Ico_succ_bot",
    "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean",
    "teorema": "theorem Finset.prod_eq_prod_Ico_succ_bot (M : Type u_2) (a : ‚Ñï) (b : ‚Ñï) (f : ‚Ñï ‚Üí M) : ‚àè k ‚àà Ico a b, f k = f a * ‚àè k ‚àà Ico (a + 1) b, f k := by"
  },
  {
    "full_name": "Orientation.oangle_add_left_eq_arccos_of_oangle_eq_pi_div_two",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/RightAngle.lean",
    "teorema": "theorem Orientation.oangle_add_left_eq_arccos_of_oangle_eq_pi_div_two (V : Type u_1) (o : Orientation ‚Ñù V (Fin 2)) (x : V) (y : V) : o.oangle (x + y) y = ‚Üë(Real.arccos (‚Äñy‚Äñ / ‚Äñx + y‚Äñ)) := by"
  },
  {
    "full_name": "Real.mul_self_sqrt",
    "file_path": "Mathlib/Data/Real/Sqrt.lean",
    "teorema": "theorem Real.mul_self_sqrt (x : ‚Ñù) : ‚àöx * ‚àöx = x := by"
  },
  {
    "full_name": "Asymptotics.IsBigO.integrable",
    "file_path": "Mathlib/MeasureTheory/Integral/Asymptotics.lean",
    "teorema": "theorem Asymptotics.IsBigO.integrable (E : Type u_2) (f : Œ± ‚Üí E) (Œ± : Type u_1) (Œº : Measure Œ±) : Integrable f Œº := by"
  },
  {
    "full_name": "Filter.frequently_iff_forall_eventually_exists_and",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.frequently_iff_forall_eventually_exists_and : False := by"
  },
  {
    "full_name": "Filter.extraction_forall_of_eventually'",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "theorem Filter.extraction_forall_of_eventually' (P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) : ‚àÄ (n : ‚Ñï), ‚àÄ·∂† (k : ‚Ñï) in atTop, P n k := by"
  },
  {
    "full_name": "Matroid.restrict_eq_restrict_iff",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "teorema": "theorem Matroid.restrict_eq_restrict_iff (I : Set Œ±) (M : Matroid Œ±) (X : Set Œ±) (Œ± : Type u_1) : M ‚Üæ X = M' ‚Üæ X ‚Üî ‚àÄ I ‚äÜ X, M.Indep I ‚Üî M'.Indep I := by"
  },
  {
    "full_name": "Part.some_inter_some",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.some_inter_some (a : Œ±) (b : Œ±) (Œ± : Type u_1) : some a ‚à© some b = some (a ‚à© b) := by"
  },
  {
    "full_name": "Finset.mem_inv_smul_finset_iff",
    "file_path": "Mathlib/Data/Finset/Pointwise.lean",
    "teorema": "lemma Finset.mem_inv_smul_finset_iff (a : Œ±) (b : Œ≤) (s : Finset Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : b ‚àà a‚Åª¬π ‚Ä¢ s ‚Üî a ‚Ä¢ b ‚àà s := by"
  },
  {
    "full_name": "integral_comp_neg_Iic",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Integral.lean",
    "teorema": "theorem integral_comp_neg_Iic (E : Type u_1) (c : ‚Ñù) (f : ‚Ñù ‚Üí E) : ‚à´ (x : ‚Ñù) in Iic c, f (-x) = ‚à´ (x : ‚Ñù) in Ioi (-c), f x := by"
  },
  {
    "full_name": "Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range",
    "file_path": "Mathlib/Logic/Equiv/Fintype.lean",
    "teorema": "theorem Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range (b : Œ≤) (e : Perm Œ±) (f : Œ± ‚Ü™ Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (e.viaFintypeEmbedding f) b = b := by"
  },
  {
    "full_name": "IsCyclic.unique_zpow_zmod",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
    "teorema": "lemma IsCyclic.unique_zpow_zmod (a : Œ±) (x : Œ±) (Œ± : Type u) : ‚àÉ! n, x = a ^ n.val := by"
  },
  {
    "full_name": "BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding",
    "file_path": "Mathlib/Topology/TietzeExtension.lean",
    "teorema": "theorem BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding (X : Type u_1) (Y : Type u_2) (e : X ‚Üí Y) (f : X ‚Üí·µá ‚Ñù) : ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß ‚áëg ‚àò e = ‚áëf := by"
  },
  {
    "full_name": "intervalIntegral.integral_comp_neg",
    "file_path": "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean",
    "teorema": "lemma intervalIntegral.integral_comp_neg (E : Type u_3) (a : ‚Ñù) (b : ‚Ñù) (f : ‚Ñù ‚Üí E) : ‚à´ (x : ‚Ñù) in a..b, f (-x) = ‚à´ (x : ‚Ñù) in -b..-a, f x := by"
  },
  {
    "full_name": "NNReal.summable_coe",
    "file_path": "Mathlib/Topology/Instances/NNReal.lean",
    "teorema": "theorem NNReal.summable_coe (f : Œ± ‚Üí ‚Ñù‚â•0) (Œ± : Type u_1) : (Summable fun a => ‚Üë(f a)) ‚Üî Summable f := by"
  },
  {
    "full_name": "RightDerivMeasurableAux.differentiable_set_subset_D",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Measurable.lean",
    "teorema": "lemma RightDerivMeasurableAux.differentiable_set_subset_D (F : Type u_1) (K : Set F) (f : ‚Ñù ‚Üí F) : {x | DifferentiableWithinAt ‚Ñù f (Ici x) x ‚àß derivWithin f (Ici x) x ‚àà K} ‚äÜ D f K := by"
  },
  {
    "full_name": "constantCoeff_wittStructureRat_zero",
    "file_path": "Mathlib/RingTheory/WittVector/StructurePolynomial.lean",
    "teorema": "theorem constantCoeff_wittStructureRat_zero (idx : Type u_2) (p : ‚Ñï) (Œ¶ : MvPolynomial idx ‚Ñö) : constantCoeff (wittStructureRat p Œ¶ 0) = constantCoeff Œ¶ := by"
  },
  {
    "full_name": "cfc_add",
    "file_path": "Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean",
    "teorema": "theorem cfc_add (A : Type u_2) (R : Type u_1) (a : A) (f : R ‚Üí R) (g : R ‚Üí R) : cfc (fun x => f x + g x) a = cfc f a + cfc g a := by"
  },
  {
    "full_name": "PadicSeq.equiv_zero_of_val_eq_of_equiv_zero",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNumbers.lean",
    "teorema": "lemma PadicSeq.equiv_zero_of_val_eq_of_equiv_zero (g : PadicSeq p) (j : ‚Ñï) (p : ‚Ñï) (Œµ : ‚Ñö) : padicNorm p (‚Üë(g - 0) j) < Œµ := by"
  },
  {
    "full_name": "EReal.coe_ennreal_pos",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "lemma EReal.coe_ennreal_pos (x : ‚Ñù‚â•0‚àû) : 0 < ‚Üëx ‚Üî 0 < x := by"
  },
  {
    "full_name": "MeasureTheory.VectorMeasure.subset_le_of_restrict_le_restrict",
    "file_path": "Mathlib/MeasureTheory/Measure/VectorMeasure.lean",
    "teorema": "theorem MeasureTheory.VectorMeasure.subset_le_of_restrict_le_restrict (M : Type u_3) (j : Set Œ±) (v : VectorMeasure Œ± M) (w : VectorMeasure Œ± M) (Œ± : Type u_1) : ‚Üëv j ‚â§ ‚Üëw j := by"
  },
  {
    "full_name": "CategoryTheory.MonoidalCategory.inv_hom_id_tensor",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean",
    "teorema": "theorem CategoryTheory.MonoidalCategory.inv_hom_id_tensor (C : Type u) (V : C) (W : C) (X : C) (Y : C) (Z : C) (f : V ‚âÖ W) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z) : (f.inv ‚äó g) ‚â´ (f.hom ‚äó h) = (ùüô W ‚äó g) ‚â´ (ùüô W ‚äó h) := by"
  },
  {
    "full_name": "Set.Ico_eq_Ico_iff",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Ico_eq_Ico_iff (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÅ : Œ±) (b‚ÇÇ : Œ±) (Œ± : Type u_1) : a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ := by"
  },
  {
    "full_name": "IsCompact.measure_eq_iInf_isOpen",
    "file_path": "Mathlib/MeasureTheory/Measure/Regular.lean",
    "teorema": "theorem IsCompact.measure_eq_iInf_isOpen (K : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº K = ‚®Ö U, ‚®Ö (_ : K ‚äÜ U), ‚®Ö (_ : IsOpen U), Œº U := by"
  },
  {
    "full_name": "one_sub_goldConj",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "teorema": "lemma one_sub_goldConj : 1 - œÜ = œà := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.homMap_apply",
    "file_path": "Mathlib/CategoryTheory/Localization/HomEquiv.lean",
    "teorema": "lemma CategoryTheory.LocalizerMorphism.homMap_apply (C‚ÇÅ : Type u_2) (C‚ÇÇ : Type u_3) (D‚ÇÅ : Type u_5) (D‚ÇÇ : Type u_6) (G : D‚ÇÅ ‚•§ D‚ÇÇ) (L‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (L‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (W‚ÇÅ : MorphismProperty C‚ÇÅ) (W‚ÇÇ : MorphismProperty C‚ÇÇ) (X : C‚ÇÅ) (Y : C‚ÇÅ) (e : Œ¶.functor ‚ãô L‚ÇÇ ‚âÖ L‚ÇÅ ‚ãô G) (f : L‚ÇÅ.obj X ‚ü∂ L‚ÇÅ.obj Y) (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ) : Œ¶.homMap L‚ÇÅ L‚ÇÇ f = e.hom.app X ‚â´ G.map f ‚â´ e.inv.app Y := by"
  },
  {
    "full_name": "Int.existsUnique_mem_box",
    "file_path": "Mathlib/Order/Interval/Finset/Box.lean",
    "teorema": "lemma Int.existsUnique_mem_box (n : ‚Ñï) (x : ‚Ñ§ √ó ‚Ñ§) : ‚àÉ! n, x ‚àà box n := by"
  },
  {
    "full_name": "ENNReal.iInf_sum",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "teorema": "lemma ENNReal.iInf_sum (a : ‚Ñù‚â•0‚àû) (f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Finset Œ±) (Œ± : Type u_2) (Œπ : Sort u_1) : ‚®Ö i, ‚àë a ‚àà s, f i a = ‚àë a ‚àà s, ‚®Ö i, f i a := by"
  },
  {
    "full_name": "Mathlib.Tactic.Ring.atom_pf",
    "file_path": "Mathlib/Tactic/Ring/Basic.lean",
    "teorema": "lemma Mathlib.Tactic.Ring.atom_pf (R : Type u_1) (a : R) : a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 := by"
  },
  {
    "full_name": "Prod.segment_subset",
    "file_path": "Mathlib/Analysis/Convex/Segment.lean",
    "teorema": "lemma Prod.segment_subset (E : Type u_2) (F : Type u_3) (x : E √ó F) (y : E √ó F) (ùïú : Type u_1) : [x-[ùïú]y] ‚äÜ [x.1-[ùïú]y.1] √óÀ¢ [x.2-[ùïú]y.2] := by"
  },
  {
    "full_name": "IsSigmaCompact.image_of_continuousOn",
    "file_path": "Mathlib/Topology/Compactness/SigmaCompact.lean",
    "teorema": "theorem IsSigmaCompact.image_of_continuousOn (X : Type u_1) (Y : Type u_2) (f : X ‚Üí Y) (s : Set X) : IsSigmaCompact (f '' s) := by"
  },
  {
    "full_name": "IsGalois.card_aut_eq_finrank",
    "file_path": "Mathlib/FieldTheory/Galois.lean",
    "teorema": "theorem IsGalois.card_aut_eq_finrank (E : Type u_2) (F : Type u_1) : Fintype.card (E ‚âÉ‚Çê[F] E) = finrank F E := by"
  },
  {
    "full_name": "NNReal.hasSum_coe",
    "file_path": "Mathlib/Topology/Instances/NNReal.lean",
    "teorema": "theorem NNReal.hasSum_coe (f : Œ± ‚Üí ‚Ñù‚â•0) (r : ‚Ñù‚â•0) (Œ± : Type u_1) : HasSum (fun a => ‚Üë(f a)) ‚Üër ‚Üî HasSum f r := by"
  },
  {
    "full_name": "Finsupp.erase_add",
    "file_path": "Mathlib/Data/Finsupp/Defs.lean",
    "teorema": "theorem Finsupp.erase_add (M : Type u_5) (a : Œ±) (f : Œ± ‚Üí‚ÇÄ M) (Œ± : Type u_1) : erase a (f + f') = erase a f + erase a f' := by"
  },
  {
    "full_name": "Rat.neg_mkRat",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.neg_mkRat (d : Nat) (n : Int) : -mkRat n d = mkRat (-n) d := by"
  },
  {
    "full_name": "PFunctor.M.ichildren_mk",
    "file_path": "Mathlib/Data/PFunctor/Univariate/M.lean",
    "teorema": "theorem PFunctor.M.ichildren_mk (F : PFunctor.{u}) (i : F.Idx) (x : ‚ÜëF F.M) : ichildren i (M.mk x) = x.iget i := by"
  },
  {
    "full_name": "Ordinal.log_mono_right",
    "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
    "teorema": "theorem Ordinal.log_mono_right (b : Ordinal.{u_1}) (x : Ordinal.{u_1}) (y : Ordinal.{u_1}) : log b x ‚â§ log b y := by"
  },
  {
    "full_name": "RCLike.add_conj",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "theorem RCLike.add_conj (K : Type u_1) (z : K) : z + (starRingEnd K) z = ‚Üë(re z) + ‚Üë(im z) * I + (‚Üë(re z) - ‚Üë(im z) * I) := by"
  },
  {
    "full_name": "compact_open_separated_mul_left",
    "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean",
    "teorema": "lemma compact_open_separated_mul_left (G : Type w) (K : Set G) (U : Set G) : ‚àÉ V ‚àà ùìù 1, V * K ‚äÜ U := by"
  },
  {
    "full_name": "contDiffAt_map_inverse",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma contDiffAt_map_inverse (E : Type uE) (F : Type uF) (e : E ‚âÉL[ùïú] F) (n : ‚Ñï‚àû) (ùïú : Type u_1) : ContDiffAt ùïú n inverse ‚Üëe := by"
  },
  {
    "full_name": "Finset.max'_mem",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "theorem Finset.max'_mem (H : s.Nonempty) (s : Finset Œ±) (Œ± : Type u_2) : s.max = ‚Üë(s.max' H) := by"
  },
  {
    "full_name": "UFModel.Agrees.push",
    "file_path": "Mathlib/Data/UnionFind.lean",
    "teorema": "lemma UFModel.Agrees.push (arr : Array Œ±) (f : Œ± ‚Üí Œ≤) (m : Fin n ‚Üí Œ≤) (n : ‚Ñï) (x : Œ±) (Œ± : Type u_1) (Œ≤ : Sort u_2) : Agrees (arr.push x) f m' := by"
  },
  {
    "full_name": "inv_mul_cancel_left‚ÇÄ",
    "file_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
    "teorema": "lemma inv_mul_cancel_left‚ÇÄ (G‚ÇÄ : Type u_3) (a : G‚ÇÄ) (b : G‚ÇÄ) : a‚Åª¬π * a * b = b := by"
  },
  {
    "full_name": "Algebra.norm_algebraMap_of_basis",
    "file_path": "Mathlib/RingTheory/Norm.lean",
    "teorema": "lemma Algebra.norm_algebraMap_of_basis (R : Type u_1) (S : Type u_2) (x : R) (Œπ : Type w) : (norm R) ((algebraMap R S) x) = x ^ Fintype.card Œπ := by"
  },
  {
    "full_name": "ModularForm.mul_slash_SL2",
    "file_path": "Mathlib/NumberTheory/ModularForms/SlashActions.lean",
    "teorema": "theorem ModularForm.mul_slash_SL2 (A : SL(2, ‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) (g : ‚Ñç ‚Üí ‚ÑÇ) (k1 : ‚Ñ§) (k2 : ‚Ñ§) : (f * g) ‚à£[k1 + k2] ‚ÜëA = (‚Üë‚Üë‚ÜëA).det ‚Ä¢ f ‚à£[k1] A * g ‚à£[k2] A := by"
  },
  {
    "full_name": "UniqueMDiffWithinAt.smooth_bundle_preimage",
    "file_path": "Mathlib/Geometry/Manifold/MFDeriv/UniqueDifferential.lean",
    "teorema": "theorem UniqueMDiffWithinAt.smooth_bundle_preimage (E : Type u_2) (F : Type u_8) (H : Type u_3) (I : ModelWithCorners ùïú E H) (M : Type u_4) (Z : M ‚Üí Type u_9) (p : TotalSpace F Z) (s : Set M) (ùïú : Type u_1) : UniqueMDiffWithinAt (I.prod ùìò(ùïú, F)) (TotalSpace.proj ‚Åª¬π' s) p := by"
  },
  {
    "full_name": "List.takeD_eq_takeDTR",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "teorema": "theorem List.takeD_eq_takeDTR : @takeD = @takeDTR := by"
  },
  {
    "full_name": "unitInterval.mem_iff_one_sub_mem",
    "file_path": "Mathlib/Topology/UnitInterval.lean",
    "teorema": "theorem unitInterval.mem_iff_one_sub_mem (t : ‚Ñù) : t ‚àà I ‚Üî 1 - t ‚àà I := by"
  },
  {
    "full_name": "Set.encard_tsub_one_le_encard_diff_singleton",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "theorem Set.encard_tsub_one_le_encard_diff_singleton (s : Set Œ±) (x : Œ±) (Œ± : Type u_1) : s.encard - 1 ‚â§ (s \\ {x}).encard := by"
  },
  {
    "full_name": "Ideal.IsPrime.mul_mem_pow",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Ideal.lean",
    "teorema": "lemma Ideal.IsPrime.mul_mem_pow (I : Ideal R) (R : Type u_1) (a : R) (b : R) (n : ‚Ñï) : a ‚àà I ‚à® b ‚àà I ^ n := by"
  },
  {
    "full_name": "MeasureTheory.mem‚Ñíp_zero_iff_aestronglyMeasurable",
    "file_path": "Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean",
    "teorema": "lemma MeasureTheory.mem‚Ñíp_zero_iff_aestronglyMeasurable (E : Type u_2) (f : Œ± ‚Üí E) (Œ± : Type u_1) (Œº : Measure Œ±) : Mem‚Ñíp f 0 Œº ‚Üî AEStronglyMeasurable f Œº := by"
  },
  {
    "full_name": "Ring.DirectLimit.congr_symm_apply_of",
    "file_path": "Mathlib/Algebra/DirectLimit.lean",
    "teorema": "lemma Ring.DirectLimit.congr_symm_apply_of (G : Œπ ‚Üí Type w) (e : (i : Œπ) ‚Üí G i ‚âÉ+* G' i) (f : (i j : Œπ) ‚Üí i ‚â§ j ‚Üí G i ‚Üí+* G j) (g : G' i) (he : ‚àÄ (i j : Œπ) (h : i ‚â§ j), (e j).toRingHom.comp (f i j h) = (f' i j h).comp ‚Üë(e i)) (i : Œπ) (Œπ : Type v) : (congr e he).symm ((of G' (fun x x_1 h => ‚áë(f' x x_1 h)) i) g) = (of G (fun x x_1 h => ‚áë(f x x_1 h)) i) ((e i).symm g) := by"
  },
  {
    "full_name": "eq_one_div_of_mul_eq_one_left",
    "file_path": "Mathlib/Algebra/Group/Basic.lean",
    "teorema": "lemma eq_one_div_of_mul_eq_one_left (a : Œ±) (b : Œ±) (Œ± : Type u_1) : b = 1 / a := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.compProdFun_tsum_left",
    "file_path": "Mathlib/Probability/Kernel/Composition.lean",
    "teorema": "lemma ProbabilityTheory.kernel.compProdFun_tsum_left (a : Œ±) (s : Set (Œ≤ √ó Œ≥)) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_4) (Œ∑ : ‚Ü•(kernel (Œ± √ó Œ≤) Œ≥)) (Œ∫ : ‚Ü•(kernel Œ± Œ≤)) : compProdFun Œ∫ Œ∑ a s = ‚àë' (n : ‚Ñï), compProdFun (seq Œ∫ n) Œ∑ a s := by"
  },
  {
    "full_name": "MulAction.Supports.smul",
    "file_path": "Mathlib/GroupTheory/GroupAction/Support.lean",
    "teorema": "lemma MulAction.Supports.smul (G : Type u_1) (H : Type u_2) (b : Œ≤) (g : H) (s : Set Œ±) (Œ± : Type u_3) (Œ≤ : Type u_4) : Supports G (g ‚Ä¢ s) (g ‚Ä¢ b) := by"
  },
  {
    "full_name": "Set.projIci_eq_self",
    "file_path": "Mathlib/Order/Interval/Set/ProjIcc.lean",
    "teorema": "lemma Set.projIci_eq_self (a : Œ±) (x : Œ±) (Œ± : Type u_1) : projIci a x = ‚ü®a, ‚ãØ‚ü© ‚Üî x ‚â§ a := by"
  },
  {
    "full_name": "nnnorm_mul_le",
    "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean",
    "teorema": "lemma nnnorm_mul_le (a : Œ±) (b : Œ±) (Œ± : Type u_1) : ‚Äña * b‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä * ‚Äñb‚Äñ‚Çä := by"
  },
  {
    "full_name": "IsGLB.biUnion_Ioi_eq",
    "file_path": "Mathlib/Order/Interval/Set/Disjoint.lean",
    "teorema": "theorem IsGLB.biUnion_Ioi_eq (a : Œ±) (s : Set Œ±) (Œ± : Type v) : ‚ãÉ x ‚àà s, Ioi x = Ioi a := by"
  },
  {
    "full_name": "RCLike.conj_smul",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "lemma RCLike.conj_smul (K : Type u_1) (r : ‚Ñù) (z : K) : (starRingEnd K) (r ‚Ä¢ z) = r ‚Ä¢ (starRingEnd K) z := by"
  },
  {
    "full_name": "Polynomial.isNilpotent_C_mul_pow_X_of_isNilpotent",
    "file_path": "Mathlib/RingTheory/Polynomial/Nilpotent.lean",
    "teorema": "lemma Polynomial.isNilpotent_C_mul_pow_X_of_isNilpotent (R : Type u_1) (n : ‚Ñï) (r : R) : IsNilpotent (C r * X ^ n) := by"
  },
  {
    "full_name": "AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection_germ",
    "file_path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",
    "teorema": "lemma AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection_germ (A : Type u_2) (R : Type u_1) (f : A) (x : ‚Ü•(pbo f)) (ùíú : ‚Ñï ‚Üí Submodule R A) : awayToSection ùíú f ‚â´ (structureSheaf ùíú).presheaf.germ x = HomogeneousLocalization.mapId ùíú ‚ãØ ‚â´ (Proj.stalkIso' ùíú ‚Üëx).toCommRingCatIso.inv := by"
  },
  {
    "full_name": "Measurable.nnreal_tsum",
    "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean",
    "teorema": "lemma Measurable.nnreal_tsum (f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0) (Œ± : Type u_1) (Œπ : Type u_5) : Measurable fun x => ‚àë' (i : Œπ), f i x := by"
  },
  {
    "full_name": "PosNum.to_nat_inj",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "lemma PosNum.to_nat_inj (m : PosNum) (n : PosNum) : pos m = pos n := by"
  },
  {
    "full_name": "Complex.add_conj",
    "file_path": "Mathlib/Data/Complex/Basic.lean",
    "teorema": "lemma Complex.add_conj (z : ‚ÑÇ) : (z + (starRingEnd ‚ÑÇ) z).re = (‚Üë(2 * z.re)).re ‚àß (z + (starRingEnd ‚ÑÇ) z).im = (‚Üë(2 * z.re)).im := by"
  },
  {
    "full_name": "AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk",
    "file_path": "Mathlib/RingTheory/AdjoinRoot.lean",
    "teorema": "lemma AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk (I : Ideal R) (R : Type u) (f : R[X]) (p : R[X]) : (quotAdjoinRootEquivQuotPolynomialQuot I f).symm ((Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) f})) (Polynomial.map (Ideal.Quotient.mk I) p)) = (Ideal.Quotient.mk (Ideal.map (of f) I)) ((mk f) p) := by"
  },
  {
    "full_name": "Mathlib.Meta.NormNum.isRat_inv_pos",
    "file_path": "Mathlib/Tactic/NormNum/Inv.lean",
    "teorema": "theorem Mathlib.Meta.NormNum.isRat_inv_pos (a : Œ±) (d : ‚Ñï) (n : ‚Ñï) (Œ± : Type u_1) : IsRat a (Int.ofNat n.succ) d ‚Üí IsRat a‚Åª¬π (Int.ofNat d) n.succ := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.density_nonneg",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
    "teorema": "theorem ProbabilityTheory.kernel.density_nonneg (a : Œ±) (s : Set Œ≤) (x : Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œ∫ : ‚Ü•(kernel Œ± (Œ≥ √ó Œ≤))) (ŒΩ : ‚Ü•(kernel Œ± Œ≥)) : 0 ‚â§ density Œ∫ ŒΩ a x s := by"
  },
  {
    "full_name": "Multiset.le_inter",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.le_inter (s : Multiset Œ±) (t : Multiset Œ±) (u : Multiset Œ±) (Œ± : Type u_1) : s ‚â§ t ‚à© u := by"
  },
  {
    "full_name": "Nat.WithBot.add_one_le_of_lt",
    "file_path": "Mathlib/Data/Nat/WithBot.lean",
    "teorema": "lemma Nat.WithBot.add_one_le_of_lt (m : WithBot ‚Ñï) (n : WithBot ‚Ñï) : n + 1 ‚â§ m := by"
  },
  {
    "full_name": "Matrix.det_updateColumn_add_self",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
    "teorema": "lemma Matrix.det_updateColumn_add_self (A : Matrix n n R) (R : Type v) (i : n) (j : n) (n : Type u_2) : (A.updateColumn i fun k => A k i + A k j).det = A.det := by"
  },
  {
    "full_name": "Subgroup.MemRightTransversals.toEquiv_apply",
    "file_path": "Mathlib/GroupTheory/Complement.lean",
    "teorema": "theorem Subgroup.MemRightTransversals.toEquiv_apply (G : Type u_1) (H : Subgroup G) (f : Quotient (QuotientGroup.rightRel H) ‚Üí G) (q : Quotient (QuotientGroup.rightRel H)) : ‚Üë((toEquiv ‚ãØ) q) = f q := by"
  },
  {
    "full_name": "Stream'.WSeq.exists_of_liftRel_right",
    "file_path": "Mathlib/Data/Seq/WSeq.lean",
    "teorema": "lemma Stream'.WSeq.exists_of_liftRel_right (R : Œ± ‚Üí Œ≤ ‚Üí Prop) (b : Œ≤) (s : WSeq Œ±) (Œ± : Type u) (Œ≤ : Type v) : ‚àÉ a, a ‚àà s ‚àß R a b := by"
  },
  {
    "full_name": "MeasureTheory.locallyIntegrableOn_of_locallyIntegrable_restrict",
    "file_path": "Mathlib/MeasureTheory/Function/LocallyIntegrable.lean",
    "teorema": "lemma MeasureTheory.locallyIntegrableOn_of_locallyIntegrable_restrict (E : Type u_3) (X : Type u_1) (f : X ‚Üí E) (s : Set X) (Œº : Measure X) : LocallyIntegrableOn f s Œº := by"
  },
  {
    "full_name": "ENNReal.smul_sSup",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "theorem ENNReal.smul_sSup (R : Type u_4) (c : R) (s : Set ‚Ñù‚â•0‚àû) : c ‚Ä¢ sSup s = ‚®Ü i ‚àà s, c ‚Ä¢ i := by"
  },
  {
    "full_name": "UniqueMul.of_image_filter",
    "file_path": "Mathlib/Algebra/Group/UniqueProds.lean",
    "teorema": "theorem UniqueMul.of_image_filter (G : Type u_1) (a : G) (aG : G) (b : G) (bG : G) : a = aG ‚àß b = bG := by"
  },
  {
    "full_name": "Nat.prod_pow_pos_of_zero_not_mem_support",
    "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean",
    "teorema": "lemma Nat.prod_pow_pos_of_zero_not_mem_support : False := by"
  },
  {
    "full_name": "Matrix.PosSemidef.fromBlocks‚ÇÅ‚ÇÅ",
    "file_path": "Mathlib/LinearAlgebra/Matrix/SchurComplement.lean",
    "teorema": "lemma Matrix.PosSemidef.fromBlocks‚ÇÅ‚ÇÅ (A : Matrix m m ùïú) (B : Matrix m n ùïú) (D : Matrix n n ùïú) (m : Type u_2) (n : Type u_3) (ùïú : Type u_5) : (fromBlocks A B B·¥¥ D).PosSemidef ‚Üî (D - B·¥¥ * A‚Åª¬π * B).PosSemidef := by"
  },
  {
    "full_name": "Function.mulSupport_update_of_ne_one",
    "file_path": "Mathlib/Algebra/Group/Support.lean",
    "teorema": "lemma Function.mulSupport_update_of_ne_one (M : Type u_5) (f : Œ± ‚Üí M) (x : Œ±) (y : M) (Œ± : Type u_1) : mulSupport (update f x y) = insert x (mulSupport f) := by"
  },
  {
    "full_name": "Multiset.gcd_union",
    "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
    "teorema": "theorem Multiset.gcd_union (s‚ÇÅ : Multiset Œ±) (s‚ÇÇ : Multiset Œ±) (Œ± : Type u_1) : (s‚ÇÅ ‚à™ s‚ÇÇ).gcd = GCDMonoid.gcd s‚ÇÅ.gcd s‚ÇÇ.gcd := by"
  },
  {
    "full_name": "Multiset.Icc_eq_zero_iff",
    "file_path": "Mathlib/Order/Interval/Multiset.lean",
    "teorema": "lemma Multiset.Icc_eq_zero_iff (a : Œ±) (b : Œ±) (Œ± : Type u_1) : Icc a b = 0 ‚Üî ¬¨a ‚â§ b := by"
  },
  {
    "full_name": "Set.pairwise_univ",
    "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean",
    "teorema": "theorem Set.pairwise_univ (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : univ.Pairwise r ‚Üî Pairwise r := by"
  },
  {
    "full_name": "Finset.affineCombination_filter_of_ne",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean",
    "teorema": "lemma Finset.affineCombination_filter_of_ne (P : Type u_3) (k : Type u_1) (p : Œπ ‚Üí P) (pred : Œπ ‚Üí Prop) (s : Finset Œπ) (w : Œπ ‚Üí k) (Œπ : Type u_4) : (affineCombination k (filter pred s) p) w = (affineCombination k s p) w := by"
  },
  {
    "full_name": "Filter.pi_eq_bot",
    "file_path": "Mathlib/Order/Filter/Pi.lean",
    "teorema": "theorem Filter.pi_eq_bot (f : (i : Œπ) ‚Üí Filter (Œ± i)) (Œ± : Œπ ‚Üí Type u_2) (Œπ : Type u_1) : pi f = ‚ä• ‚Üî ‚àÉ i, f i = ‚ä• := by"
  },
  {
    "full_name": "iterateFrobeniusEquiv_symm_add_apply",
    "file_path": "Mathlib/FieldTheory/Perfect.lean",
    "teorema": "theorem iterateFrobeniusEquiv_symm_add_apply (R : Type u_1) (m : ‚Ñï) (n : ‚Ñï) (p : ‚Ñï) (x : R) : (iterateFrobeniusEquiv R p (m + n)) ((iterateFrobeniusEquiv R p (m + n)).symm x) = (iterateFrobeniusEquiv R p (m + n)) ((iterateFrobeniusEquiv R p m).symm ((iterateFrobeniusEquiv R p n).symm x)) := by"
  },
  {
    "full_name": "Set.Ioi_mul_Ici_subset'",
    "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean",
    "teorema": "theorem Set.Ioi_mul_Ici_subset' (a : Œ±) (b : Œ±) (Œ± : Type u_1) : Ioi a * Ici b ‚äÜ Ioi (a * b) := by"
  },
  {
    "full_name": "EReal.image_coe_Iio",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "theorem EReal.image_coe_Iio (x : ‚Ñù) : Real.toEReal '' Iio x = Ioo ‚ä• ‚Üëx := by"
  },
  {
    "full_name": "Real.tendsto_exp_div_pow_atTop",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
    "teorema": "theorem Real.tendsto_exp_div_pow_atTop (n : ‚Ñï) (x : ‚Ñù) : Tendsto (fun x => rexp x / x ^ n) atTop atTop := by"
  },
  {
    "full_name": "FractionalIdeal.count_zero",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Factorization.lean",
    "teorema": "lemma FractionalIdeal.count_zero (K : Type u_2) (R : Type u_1) (v : HeightOneSpectrum R) : count K v 0 = 0 := by"
  },
  {
    "full_name": "CategoryTheory.eqToHom_comp_iff",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "theorem CategoryTheory.eqToHom_comp_iff (C : Type u‚ÇÅ) (X : C) (Y : C) (g : X' ‚ü∂ Y) (p : X = X') : g = eqToHom ‚ãØ ‚â´ eqToHom p ‚â´ g := by"
  },
  {
    "full_name": "Real.exists_rat_pow_btwn_rat_aux",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "lemma Real.exists_rat_pow_btwn_rat_aux (n : ‚Ñï) (x : ‚Ñù) (y : ‚Ñù) : ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y := by"
  },
  {
    "full_name": "UniqueFactorizationMonoid.normalize_normalized_factor",
    "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean",
    "teorema": "theorem UniqueFactorizationMonoid.normalize_normalized_factor (a : Œ±) (Œ± : Type u_1) : ‚àÄ x ‚àà normalizedFactors a, normalize x = x := by"
  },
  {
    "full_name": "Real.mul_le_sin",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean",
    "teorema": "theorem Real.mul_le_sin (x : ‚Ñù) : 2 / œÄ * x ‚â§ sin x := by"
  },
  {
    "full_name": "Bornology.isVonNBounded_insert",
    "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean",
    "teorema": "theorem Bornology.isVonNBounded_insert (E : Type u_3) (s : Set E) (x : E) (ùïú : Type u_1) : IsVonNBounded ùïú (insert x s) ‚Üî IsVonNBounded ùïú s := by"
  },
  {
    "full_name": "monovary_inv‚ÇÄ",
    "file_path": "Mathlib/Algebra/Order/Monovary.lean",
    "teorema": "lemma monovary_inv‚ÇÄ (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œπ : Type u_1) : Monovary f‚Åª¬π g‚Åª¬π ‚Üî Monovary f g := by"
  },
  {
    "full_name": "smul_balancedCore_subset",
    "file_path": "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean",
    "teorema": "theorem smul_balancedCore_subset (E : Type u_2) (a : ùïú) (s : Set E) (ùïú : Type u_1) : a ‚Ä¢ balancedCore ùïú s ‚äÜ balancedCore ùïú s := by"
  },
  {
    "full_name": "List.enumFrom_eq_nil",
    "file_path": "Mathlib/Data/List/Enum.lean",
    "teorema": "theorem List.enumFrom_eq_nil (l : List Œ±) (n : ‚Ñï) (Œ± : Type u_1) : enumFrom n l = [] ‚Üî l = [] := by"
  },
  {
    "full_name": "Nat.or_exists_succ",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "lemma Nat.or_exists_succ (n : ‚Ñï) (p : ‚Ñï ‚Üí Prop) : (‚àÉ n, p n) ‚Üí p 0 ‚à® ‚àÉ n, p (n + 1) := by"
  },
  {
    "full_name": "IsUnit.smul_sub_iff_sub_inv_smul",
    "file_path": "Mathlib/GroupTheory/GroupAction/Group.lean",
    "teorema": "lemma IsUnit.smul_sub_iff_sub_inv_smul (a : Œ≤) (r : Œ±) (Œ± : Type u) (Œ≤ : Type v) : IsUnit (r ‚Ä¢ 1 - a) ‚Üî IsUnit (1 - r‚Åª¬π ‚Ä¢ a) := by"
  },
  {
    "full_name": "HasFiniteFPowerSeriesOnBall.changeOrigin",
    "file_path": "Mathlib/Analysis/Analytic/CPolynomial.lean",
    "teorema": "theorem HasFiniteFPowerSeriesOnBall.changeOrigin (E : Type u_2) (r : ‚Ñù‚â•0‚àû) (y : E) : 0 < r - ‚Üë‚Äñy‚Äñ‚Çä := by"
  },
  {
    "full_name": "Set.image_mono",
    "file_path": "Mathlib/Data/Set/Image.lean",
    "teorema": "theorem Set.image_mono (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : f '' s ‚äÜ f '' t := by"
  },
  {
    "full_name": "Filter.EventuallyEq.restrict",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "theorem Filter.EventuallyEq.restrict (f : Œ± ‚Üí Œ¥) (g : Œ± ‚Üí Œ¥) (s : Set Œ±) (Œ± : Type u_2) (Œ¥ : Type u_4) (Œº : Measure Œ±) : f =·∂†[ae (Œº.restrict s)] g := by"
  },
  {
    "full_name": "Fin.castAdd_inj",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.castAdd_inj (a : Fin m) (b : Fin m) (m : ‚Ñï) (n : ‚Ñï) : castAdd n a = castAdd n b ‚Üî a = b := by"
  },
  {
    "full_name": "Matrix.conjTranspose_zpow",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "teorema": "lemma Matrix.conjTranspose_zpow (A : M) (n : ‚Ñï) : (A ^ ‚Üën)·¥¥ = A·¥¥ ^ ‚Üën := by"
  },
  {
    "full_name": "List.countP_join'",
    "file_path": "Mathlib/Data/List/Join.lean",
    "teorema": "lemma List.countP_join' (a : List Œ±) (l : List (List Œ±)) (p : Œ± ‚Üí Bool) (Œ± : Type u_1) : countP p (a :: l).join = Nat.sum (map (countP p) (a :: l)) := by"
  },
  {
    "full_name": "NormedSpace.vonNBornology_eq",
    "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean",
    "teorema": "theorem NormedSpace.vonNBornology_eq (E : Type u_3) (ùïú : Type u_1) : Bornology.vonNBornology ùïú E = PseudoMetricSpace.toBornology := by"
  },
  {
    "full_name": "Rat.mkRat_nonneg",
    "file_path": "Mathlib/Algebra/Order/Ring/Rat.lean",
    "teorema": "lemma Rat.mkRat_nonneg (a : ‚Ñ§) (b : ‚Ñï) : 0 ‚â§ mkRat a b := by"
  },
  {
    "full_name": "dist_vadd_left",
    "file_path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean",
    "teorema": "theorem dist_vadd_left (P : Type u_3) (V : Type u_2) (v : V) (x : P) : dist (v +·µ• x) x = ‚Äñv‚Äñ := by"
  },
  {
    "full_name": "ContDiffAt.dist",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Calculus.lean",
    "teorema": "lemma ContDiffAt.dist (E : Type u_2) (G : Type u_4) (f : G ‚Üí E) (g : G ‚Üí E) (n : ‚Ñï‚àû) (x : G) : ContDiffAt ‚Ñù n (fun y => Dist.dist (f y) (g y)) x := by"
  },
  {
    "full_name": "Set.image_const_sub_uIcc",
    "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean",
    "teorema": "lemma Set.image_const_sub_uIcc (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : (fun x => a - x) '' [[b, c]] = [[a - b, a - c]] := by"
  },
  {
    "full_name": "Nat.div_ne_zero_iff_of_dvd",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "theorem Nat.div_ne_zero_iff_of_dvd (a : ‚Ñï) (b : ‚Ñï) : a / b ‚â† 0 ‚Üî a ‚â† 0 ‚àß b ‚â† 0 := by"
  },
  {
    "full_name": "isQuasiSeparated_univ_iff",
    "file_path": "Mathlib/Topology/QuasiSeparated.lean",
    "teorema": "lemma isQuasiSeparated_univ_iff (Œ± : Type u_3) : IsQuasiSeparated Set.univ ‚Üî QuasiSeparatedSpace Œ± := by"
  },
  {
    "full_name": "MeasureTheory.measure_le_average_pos",
    "file_path": "Mathlib/MeasureTheory/Integral/Average.lean",
    "teorema": "theorem MeasureTheory.measure_le_average_pos (f : Œ± ‚Üí ‚Ñù) (Œ± : Type u_1) (Œº : Measure Œ±) : 0 < Œº {x | f x ‚â§ ‚®ç (a : Œ±), f a ‚àÇŒº} := by"
  },
  {
    "full_name": "Int.bitwise_bit",
    "file_path": "Mathlib/Data/Int/Bitwise.lean",
    "teorema": "theorem Int.bitwise_bit (a : Bool) (b : Bool) (f : Bool ‚Üí Bool ‚Üí Bool) (m : ‚Ñ§) (n : ‚Ñ§) : bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by"
  },
  {
    "full_name": "Real.log_sqrt",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "teorema": "theorem Real.log_sqrt (x : ‚Ñù) : log ‚àöx = log x / 2 := by"
  },
  {
    "full_name": "openEmbedding_sigma_map",
    "file_path": "Mathlib/Topology/Constructions.lean",
    "teorema": "theorem openEmbedding_sigma_map (f‚ÇÅ : Œπ ‚Üí Œ∫) (f‚ÇÇ : (i : Œπ) ‚Üí œÉ i ‚Üí œÑ (f‚ÇÅ i)) (Œπ : Type u_5) (Œ∫ : Type u_6) (œÉ : Œπ ‚Üí Type u_7) (œÑ : Œ∫ ‚Üí Type u_8) : OpenEmbedding (Sigma.map f‚ÇÅ f‚ÇÇ) ‚Üî ‚àÄ (i : Œπ), OpenEmbedding (f‚ÇÇ i) := by"
  },
  {
    "full_name": "WithTop.map‚ÇÇ_coe_right",
    "file_path": "Mathlib/Order/WithBot.lean",
    "teorema": "lemma WithTop.map‚ÇÇ_coe_right (a : WithTop Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : map‚ÇÇ f a ‚Üëb = map (fun x => f x b) a := by"
  },
  {
    "full_name": "Matrix.isUnit_fromBlocks_zero‚ÇÅ‚ÇÇ",
    "file_path": "Mathlib/LinearAlgebra/Matrix/SchurComplement.lean",
    "teorema": "lemma Matrix.isUnit_fromBlocks_zero‚ÇÅ‚ÇÇ (A : Matrix m m Œ±) (C : Matrix n m Œ±) (D : Matrix n n Œ±) (m : Type u_2) (n : Type u_3) (Œ± : Type u_4) : IsUnit (fromBlocks A 0 C D) ‚Üî IsUnit A ‚àß IsUnit D := by"
  },
  {
    "full_name": "MeasureTheory.DominatedFinMeasAdditive.of_smul_measure",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "lemma MeasureTheory.DominatedFinMeasAdditive.of_smul_measure (C : ‚Ñù) (T : Set Œ± ‚Üí Œ≤) (c : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œ≤ : Type u_7) (Œº : Measure Œ±) : DominatedFinMeasAdditive Œº T (c.toReal * C) := by"
  },
  {
    "full_name": "MeasureTheory.AEStronglyMeasurable.ae_integrable_condKernel_iff",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Integral.lean",
    "teorema": "theorem MeasureTheory.AEStronglyMeasurable.ae_integrable_condKernel_iff (F : Type u_4) (f : Œ± √ó Œ© ‚Üí F) (Œ© : Type u_2) (Œ± : Type u_1) (œÅ : Measure (Œ± √ó Œ©)) : (‚àÄ·µê (a : Œ±) ‚àÇœÅ.fst, Integrable (fun œâ => f (a, œâ)) (œÅ.condKernel a)) ‚àß := by"
  },
  {
    "full_name": "smul_inv_smul",
    "file_path": "Mathlib/GroupTheory/GroupAction/Group.lean",
    "teorema": "lemma smul_inv_smul (c : Œ±) (x : Œ≤) (Œ± : Type u) (Œ≤ : Type v) : c ‚Ä¢ c‚Åª¬π ‚Ä¢ x = x := by"
  },
  {
    "full_name": "RingHom.pNilradical_le_ker_of_perfectRing",
    "file_path": "Mathlib/FieldTheory/IsPerfectClosure.lean",
    "teorema": "lemma RingHom.pNilradical_le_ker_of_perfectRing (K : Type u_1) (L : Type u_2) (i : K ‚Üí+* L) (x : K) : x ‚àà ker i := by"
  },
  {
    "full_name": "infPrime_iff_infIrred",
    "file_path": "Mathlib/Order/Irreducible.lean",
    "teorema": "theorem infPrime_iff_infIrred (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_2) : b ‚äì c ‚â§ a ‚Üí b ‚â§ a ‚à® c ‚â§ a := by"
  },
  {
    "full_name": "Nat.count_one",
    "file_path": "Mathlib/Data/Nat/Count.lean",
    "teorema": "lemma Nat.count_one (p : ‚Ñï ‚Üí Prop) : count p 1 = if p 0 then 1 else 0 := by"
  },
  {
    "full_name": "TensorProduct.liftAux.smul",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean",
    "teorema": "lemma TensorProduct.liftAux.smul (M : Type u_4) (N : Type u_5) (P : Type u_6) (R : Type u_1) (f : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) (p : M) (q : N) (r : R) : (liftAux f) (r ‚Ä¢ p ‚äó‚Çú[R] q) = r ‚Ä¢ (liftAux f) (p ‚äó‚Çú[R] q) := by"
  },
  {
    "full_name": "NumberField.mem_span_integralBasis",
    "file_path": "Mathlib/NumberTheory/NumberField/Basic.lean",
    "teorema": "theorem NumberField.mem_span_integralBasis (K : Type u_1) (x : K) : x ‚àà Submodule.span ‚Ñ§ (Set.range ‚áë(integralBasis K)) ‚Üî x ‚àà (algebraMap (ùìû K) K).range := by"
  },
  {
    "full_name": "MvPolynomial.weightedHomogeneousComponent_eq_zero",
    "file_path": "Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean",
    "teorema": "theorem MvPolynomial.weightedHomogeneousComponent_eq_zero (M : Type u_2) (R : Type u_1) (n : M) (w : œÉ ‚Üí M) (œÉ : Type u_3) (œÜ : MvPolynomial œÉ R) : (weightedHomogeneousComponent w n) œÜ = 0 := by"
  },
  {
    "full_name": "IsPurelyInseparable.tower_bot",
    "file_path": "Mathlib/FieldTheory/PurelyInseparable.lean",
    "teorema": "theorem IsPurelyInseparable.tower_bot (E : Type v) (F : Type u) : IsPurelyInseparable F E := by"
  },
  {
    "full_name": "Finset.card_union_eq_card_add_card",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "lemma Finset.card_union_eq_card_add_card (s : Finset Œ±) (t : Finset Œ±) (Œ± : Type u_1) : (s ‚à™ t).card = s.card + t.card ‚Üî _root_.Disjoint s t := by"
  },
  {
    "full_name": "sdiff_lt",
    "file_path": "Mathlib/Order/BooleanAlgebra.lean",
    "teorema": "theorem sdiff_lt (x : Œ±) (y : Œ±) (Œ± : Type u) : x \\ y < x := by"
  },
  {
    "full_name": "nonneg_iff_isSelfAdjoint_and_quasispectrumRestricts",
    "file_path": "Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean",
    "teorema": "theorem nonneg_iff_isSelfAdjoint_and_quasispectrumRestricts (A : Type u_1) (a : A) : 0 ‚â§ a ‚Üî IsSelfAdjoint a ‚àß QuasispectrumRestricts a ‚áëContinuousMap.realToNNReal := by"
  },
  {
    "full_name": "MeasureTheory.Lp.norm_const",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "theorem MeasureTheory.Lp.norm_const (E : Type u_2) (c : E) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚Äñ(Lp.const p Œº) c‚Äñ = ‚Äñc‚Äñ * (Œº Set.univ).toReal ^ (1 / p.toReal) := by"
  },
  {
    "full_name": "MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto",
    "file_path": "Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean",
    "teorema": "lemma MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto (E : Type u_1) (a : ‚Ñù) (f : ‚Ñù ‚Üí E) (m : E) : ‚à´ (x : ‚Ñù) in Ioi a, f' x = m - f a := by"
  },
  {
    "full_name": "BoxIntegral.Box.measurableSet_coe",
    "file_path": "Mathlib/Analysis/BoxIntegral/Partition/Measure.lean",
    "teorema": "theorem BoxIntegral.Box.measurableSet_coe (I : Box Œπ) (Œπ : Type u_1) : MeasurableSet ‚ÜëI := by"
  },
  {
    "full_name": "Sum.lex_acc_inr",
    "file_path": ".lake/packages/batteries/Batteries/Data/Sum/Lemmas.lean",
    "teorema": "lemma Sum.lex_acc_inr (b : Œ≤‚úù) (r : Œ±‚úù ‚Üí Œ±‚úù ‚Üí Prop) (s : Œ≤‚úù ‚Üí Œ≤‚úù ‚Üí Prop) : Acc (Lex r s) (inr b) := by"
  },
  {
    "full_name": "Nat.bit0_val",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "teorema": "lemma Nat.bit0_val (n : ‚Ñï) : n + n = 0 + n + n := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.densityProcess_fst_univ_ae",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
    "teorema": "theorem ProbabilityTheory.kernel.densityProcess_fst_univ_ae (a : Œ±) (n : ‚Ñï) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œ∫ : ‚Ü•(kernel Œ± (Œ≥ √ó Œ≤))) : ‚àÄ·µê (x : Œ≥) ‚àÇ(fst Œ∫) a, densityProcess Œ∫ (fst Œ∫) n a x univ = 1 := by"
  },
  {
    "full_name": "TensorProduct.LieModule.liftLie_apply",
    "file_path": "Mathlib/Algebra/Lie/TensorProduct.lean",
    "teorema": "theorem TensorProduct.LieModule.liftLie_apply (L : Type v) (M : Type w) (N : Type w‚ÇÅ) (P : Type w‚ÇÇ) (R : Type u) (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N ‚Üí‚Çó[R] P) (m : M) (n : N) : ((liftLie R L M N P) f) (m ‚äó‚Çú[R] n) = (f m) n := by"
  },
  {
    "full_name": "Rat.divInt_nonneg",
    "file_path": "Mathlib/Algebra/Order/Ring/Rat.lean",
    "teorema": "lemma Rat.divInt_nonneg (a : ‚Ñ§) (b : ‚Ñ§) : 0 ‚â§ a /. b := by"
  },
  {
    "full_name": "TotallyBounded.isSeparable",
    "file_path": "Mathlib/Topology/Metrizable/Uniformity.lean",
    "teorema": "lemma TotallyBounded.isSeparable (X : Type u_1) (s : Set X) : TopologicalSpace.IsSeparable s := by"
  },
  {
    "full_name": "FractionalIdeal.dual_inv",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Different.lean",
    "teorema": "lemma FractionalIdeal.dual_inv (A : Type u_1) (I : FractionalIdeal B‚Å∞ L) (K : Type u_2) (L : Type u) : dual A K I‚Åª¬π = dual A K 1 * I := by"
  },
  {
    "full_name": "normEDS_three",
    "file_path": "Mathlib/NumberTheory/EllipticDivisibilitySequence.lean",
    "teorema": "theorem normEDS_three (R : Type u) (b : R) (c : R) (d : R) : normEDS b c d 3 = c := by"
  },
  {
    "full_name": "CategoryTheory.monoidalOfHasFiniteProducts.associator_hom_fst",
    "file_path": "Mathlib/CategoryTheory/Monoidal/OfHasFiniteProducts.lean",
    "teorema": "lemma CategoryTheory.monoidalOfHasFiniteProducts.associator_hom_fst (C : Type u) (X : C) (Y : C) (Z : C) : (Œ±_ X Y Z).hom ‚â´ prod.fst = prod.fst ‚â´ prod.fst := by"
  },
  {
    "full_name": "Cardinal.cantor",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "theorem Cardinal.cantor (a : Cardinal.{u}) : a < 2 ^ a := by"
  },
  {
    "full_name": "Ideal.exists_comap_eq_of_mem_minimalPrimes",
    "file_path": "Mathlib/RingTheory/Ideal/MinimalPrime.lean",
    "teorema": "theorem Ideal.exists_comap_eq_of_mem_minimalPrimes (I : Ideal S) (R : Type u_1) (S : Type u_2) (f : R ‚Üí+* S) (p : Ideal R) : ‚àÉ p', p'.IsPrime ‚àß I ‚â§ p' ‚àß comap f p' = p := by"
  },
  {
    "full_name": "Polynomial.leadingCoeff_prod",
    "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
    "teorema": "lemma Polynomial.leadingCoeff_prod (R : Type u) (f : Œπ ‚Üí R[X]) (s : Finset Œπ) (Œπ : Type w) : (‚àè i ‚àà s, f i).leadingCoeff = ‚àè i ‚àà s, (f i).leadingCoeff := by"
  },
  {
    "full_name": "CochainComplex.mappingCone.ext_cochain_to_iff",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean",
    "teorema": "theorem CochainComplex.mappingCone.ext_cochain_to_iff (C : Type u_1) (F : CochainComplex C ‚Ñ§) (G : CochainComplex C ‚Ñ§) (K : CochainComplex C ‚Ñ§) (hij : i + 1 = j) (i : ‚Ñ§) (j : ‚Ñ§) (Œ≥‚ÇÅ : Cochain K (mappingCone œÜ) i) (Œ≥‚ÇÇ : Cochain K (mappingCone œÜ) i) (œÜ : F ‚ü∂ G) : Œ≥‚ÇÅ = Œ≥‚ÇÇ ‚Üî Œ≥‚ÇÅ.comp (‚Üë(fst œÜ)) hij = Œ≥‚ÇÇ.comp (‚Üë(fst œÜ)) hij ‚àß Œ≥‚ÇÅ.comp (snd œÜ) ‚ãØ = Œ≥‚ÇÇ.comp (snd œÜ) ‚ãØ := by"
  },
  {
    "full_name": "Batteries.HashMap.Imp.Buckets.WF.update",
    "file_path": ".lake/packages/batteries/Batteries/Data/HashMap/WF.lean",
    "teorema": "theorem Batteries.HashMap.Imp.Buckets.WF.update (buckets : Buckets Œ± Œ≤) (d : AssocList Œ± Œ≤) (h : i.toNat < buckets.val.size) (i : USize) (Œ± : Type u_1) (Œ≤ : Type u_2) : (buckets.update i d h).WF := by"
  },
  {
    "full_name": "Prod.smul_mk_zero",
    "file_path": "Mathlib/GroupTheory/GroupAction/Prod.lean",
    "teorema": "lemma Prod.smul_mk_zero (M : Type u_1) (a : M) (b : Œ±) (Œ± : Type u_5) : a ‚Ä¢ (b, 0) = (a ‚Ä¢ b, 0) := by"
  },
  {
    "full_name": "Set.Ioc_union_Ioc_left",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Ioc_union_Ioc_left (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : Ioc a c ‚à™ Ioc b c = Ioc (min a b) c := by"
  },
  {
    "full_name": "Finset.sup_product_right",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "lemma Finset.sup_product_right (f : Œ≤ √ó Œ≥ ‚Üí Œ±) (s : Finset Œ≤) (t : Finset Œ≥) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œ≥ : Type u_4) : (s √óÀ¢ t).sup f = t.sup fun i' => s.sup fun i => f (i, i') := by"
  },
  {
    "full_name": "isSolvable_of_comm",
    "file_path": "Mathlib/GroupTheory/Solvable.lean",
    "teorema": "lemma isSolvable_of_comm (G : Type u_3) : IsSolvable G := by"
  },
  {
    "full_name": "hasDerivAt_mul_const",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean",
    "teorema": "theorem hasDerivAt_mul_const (c : ùïú) (u : ùïú ‚Üí ùïú') (x : ùïú) (ùïú : Type u) : HasDerivAt (fun x => x * c) c x := by"
  },
  {
    "full_name": "Complex.arg_eq_nhds_of_re_neg_of_im_neg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean",
    "teorema": "lemma Complex.arg_eq_nhds_of_re_neg_of_im_neg (x : ‚ÑÇ) : arg =·∂†[ùìù x] fun x => Real.arcsin ((-x).im / abs x) - œÄ := by"
  },
  {
    "full_name": "CategoryTheory.InjectiveResolution.homotopyEquiv_hom_Œπ",
    "file_path": "Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean",
    "teorema": "lemma CategoryTheory.InjectiveResolution.homotopyEquiv_hom_Œπ (C : Type u) (I : InjectiveResolution X) (J : InjectiveResolution X) (X : C) : I.Œπ ‚â´ (I.homotopyEquiv J).hom = J.Œπ := by"
  },
  {
    "full_name": "Polynomial.mul_coeff_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Coeff.lean",
    "teorema": "theorem Polynomial.mul_coeff_zero (R : Type u) (p : R[X]) (q : R[X]) : (p * q).coeff 0 = p.coeff 0 * q.coeff 0 := by"
  },
  {
    "full_name": "Monotone.cauchySeq_alternating_series_of_tendsto_zero",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "lemma Monotone.cauchySeq_alternating_series_of_tendsto_zero (f : ‚Ñï ‚Üí ‚Ñù) : CauchySeq fun n => ‚àë i ‚àà Finset.range n, (-1) ^ i * f i := by"
  },
  {
    "full_name": "MeasureTheory.restrict_trim",
    "file_path": "Mathlib/MeasureTheory/Measure/Trim.lean",
    "teorema": "theorem MeasureTheory.restrict_trim (hm : m ‚â§ m0) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (Œº.trim hm).restrict s = (Œº.restrict s).trim hm := by"
  },
  {
    "full_name": "SecondCountableTopology.of_separableSpace_orderTopology",
    "file_path": "Mathlib/Topology/Order/Basic.lean",
    "teorema": "lemma SecondCountableTopology.of_separableSpace_orderTopology (Œ± : Type u) : SecondCountableTopology Œ± := by"
  },
  {
    "full_name": "Rat.add_def",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "lemma Rat.add_def (a : Rat) (b : Rat) : a + b = normalize (a.num * ‚Üëb.den + b.num * ‚Üëa.den) (a.den * b.den) ‚ãØ := by"
  },
  {
    "full_name": "of_quotient_center_nilpotent",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "teorema": "lemma of_quotient_center_nilpotent (G : Type u_1) : Group.IsNilpotent G := by"
  },
  {
    "full_name": "Metric.cthickening_closure",
    "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean",
    "teorema": "lemma Metric.cthickening_closure (s : Set Œ±) (Œ± : Type u) (Œ¥ : ‚Ñù) : cthickening Œ¥ (closure s) = cthickening Œ¥ s := by"
  },
  {
    "full_name": "Real.Angle.cos_pi_div_two_sub",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "theorem Real.Angle.cos_pi_div_two_sub (Œ∏ : Angle) : (‚Üë(œÄ / 2) - Œ∏).cos = Œ∏.sin := by"
  },
  {
    "full_name": "Ideal.isMaximal_iff",
    "file_path": "Mathlib/RingTheory/Ideal/Basic.lean",
    "teorema": "lemma Ideal.isMaximal_iff (I : Ideal Œ±) (J : Ideal Œ±) (Œ± : Type u) : I < J ‚Üí J = ‚ä§ ‚Üî ‚àÄ (x : Œ±), I ‚â§ J ‚Üí x ‚àâ I ‚Üí x ‚àà J ‚Üí 1 ‚àà J := by"
  },
  {
    "full_name": "RelIso.preimage_eq_image_symm",
    "file_path": "Mathlib/Order/RelIso/Set.lean",
    "teorema": "theorem RelIso.preimage_eq_image_symm (e : r ‚âÉr s) (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (t : Set Œ≤) (Œ± : Type u_5) (Œ≤ : Type u_6) : ‚áëe ‚Åª¬π' t = ‚áëe.symm '' t := by"
  },
  {
    "full_name": "MeasureTheory.Measure.singularPart_of_not_haveLebesgueDecomposition",
    "file_path": "Mathlib/MeasureTheory/Decomposition/Lebesgue.lean",
    "teorema": "lemma MeasureTheory.Measure.singularPart_of_not_haveLebesgueDecomposition (Œ± : Type u_1) (Œº : Measure Œ±) (ŒΩ : Measure Œ±) : Œº.singularPart ŒΩ = 0 := by"
  },
  {
    "full_name": "ProbabilityTheory.cond_univ",
    "file_path": "Mathlib/Probability/ConditionalProbability.lean",
    "teorema": "theorem ProbabilityTheory.cond_univ (Œ© : Type u_1) (Œº : Measure Œ©) : Œº[|univ] = Œº := by"
  },
  {
    "full_name": "AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_fst_snd",
    "file_path": "Mathlib/AlgebraicGeometry/Gluing.lean",
    "teorema": "theorem AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_fst_snd (X : Scheme) (x : ùí∞.J) (y : ùí∞.J) (z : ùí∞.J) (ùí∞ : X.OpenCover) : ùí∞.gluedCoverT' x y z ‚â´ pullback.fst ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd := by"
  },
  {
    "full_name": "MeasurableSet.cond",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
    "teorema": "lemma MeasurableSet.cond (i : Bool) (s‚ÇÅ : Set Œ±) (s‚ÇÇ : Set Œ±) (Œ± : Type u_1) : MeasurableSet (bif i then s‚ÇÅ else s‚ÇÇ) := by"
  }
]